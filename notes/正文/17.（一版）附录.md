### B.2　参考资料II：C运算符

C语言有大量的运算符。下表按优先级从高至低的顺序列出了C运算符，并给出了其结合性。除非特别指明，否则所有运算符都是二元运算符（需要两个运算对象）。注意，一些二元运算符和一元运算符的表示符号相同，但是其优先级不同。例如，`*`（乘法运算符）和`*`（间接运算符）。表后面总结了每个运算符的用法。

**表B.2.1　C运算符**

|运算符（优先级从高至低）|结合律|
|---|---|
|`++` (后缀) `--` (后缀) `()` (函数调用) `[]` `{}` (复合字面量) `.` `->`|从左往右|
|`++` (前缀) `--` (前缀) `-` `+` `~` `!` `*` (解引用) `&` (取址) `sizeof` `_Alignof` `(类型名)`|从右往左|
|`(类型名)` (类型转换)|从右往左|
|`*` `/` `%`|从左往右|
|`+` `-` (二元运算符)|从左往右|
|`<<` `>>`|从左往右|
|`<` `<=` `>` `>=`|从左往右|
|`==` `!=`|从左往右|
|`&` (按位与)|从左往右|
|`^` (按位异或)|从左往右|
|`|` (按位或)|
|`&&` (逻辑与)|从左往右|
|`||
|`?:` (条件表达式)|从右往左|
|`=` `*=` `/=` `%=` `+=` `-=` `<<=` `>>=` `&=` `^=` `|=`|
|`,` (逗号运算符)|从左往右|

#### B.2.1　算术运算符

`+` 　把右边的值加到左边的值上。  
`+` 　作为一元运算符，生成一个大小和符号都与右边值相同的值。  
`-` 　从左边的值中减去右边的值。  
`-` 　作为一元运算符，生成一个与右边值大小相等符号相反的值。  
`*`　 把左边的值乘以右边的值。  
`/` 　把左边的值除以右边的值；如果两个运算对象都是整数，其结果要被截断。  
`%` 　得左边值除以右边值时的余数  
`++` 把右边变量的值加1 （前缀模式），或把左边变量的值加1 （后缀模式）。  
`--` 把右边变量的值减1 （前缀模式），或把左边变量的值减1 （后缀模式）。
#### B.2.2　关系运算符

下面的每个运算符都把左边的值与右边的值相比较。

|运算符|描述|
|---|---|
|`<`|小于|
|`<=`|小于或等于|
|`==`|等于|
|`>=`|大于或等于|
|`>`|大于|
|`!=`|不等于|

**关系表达式**

简单的关系表达式由关系运算符及其两侧的运算对象组成。如果关系为真，则关系表达式的值为1 ；如果关系为假，则关系表达式的值为0 。下面是两个例子：

`5 > 2` 关系为真，整个表达式的值为1 。  
`(2 + a) == a` 关系为假，整个表达式的值为0 。

#### B.2.3　赋值运算符

C语言有一个基本赋值运算符和多个复合赋值运算符。`=`运算符是基本的形式：  
　　　　　`=` 把它右边的值赋给其左边的左值。

下面的每个赋值运算符都根据它右边的值更新其左边的左值。我们使用R-H 表示右边，L-R 表示左边。

|运算符|描述|
|---|---|
|`+=`|把左边的变量加上右边的量，并把结果储存在左边的变量中。|
|`-=`|从左边的变量中减去右边的量，并把结果储存在左边的变量中。|
|`*=`|把左边的变量乘以右边的量，并把结果储存在左边的变量中。|
|`/=`|把左边的变量除以右边的量，并把结果储存在左边的变量中。|
|`%=`|得到左边量除以右边量的余数，并把结果储存在左边的变量中。|
|`&=`|把`L-H & R-H` 的值赋给左边的量，并把结果储存在左边的变量中。|
|`|=`|
|`^=`|把`L-H ^ R-H` 的值赋给左边的量，并把结果储存在左边的变量中。|
|`>>=`|把`L-H >> R-H` 的值赋给左边的量，并把结果储存在左边的变量中。|
|`<<=`|把`L-H << R-H` 的值赋给左边的量，并把结果储存在左边的变量中。|

**示例**

`rabbits *= 1.6;` 与`rabbits = rabbits * 1.6` 效果相同。

#### B.2.4　逻辑运算符

逻辑运算符通常以关系表达式作为运算对象。`!`运算符只需要一个运算对象，其他运算符需要两个运算对象，运算符左边一个，右边一个。

|运算符|描述|
|---|---|
|`&&`|逻辑与|
|`||
|`!`|逻辑非|

**1．逻辑表达式**

当且仅当两个表达式都为真时，`expresson1 && expresson 2` 的值才为真。  
两个表达式中至少有一个为真时，`expresson 1 || expresson 2` 的值就为真。  
如果`expresson` 的值为假，则`!expresson` 为真，反之亦然。

**2．逻辑表达式的求值顺序**

逻辑表达式的求值顺序是从左往右。当发现可以使整个表达式为假的条件时立即停止求值。

**3．示例**

`6 > 2 && 3 == 3` 为真。  
`!(6 > 2 && 3 == 3)` 为假。  
`x != 0 && 20/x < 5` 只有在x 是非零时才会对第2 个表达式求值。

#### B.2.5　条件运算符

`?:` 有3个运算对象，每个运算对象都是一个表达式：  
`expression1 ? expression2 : expression3`  
如果`expression1` 为真，则整个表达式的值等于`expression2` 的值；否则，等于`expression3` 的值。

**示例**

`(5 > 3) ? 1 : 2` 的值为1 。  
`(3 > 5) ? 1 : 2` 的值为2 。  
`(a > b) ? a : b` 的值是`a` 和`b` 中较大者

#### B.2.6　与指针有关的运算符

`&` 是地址运算符。当它后面是一个变量名时，`&` 给出该变量的地址。  
`*`是间接或解引用运算符。当它后面是一个指针时，`*`给出储存在指针指向地址中的值。

**示例**

`&nurse` 是变量`nurse` 的地址：

以下代码演示了地址运算符 `&` 和间接运算符 `*` 的用法。首先获取变量 `nurse` 的地址并存入指针 `ptr`，然后通过解引用指针 `ptr` 来获取 `nurse` 的值并赋给 `val`。

text

```
nurse = 22;
ptr = &nurse; /* 指向nurse的指针 */
val = *ptr;
```

以上代码的效果是把22 赋给`val` 。

#### B.2.7　符号运算符

`-` 是负号，反转运算对象的符号。  
`+` 是正号，不改变运算对象的符号。

#### B.2.8　结构和联合运算符

结构和联合使用一些运算符标识成员。成员运算符与结构和联合一起使用，间接成员运算符与指向结构或联合的指针一起使用。

**1．成员运算符**

成员运算符（`.`）与结构名或联合名一起使用，指定结构或联合中的一个成员。如果`name` 是一个结构名，`member` 是该结构模板指定的成员名，那么`name.member` 标识该结构中的这个成员。  
`name.member` 的类型就是被指定`member` 的类型。在联合中也可以用相同的方式使用成员运算符。

**示例**

下面的代码定义了一个名为 `item` 的结构变量，并使用成员运算符 `.` 将值 `1265` 赋给其 `code` 成员。

text

```
struct {
int code;
float cost;
} item;
item.code = 1265;
```

上面这条语句把1265 赋给结构变量`item` 的成员`code` 。

**2．间接成员运算符（或结构指针运算符）**

间接成员运算符（`->`）与一个指向结构或联合的指针一起使用，标识该结构或联合的一个成员。假设`ptrstr` 是一个指向结构的指针，`member` 是该结构模板指定的成员，那么`ptrstr->member` 标识了指针所指向结构的这个成员。在联合中也可以用相同的方式使用间接成员运算符。

**示例**

以下代码定义了一个结构变量 `item` 和一个指向该类型结构的指针 `ptrst`。代码将 `ptrst` 指向 `item`，然后通过间接成员运算符 `->` 将值 `3451` 赋给 `item` 的 `code` 成员。

text

```
struct {
int code;
float cost;
} item, * ptrst;
ptrst = &item;
ptrst->code = 3451;
```

以上程序段把3451 赋给结构`item` 的成员`code` 。下面3 种写法是等效的：  
`ptrst->code` `item.code` `(*ptrst).code`

#### B.2.9　按位运算符

下面所列除了`~`，都是按位运算符。

|运算符|描述|
|---|---|
|`~`|是一元运算符，它通过翻转运算对象的每一位得到一个值。|
|`&`|是逻辑与运算符，只有当两个运算对象中对应的位都为1 时，它生成的值中对应的位才为1 。|
|`|`|
|`^`|是按位异或运算符，只有两个运算对象中对应的位中只有一位为1 （不能全为1 ），它生成的值中对应的位才为1 。|
|`<<`|是左移运算符，把左边运算对象中的位向左移动得到一个值。移动的位数由该运算符右边的运算对象确定，空出的位用0 填充。|
|`>>`|是右移运算符，把左边运算对象中的位向右移动得到一个值。移动的位数由该运算符右边的运算对象确定，空出的位用0 填充。|

**示例**

假设有下面的代码：

此代码片段声明并初始化了两个整型变量 `x` 和 `y`，用于后续的按位运算示例。

text

```
int x = 2;
int y = 3;
```

`x & y` 的值为2 ，因为`x` 和`y` 的位组合中，只有第1 位均为1 。  
而`y << x` 的值为12 ，因为在`y` 的位组合中，3 的位组合向左移动两位，得到12 。
#### B.2.10　混合运算符

`sizeof` 给出它右边运算对象的大小，单位是`char` 的大小。通常，`char` 类型的大小是1 字节。运算对象可以圆括号中的类型说明符，如`sizeof(float)` ，也可以是特定的变量名、数组名等，如`sizeof foo` 。`sizeof` 表达式的类型是`size_t` 。

`_Alignof` （C11）给出它的运算对象指定类型的对齐要求。一些系统要求以特定值的倍数在地址上储存特定类型，如4 的倍数。这个整数就是对齐要求。

`(类型名)` 是强制类型转换运算符，它把后面的值转换成圆括号中关键字指定的类型。例如，`(float)9` 把整数9 转换成浮点数9.0。

`,` 是逗号运算符，它把两个表达式链接成一个表达式，并保证先对最左端的表达式求值。整个表达式的值是最右边表达式的值。该运算符通常在`for` 循环头中用于包含更多的信息。

**示例**

下面的 `for` 循环演示了逗号运算符的用法，它在循环的初始化部分同时对 `step` 和 `fargo` 两个变量进行初始化。

text

```
for (step = 2, fargo = 0; fargo < 1000; step *= 2)
fargo += step;
```

### B.3　参考资料III：基本类型和存储类别

#### B.3.1　总结：基本数据类型

C语言的基本数据类型分为两大类：整数类型和浮点数类型。不同的种类提供了不同的范围和精度。

**1．关键字**

创建基本数据类型要用到8个关键字：`int` 、`long` 、`short` 、`unsigned` 、`char` 、`float` 、`double` 、`signed` （ANSI C）。

**2．有符号整数**

有符号整数可以具有正值或负值。

`int` 是所有系统中基本整数类型。  
`long` 或`long int` 可储存的整数应大于或等于`int` 可储存的最大数；`long` 至少是32 位。  
`short` 或`short int` 整数应小于或等于`int` 可储存的最大数；`short` 至少是16 位。通常，`long` 比`short` 大。例如，在PC 中的C DOS 编译器提供16 位的`short` 和`int` 、32 位的`long` 。这完全取决于系统。  
C99 标准提供了`long long` 类型，至少和`long` 一样大，至少是64 位。

**3．无符号整数**

无符号整数只有0 和正值，这使得该类型能表示的正数范围更大。在所需的类型前面加上关键字`unsigned` ：`unsigned int` 、`unsigned long` 、`unsigned short` 、`unsigned long long` 。单独的`unsigned` 相当于`unsigned int` 。

**4．字符**

字符是如A 、& 、+ 这样的印刷符号。根据定义，`char` 类型的变量占用1字节的内存。过去，`char` 类型的大小通常是8位。然而，C在处理更大的字符集时，`char` 类型可以是16位，或者甚至是32位。  
这种类型的关键字是`char` 。一些实现使用有符号的`char` ，但是其他实现使用无符号的`char` 。ANSI C 允许使用关键字`signed` 和`unsigned` 指定所需类型。从技术层面上看，`char` 、`unsigned char` 和`signed char` 是3种不同的类型，但是`char` 类型与其他两种类型的表示方法相同。

**5．布尔类型（C99）**

`_Bool` 是C99新增的布尔类型。它一个无符号整数类型，只能储存0 （表示假）或1 （表示真）。包含`stdbool.c` 头文件后，可以用`bool` 表示`_Bool` 、`ture` 表示1 、`false` 表示0 ，让代码与C++ 兼容。

**6．实浮点数和复浮点数类型**

C99识别两种浮点数类型：实浮点数和复浮点数。浮点类型由这两种类型构成。

**实浮点数**可以是正值或负值。C识别3种实浮点类型。

`float` 是系统中的基本浮点类型。它至少可以精确表示 6 位有效数字，通常 `float` 为 32 位。  
`double` （可能）表示更大的浮点数。它能表示比 `float` 更多的有效数字和更大的指数。它至少能精确表示 10 位有效数字。通常， `double` 为 64 位。  
`long double` （可能）表示更大的浮点数。它能表示比 `double` 更多的有效数字和更大的指数。

**复数**由两部分组成：实部和虚部。C99规定一个复数在内部用一个有两个元素的数组表示，第1个元素表示实部，第2个元素表示虚部。有3种复浮点数类型。

`float _Complex` 表示实部和虚部都是 `float` 类型的值。  
`double _Complex` 表示实部虚部都是 `double` 类型的值。  
`long double _Complex` 表示实部和虚部都是 `long double` 类型的值。

每种情况，前缀部分的类型都称为相应的实数类型（corresponding real type ）。例如，`double` 是`double _Complex` 相应的实数类型。

C99中，复数类型在独立环境中是可选的，这样的环境中不需要操作系统也可运行C程序。在C11中，复数类型在独立环境和主机环境都是可选的。

有3种**虚数**类型。它们在独立环境中和主机环境中（C程序在一种操作系统下运行的环境）都是可选的。虚数只有虚部。这3种类型如下。

`float _Imaginary` 表示虚部是 `float` 类型的值。  
`double _Imaginary` 表示虚部是 `double` 类型的值。  
`long double _Imaginary` 表示虚部是 `long double` 类型的值。

可以用实数和`I` 值来初始化复数。`I` 定义在`complex.h` 头文件中，表示i （即-1 的平方根）。

这段代码演示了如何使用 `complex.h` 头文件中的 `I` 宏来初始化不同值的复数变量。

text

```
#include <complex.h> // I定义在该头文件中
double _Complex z = 3.0; // 实部 = 3.0，虚部 = 0
double _Complex w = 4.0 * I; // 实部 = 0.0，虚部 = 4.0
double Complex u = 6.0 – 8.0 * I; //实部= 6.0，虚部 = -8.0
```

前面章节讨论过，`complex.h` 库包含一些返回复数实部和虚部的函数。

#### B.3.2　总结：如何声明一个简单变量

1. 选择所需的类型。
2. 选择一个合适的变量名。
3. 使用这种声明格式： `type-specifiervariable-name;`  
    `type-specifier` 由一个或多个类型关键字组成，下面是一些例子：  
    `int erest;`  
    `unsigned short cash;`
4. 声明多个同类型变量时，使用逗号分隔符隔开各变量名：  
    `char ch, init, ans;`
5. 可以在声明的同时初始化变量：  
    `float mass = 6.0E24;`

**总结：存储类别**

**关键字：** `auto` 、`extern` 、`static` 、`register` 、`_Thread_local` （C11 ）

**一般注解：**  
变量的存储类别取决于它的作用域、链接和存储期。存储类别由声明变量的位置和与之关联的关键字决定。定义在所有函数外部的变量具有文件作用域、外部链接、静态存储期。声明在函数中的变量是自动变量，除非该变量前面使用了其他关键字。它们具有块作用域、无链接、自动存储期。以`static` 关键字声明在函数中的变量具有块作用域、无链接、静态存储期。以`static` 关键字声明在函数外部的变量具有文件作用域、内部链接、静态存储期。  
C11 新增了一个存储类别说明符：`_Thread_local` 。以该关键字声明的对象具有线程存储期，意思是在线程中声明的对象在该线程运行期间一直存在，且在线程开始时被初始化。因此，这种对象属于线程私有。

**属性：**  
下面总结了这些存储类别的属性：

|存储类别|存储期|作用域|链接|如何声明|
|---|---|---|---|---|
|自动|自动|块|无|在块中|
|寄存器|自动|块|无|在块中，使用关键字`register`|
|静态、外部链接|静态|文件|外部|在所有函数外部|
|静态、内部链接|静态|文件|内部|在所有函数外部，使用关键字`static`|
|静态、无链接|静态|块|无|在块中，使用关键字`static`|
|线程、外部链接|线程|文件|外部|在所有块的外部，使用关键字`_Thread_local`|
|线程、内部链接|线程|文件|内部|在所有块的外部，使用关键字`static` 和 `_Thread_local`|
|线程、无链接|线程|块|无|在块中，使用关键字`static` 和 `_Thread_local`|

注意，关键字`extern` 只能用来再次声明在别处已定义过的变量。在函数外部定义变量，该变量具有外部链接属性。

除了以上介绍的存储类别，C还提供了动态分配内存。这种内存通过调用`malloc()` 函数系列中的一个函数来分配。这种函数返回一个可用于访问内存的指针。调用`free()` 函数或结束程序可以释放动态分配的内存。任何可以访问指向该内存指针的函数均可访问这块内存。例如，一个函数可以把这个指针的值返回给另一个函数，那么另一个函数也可以访问该指针所指向的内存。

#### B.3.3　总结：限定符

**关键字**  
使用下面关键字限定变量：  
`const`、`volatile`、`restrict`

**一般注释**  
限定符用于限制变量的使用方式。不能改变初始化以后的`const`变量。编译器不会假设`volatile` 变量不被某些外部代理（如，一个硬件更新）改变。`restrict` 限定的指针是访问它所指向内存的唯一方式（在特定作用域中）。

**属性**  
`const int joy = 101;` 声明创建了变量`joy` ，它的值被初始化为101 。  
`volatile unsigned int incoming;` 声明创建了变量`incoming` ，该变量在程序中两次出现之间，其值可能会发生改变。  
`const int * ptr = &joy;` 声明创建了指针`ptr` ，该指针不能用来改变变量`joy` 的值，但是它可以指向其他位置。  
`int * const ptr = &joy;` 声明创建了指针`ptr` ，不能改变该指针的值，即`ptr` 只能指向`joy` ，但是可以用它来改变`joy` 的值。  
`void simple (const char * s);` 声明表明形式参数`s` 被传递给`simple()` 的值初始化后，`simple()` 不能改变`s` 指向的值。  
`void supple(int * const pi);` 与`void supple(int pi[const]);` 等价。这两个声明都表明`supple()` 函数不会改变形参`pi` 。  
`void interleave(int * restrict p1, int * restrict p2, int n);` 声明表明`p1` 和`p2` 是访问它们所指向内存的唯一方法，这意味着这两个块不能重叠。
### B.4　参考资料IV：表达式、语句和程序流

#### B.4.1　总结：表达式和语句

在C语言中，对表达式可以求值，通过语句可以执行某些行为。

**表达式**  
表达式 由运算符和运算对象组成。最简单的表达式是一个常量或一个不带运算符的变量，如`22` 或`beebop` 。稍复杂些的例子是`55 + 22` 和`vap = 2 * (vip + (vup = 4))` 。

**语句**  
大部分语句都以分号结尾。以分号结尾的表达式都是语句，但这样的语句不一定有意义。语句分为简单语句和复合语句。简单语句 以分号结尾，如下所示：

`toes = 12;` // 赋值表达式语句  
`printf("%d\n", toes);` // 函数调用表达式语句  
`;` //空语句，什么也不做

（注意，在C语言中，声明不是语句。）

用花括号括起来的一条或多条语句是复合语句 或块 。如下面的`while` 语句所示：

下面是一个 `while` 循环，它包含一个复合语句（代码块），在每次循环中递增 `wisdom` 和 `years`，并打印它们的值。

text

```
while (years < 100)
{
wisdom = wisdom + 1;
printf("%d %d\n", years, wisdom);
years = years + 1;
}
```

#### B.4.2　总结：while 语句

**关键字**  
`while` 语句的关键字是`while` 。

**一般注释**  
`while` 语句创建了一个循环，在 `expression` 为假之前重复执行。`while` 语句是一个入口条件 循环，在下一轮迭代之前先确定是否要再次循环。因此可能一次循环也不执行。 `statement` 可以是一个简单语句或复合语句。

**形式**  
这是 `while` 循环的基本结构。只要 `expression` 的值为真（非零），`statement` 部分就会被重复执行。

text

```
while ( expression
)
statement
```

当 `expression` 为假（或0 ）之前，重复执行 `statement` 部分。

**示例**  
这个 `while` 循环在其条件判断中使用了后递增运算符 `n++`。

text

```
while (n++ < 100)
printf(" %d %d\n",n, 2*n+1);
```

这个 `while` 循环包含一个代码块，在每次迭代中更新 `fargo` 和 `step` 两个变量。

text

```
while (fargo < 1000)
{
fargo = fargo + step;
step = 2 * step;
}
```

#### B.4.3　总结：for 语句

**关键字**  
`for` 语句的关键字是`for` 。

**一般注释**  
`for` 语句使用 3个控制表达式控制循环过程，分别用分号隔开。`initialize` 表达式在执行 `for` 语句之前只执行一次；然后对 `test` 表达式求值，如果表达式为真（或非零），执行循环一次；接着对`update` 表达式求值，并再次检查 `test` 表达式。 `for` 语句是一种入口条件循环，即在执行循环之前就决定了是否执行循环。因此， `for` 循环可能一次都不执行。 `statement` 部分可以是一条简单语句或复合语句。

**形式：**  
这是 `for` 循环的基本结构，它由初始化、测试条件和更新三部分组成。

text

```
for ( initialize; test; update
)
statement
```

在 `test` 为假或 0 之前，重复执行 `statement` 部分。  
C99允许在`for` 循环头中包含声明。变量的作用域和生命期被限制在`for` 循环中。

**示例：**  
这是一个标准的 `for` 循环，从 `n` 等于0迭代到9。

text

```
for (n = 0; n < 10 ; n++)
printf(" %d %d\n", n, 2 * n + 1);
```

这个 `for` 循环展示了C99标准允许的特性，即在循环的初始化部分声明并初始化循环变量 `k`。

text

```
for (int k = 0; k < 10 ; ++k) // C99
printf("%d %d\n", k, 2 * k+1);
```

#### B.4.4　总结：do　while 语句

**关键字**  
`do　while` 语句的关键字是`do` 和`while` 。

**一般注解：**  
`do　while` 语句创建一个循环，在 `expression` 为假或 0 之前重复执行循环体中的内容。 `do　while` 语句是一种出口条件循环，即在执行完循环体后才根据测试条件决定是否再次执行循环。因此，该循环至少必须执行一次。 `statement` 部分可是一条简单语句或复合语句。

**形式：**  
这是 `do while` 循环的基本结构。它保证 `statement` 至少被执行一次，因为条件判断 `expression` 在循环体之后。

text

```
do
statement
while ( expression
);
```

在 `test` 为假或0 之前，重复执行 `statement` 部分。

**示例：**  
这个 `do while` 循环会持续读取用户输入的整数，直到输入的数字为 `20` 时循环结束。

text

```
do
scanf("%d", &number);
while (number != 20);
```

#### B.4.5　总结：if 语句

**小结：用if 语句进行选择**

**关键字：** `if` 、`else`

**一般注解：**  
下面各形式中， `statement` 可以是一条简单语句或复合语句。表达式为真说明其值是非零值。

**形式 1 ：**  
这是最简单的 `if` 语句形式，仅当 `expression` 为真时才执行 `statement`。

text

```
if (expression
)
statement
```

如果 `expression` 为真，则执行 `statement` 部分。

**形式 2 ：**  
这是 `if-else` 语句，根据 `expression` 的真假来二选一执行对应的语句。

text

```
if (expression
)
statement1
else
statement2
```

如果 `expression` 为真，执行 `statement1` 部分；否则，执行`statement2` 部分。

**形式 3 ：**  
这是 `if-else if-else` 链，用于处理多个互斥的条件。

text

```
if (expression1
)
statement1
else if (expression2
)
statement2
else
statement3
```

如果 `expression1` 为真，执行 `statement1` 部分；如果`expression2` 为真，执行 `statement2` 部分；否则，执行`statement3` 部分。

**示例：**  
这个例子展示了如何使用 `if-else if-else` 结构来根据变量 `legs` 的值执行不同的操作。

text

```
if (legs == 4)
printf("It might be a horse.\n");
else if (legs > 4)
printf("It is not a horse.\n");
else /* 如果legs < 4 */
{
legs++;
printf("Now it has one more leg.\n");
}
```

#### B.4.6　带多重选择的switch语句

**关键字：** `switch`

**一般注解：**  
程序控制根据 `expression` 的值跳转至相应的`case` 标签处。然后，程序流执行剩下的所有语句，除非执行到`break` 语句进行重定向。 `expression` 和`case` 标签都必须是整数值（包括`char` 类型），标签必须是常量或完全由常量组成的表达式。如果没有`case` 标签与 `expression` 的值匹配，控制则转至标有`default` 的语句（如果有的话）；否则，控制将转至紧跟在`switch` 语句后面的语句。控制转至特定标签后，将执行`switch` 语句中其后的所有语句，除非到达`switch` 末尾，或执行到`break` 语句。

**形式：**  
这是 `switch` 语句的基本结构，它根据 `expression` 的值跳转到匹配的 `case` 标签。

text

```
switch ( expression
)
{
case label1
: statement1
//使用break跳出switch
case label2
: statement2
default : statement3
}
```

可以有多个标签语句，`default` 语句可选。

**示例：**  
这个 `switch` 语句根据 `value` 的值来选择执行不同的动作，并使用 `break` 在每个 `case` 结束后跳出 `switch` 结构。

text

```
switch (value)
{
case 1 : find_sum(ar, n);
break;
case 2 : show_array(ar, n);
break;
case 3 : puts("Goodbye!");
break;
default : puts("Invalid choice, try again.");
break;
}
```

这个 `switch` 语句演示了“穿透”（fall-through）行为。因为 `case 'a'` 和 `case 'e'` 后面没有 `break` 语句，如果 `letter` 是 'a' 或 'e'，程序会继续执行后续 `case` 中的代码。

text

```
switch (letter)
{
case 'a' :
case 'e' : printf("%d is a vowel\n", letter);
case 'c' :
case 'n' : printf("%d is in \"cane\"\n", letter);
default : printf("Have a nice day.\n");
}
```

如果`letter` 的值是`'a'` 或`'e'` ，就打印这3 条消息；如果`letter` 的值是`'c'` 或`'n'` ，则只打印后两条消息；`letter` 是其他值时，值打印最后一条消息。
#### B.4.7　总结：程序跳转

**关键字：** `break` 、`continue` 、`goto`

**一般注解：**  
这3种语句都能使程序流从程序的一处跳转至另一处。

**break 语句：**  
所有的循环和`switch` 语句都可以使用`break` 语句。它使程序控制跳出当前循环或`switch` 语句的剩余部分，并继续执行跟在循环或`switch` 后面的语句。

**示例：**  
这个 `while` 循环读取并打印字符，直到遇到空格字符，此时 `break` 语句会立即终止循环。

text

```
while ((ch = getchar()) != EOF)
{
putchar(ch);
if (ch == ' ')
break; // 结束循环
chcount++;
}
```

**continue 语句：**  
所有的循环都可以使用`continue` 语句，但是`switch` 语句不行。`continue` 语句使程序控制跳出循环的剩余部分。对于`while` 或`for` 循环，程序执行到`continue` 语句后会开始进入下一轮迭代。对于`do　while` 循环，对出口条件求值后，如有必要会进入下一轮迭代。

**示例：**  
这个程序段读取字符，如果字符是空格，`continue` 语句会跳过循环体中剩余的 `putchar` 和 `chcount++` 语句，直接开始下一次循环迭代。这样就实现了打印并统计所有非空格字符的功能。

text

```
while ((ch = getchar()) != EOF)
{
if (ch == ' ')
continue; // 跳转至测试条件
putchar(ch);
chcount++;
}
```

以上程序段打印用户输入的内容并统计非空格字符

**goto 语句：**  
`goto` 语句使程序控制跳转至相应标签语句。冒号用于分隔标签和标签语句。标签名遵循变量命名规则。标签语句可以出现在`goto` 的前面或后面。

**形式：**  
这展示了 `goto` 语句的基本语法，程序执行到 `goto label;` 时会无条件跳转到 `label:` 所在的位置。

text

```
goto label
;
.
.
.
label : statement
```

**示例：**  
这段代码使用 `goto` 创建了一个循环：如果读取到的字符 `ch` 不是 'y'，程序就跳转回 `top` 标签处，重新执行 `getchar()`。

text

```
top : ch = getchar();
.
.
.
if (ch != 'y')
goto top;
```

### B.5　参考资料V：新增C99和C11的 ANSI C库

ANSI C库把函数分成不同的组，每个组都有相关联的头文件。本节将概括地介绍库函数，列出头文件并简要描述相关的函数。文中会较详细地介绍某些函数（例如，一些I/O函数）。欲了解完整的函数说明，请参考具体实现的文档或参考手册，或者试试这个在线参考： `http://www.acm.uiuc．edu/webmonkeys/book/c_guide/` 。

#### B.5.1　断言：assert.h

`assert.h` 头文件中把`assert()` 定义为一个宏。在包含`assert.h` 头文件之前定义宏标识符`NDEBUG` ，可以禁用`assert()` 宏。通常用一个关系表达式或逻辑表达式作为`assert()` 的参数，如果运行正常，那么程序在执行到该点时，作为参数的表达式应该为真。表B.5.1描述了`assert()` 宏。

**表B.5.1　断言宏**

|原型|描述|
|---|---|
|`void assert(int exprs);`|如果`exprs` 为0 （或真），宏什么也不做。如果`exprs` 为0 （或假），`assert()` 就显示该表达式和其所在的行号和文件名。然后，`assert()` 调用`abort()`|

C11新增了`static_assert` 宏，展开为`_Static_assert` 。`_Static_assert` 是一个关键字，被认为是一种声明形式。它以这种方式提供一个编译时检查：

这是 `_Static_assert` 的声明形式，它在编译时检查一个常量表达式。

text

```
_Static_assert( 常量表达式,字符串字面量);
```

如果对常量表达式求值为0 ，编译器会给出一条包含字符串字面量的错误消息；否则，没有任何效果。

#### B.5.2　复数：complex.h （C99）

C99标准支持复数计算，C11进一步支持了这个功能。实现除提供`_Complex` 类型外还可以选择是否提供`_Imaginary` 类型。在C11中，可以选择是否提供这两种类型。C99规定，实现必须提供`_Complex` 类型，但是`_Imaginary` 类型为可选，可以提供或不提供。附录B的参考资料VIII中进一步讨论了C 如何支持复数。  
`complex.h` 头文件中定义了表B.5.2所列的宏。

**表B.5.2　complex.h 宏**

|宏|描述|
|---|---|
|`complex`|展开为类型关键字`_Complex`|
|`_Complex_I`|展开为`const float _Complex` 类型的表达式，其值的平方是-1|
|`imaginary`|如果支持虚数类型，展开为类型关键字`_Imaginary`|
|`_Imaginary_I`|如果支持虚数类型，展开为`const float _Imaginary` 类型的表达式，其值的平方是-1|
|`I`|展开为`_Complex_I` 或`_Imaginary_I`|

对于实现复数方面，C和C++不同。C通过`complex.h` 头文件支持，而C++通过`complex` 头文件支持。而且，C++使用类来定义复数类型。

可以使用`STDC CX_LIMITED_RANGE` 编译指令来表明是使用普通的数学公式（设置为`on` 时），还是要特别注意极值（设置为`off` 时）：

这段代码展示了如何使用 `pragma` 指令来控制复数计算的范围检查。

text

```
#include <complex.h>
#pragma STDC CX_LIMITED_RANGE on
```

库函数分为3种：`double` 、`float` 、`long double` 。表B.5.3列出了`double` 版本的函数。`float` 和`long double` 版本只需要在函数名后面分别加上`f` 和`l` 。即`csinf()` 就是`csin()` 的`float` 版本，而`csinl()` 是`csin()` 的`long double` 版本。另外要注意，角度的单位是弧度。

**表B.5.3　复数函数**

|原型|描述|
|---|---|
|`double complex cacos(double complex z);`|返回z 的复数反余弦|
|`double complex casin(double complex z);`|返回z 的复数反正弦|
|`double complex catan(double complex z);`|返回z 的复数反正切|
|`double complex ccos(double complex z);`|返回z 的复数余弦|
|`double complex csin(double complex z);`|返回z 的复数正弦|
|`double complex ctan(double complex z);`|返回z 的复数正切|
|`double complex cacosh(double complex z);`|返回z 的复数反双曲余弦|
|`double complex casinh(double complex z);`|返回z 的复数反双曲正弦|
|`double complex catanh(double complex z);`|返回z 的复数反双曲正切|
|`double complex ccosh(double complex z);`|返回z 的复数双曲余弦|
|`double complex csinh(double complex z);`|返回z 的复数双曲正弦|
|`double complex ctanh(double complex z);`|返回z 的复数双曲正切|
|`double complex cexp(double complex z);`|返回e 的z 次幂复数值|
|`double complex clog(double complex z);`|返回z 的自然对数（以e 为底）的复数值|
|`double cabs(double complex z);`|返回z 的绝对值（或大小）|
|`double complex cpows(double complex z, double complex y);`|返回z 的y 次幂|
|`double complex csqrt(double complex z);`|返回z 的复数平方根|
|`double carg(double complex z);`|以弧度为单位返回z 的相位角（或幅角）|
|`double cimag(double complex z);`|以实数形式返回z 的虚部|
|`double complex conj(double complex z);`|返回z 的共轭复数|
|`double complex cproj(double complex z);`|返回z 在黎曼球面上的投影|
|`double complex CMPLX(double x,double y);`|返回实部为x 、虚部为y 的复数（C11）|
|`double creal(double complex z);`|以实数形式返回z 的实部|

#### B.5.3　字符处理：ctype.h

这些函数都接受`int` 类型的参数，这些参数可以表示为`unsigned char` 类型的值或`EOF` 。使用其他值的效果是未定义的。在表B.5.4中，“真”表示“非0 值”。对一些定义的解释取决于当前的本地设置，这些由`locale.h` 中的函数来控制。该表显示了在解释本地化的“C ”时要用到的一些函数。

**表B.5.4　字符处理函数**

|原型|描述|
|---|---|
|`int isalnum(int c);`|如果c 是字母或数字，则返回真|
|`int isalpha(int c);`|如果c 是字母，则返回真|
|`int isblank(int c);`|如果c 是空格或水平制表符，则返回真（C99 ）|
|`int iscntrl(int c);`|如果c 是控制字符（如Ctrl+B ），则返回真|
|`int isdigit(int c);`|如果c 是数字，则返回真|
|`int isgraph(int c);`|如果c 是非空格打印字符，则返回真|
|`int islower(int c);`|如果c 是小写字符，则返回真|
|`int isprint(int c);`|如果c 是打印字符，则返回真|
|`int ispunct(int c);`|如果c 是标点字符（除了空格、字母、数字以外的字符），则返回真|
|`int isspace(int c);`|如果c 是空白字符（空格、换行符、换页符、回车符、垂直或水平制表符，或者其他实现定义的字符），则返回真|
|`int isupper(int c);`|如果c 是大写字符，则返回真|
|`int isxdigit(int c);`|如果c 是十六进制数字字符，则返回真|
|`int tolower(int c);`|如果c 是大写字符，则返回其小写字符；否则返回c|
|`int toupper(int c);`|如果c 是小写字符，则返回其大写字符；否则返回c|

#### B.5.4　错误报告：errno.h

`errno.h` 头文件支持较老式的错误报告机制。该机制提供一个标识符（或有时称为宏）`ERRNO` 可访问的外部静态内存位置。一些库函数把一个值放进这个位置用于报告错误，然后包含该头文件的程序就可以通过查看`ERRNO` 的值检查是否报告了一个特定的错误。`ERRNO` 机制被认为不够艺术，而且设置`ERRNO` 值也不需要数学函数了。标准提供了3 个宏值表示特殊的错误，但是有些实现会提供更多。表B.5.5列出了这些标准宏。

**表B.5.5　errno.h 宏**

|宏|含义|
|---|---|
|`EDOM`|函数调用中的域错误（参数越界）|
|`ERANGE`|函数返回值的范围错误（返回值越界）|
|`EILSEQ`|宽字符转换错误|

#### B.5.5　浮点环境：fenv.h （C99）

C99标准通过`fenv.h` 头文件提供访问和控制浮点环境。  
浮点环境 （floating-point environment ）由一组状态标志（status flag ）和控制模式 （control mode ）组成。在浮点计算中发生异常情况时（如，被零除），可以“抛出一个异常”。这意味着该异常情况设置了一个浮点环境标志。控制模式值可以进行一些控制，例如控制舍入的方向。`fenv.h` 头文件定义了一组宏表示多种异常情况和控制模式，并提供了与环境交互的函数原型。头文件还提供了一个编译指令来启用或禁用访问浮点环境的功能。

下面的指令开启访问浮点环境：

text

```
#pragma STDC FENV_ACCESS on
```

下面的指令关闭访问浮点环境：

text

```
#pragma STDC FENV_ACCESS off
```

应该把该编译指示放在所有外部声明之前或者复合块的开始处。在遇到下一个编译指示之前、或到达文件末尾（外部指令）、或到达复合语句的末尾（块指令），当前编译指示一直有效。  
头文件定义了两种类型，如表B.5.6所示。

**表B.5.6　fenv.h 类型**

|类型|表示|
|---|---|
|`fenv_t`|整个浮点环境|
|`fexcept_t`|浮点状态标志集合|

头文件定义了一些宏，表示一些可能发生的浮点异常情况控制状态。其他实现可能定义更多的宏，但是必须以`FE_` 开头，后面跟大写字母。表B.5.7列出了一些标准异常宏。

**表B.5.7　fenv.h 中的标准异常宏**

|宏|含义|
|---|---|
|`FE_DIVBYZERO`|抛出被零除异常|
|`FE_INEXACT`|抛出不精确值异常|
|`FE_INVALID`|抛出无效值异常|
|`FE_OVERFLOW`|抛出上溢异常|
|`FE_UNDERFLOW`|抛出下溢异常|
|`FE_ALL_EXCEPT`|实现支持的所有浮点异常的按位或|
|`FE_DOWNWARD`|向下舍入|
|`FE_TONEAREST`|向最近的舍入|
|`FE_TOWARDZERO`|趋0 舍入|
|`FE_UPWARD`|向上舍入|
|`FE_DFL_ENV`|表示默认环境，类型是`const fenv_t *`|

表B.5.8中列出了`fenv.h` 头文件中的标准函数原型。注意，常用的参数值和返回值与表B.5.7中的宏相对应。例如，`FE_UPWARD` 是`fesetround()` 的一个合适参数。

**表B.5.8　fenv.h 中的标准函数原型**

| 原型                                                           | 描述                                                                                                                   |
| ------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------- |
| `void feclearexcept(int excepts);`                           | 清理`excepts` 表示的异常                                                                                                    |
| `void fegetexceptflag(fexcept_t *flagp, int excepts);`       | 把`excepts` 指明的浮点状态标志储存在`flagp` 指向的对象中                                                                                |
| `void feraiseexcept(int excepts);`                           | 抛出`excepts` 指定的异常                                                                                                    |
| `void fesetexceptflag(const fexcept_t *flagp, int excepts);` | 把`excepts` 指明的浮点状态标志设置为`flagp` 的值；在此之前，`fegetexceptflag()` 调用应该设置`flagp` 的值                                          |
| `int fetestexcept(int excepts);`                             | 测试`excepts` 指定的状态标志；该函数返回指定状态标志的按位或                                                                                  |
| `int fegetround(void);`                                      | 返回当前的舍入方向                                                                                                            |
| `int fesetround(int round);`                                 | 把舍入方向设置为`round` 的值；当且仅当设置成功时，函数返回0                                                                                   |
| `void fegetenv(fenv_t *envp);`                               | 把当前环境储存至`envp` 指向的位置中                                                                                                |
| `int feholdexcept(fenv_t *envp);`                            | 把当前浮点环境储存至`envp` 指向的位置中，清除浮点状态标志，然后如果可能的话就设置非停模式（nonstop mode ），在这种模式中即使发生异常也继续执行。当且仅当执行成功时，函数返回0                    |
| `void fesetenv(const fenv_t *envp);`                         | 建立`envp` 表示的浮点环境；`envp` 应指向一个之前通过调用`fegetenv()` 、`feholdexcept()` 或浮点环境宏设置的数据对象                                      |
| `void feupdateenv (const fenv_t *envp);`                     | 函数在自动存储区中储存当前抛出的异常，建立`envp` 指向的对象表示的浮点环境，然后抛出已储存的浮点异常；`envp` 应指向一个之前通过调用`fegetenv()` 、`feholdexcept()` 或浮点环境宏设置的数据对象 |
#### B.5.6　浮点特性：float.h

`float.h` 头文件中定义了一些表示各种限制和形参的宏。表B.5.9列出了这些宏，C11新增的宏以斜体并缩进标出。许多宏都涉及下面的浮点表示模型：

x=sbe∑k=1pfkb−kx=sbek=1∑p​fkb−k​

如果第1个数f 1 是非0 （且x 是非0 ），该数字被称为标准化浮点数 。附录B的参考资料VIII中将更详细地解释一些宏。

**表B.5.9　float.h 宏**

|宏|含义|
|---|---|
|`FLT_ROUNDS`|默认舍入方案|
|`FLT_EVAL_METHOD`|浮点表达式求值的默认方案|
|`FLT_HAS_SUBNORM`|存在或缺少`float` 类型的反常值|
|`DBL_HAS_SUBNORM`|存在或缺少`double` 类型的反常值|
|`LDBL_HAS_SUBNORM`|存在或缺少`long double` 类型的反常值|
|`FLT_RADIX` [1]|指数表示法中使用的进制数(b) ，最小值为2|
|`FLT_MANT_DIG`|以`FLT_RADIX` 进制表示的`float` 类型数的位数（模型中的p ）|
|`DBL_MANT_DIG`|以`FLT_RADIX` 进制表示的`double` 类型数的位数（模型中的p ）|
|`LDBL_MANT_DIG`|以`FLT_RADIX` 进制表示的`long double` 类型数的位数（模型中的p ）|
|`FLT_DECIMAL_DIG`|在b 进制和十进制相互转换不损失精度的前提下，`float` 类型的十进制数的位数（最小值是6 ）|
|`DBL_DECIMAL_DIG`|在b 进制和十进制相互转换不损失精度的前提下，`double` 类型的十进制数的位数（最小值是10 ）|
|`LDBL_DECIMAL_DIG`|在b 进制和十进制相互转换不损失精度的前提下，`long double` 类型的十进制数的位数（最小值是10 ）|
|`DECIMAL_DIG`|在b 进制与十进制相互转换不损失精度的前提下，浮点类型十进制数的最大个数（最小值为10 ）|
|`FLT_DIG`|在不损失精度的前提下，`float` 类型可表示的十进制数位数（最小值为6 ）|
|`DBL_DIG`|在不损失精度的前提下，`double` 类型可表示的十进制数位数（最小值为10 ）|
|`LDBL_DIG`|在不损失精度的前提下，`long double` 类型可表示的十进制数位数（最小值为10 ）|
|`FLT_MIN_EXP`|`float` 类型e 表示法，指数的最小负正整数值|
|`DBL_MIN_EXP`|`double` 类型e 表示法，指数的最小负正整数值|
|`LDBL_MIN_EXP`|`long double` 类型e 表示法，指数的最小负正整数值|
|`FLT_MIN_10_EXP`|用10 的x 次幂表示规范化`float` 类型数时，x 的最小负整数值（不超过-37 ）|
|`DBL_MIN_10_EXP`|用10 的x 次幂表示规范化`double` 类型数时，x 的最小负整数值（不超过-37 ）|
|`LDBL_MIN_10_EXP`|用10 的x 次幂表示规范化`long double` 类型数时，x 的最小负整数值（不超过-37 ）|
|`FLT_MAX_EXP`|`float` 类型e 表示法，指数的最大正整数值|
|`DBL_MAX_EXP`|`double` 类型e 表示法，指数的最大正整数值|
|`LDBL_MAX_EXP`|`long double` 类型e 表示法，指数的最大正整数值|
|`FLT_MAX_10_EXP`|用10 的x 次幂表示规范化`float` 类型数时，x 的最大正整数值（至少+37 ）|
|`DBL_MAX_10_EXP`|用10 的x 次幂表示规范化`double` 类型数时，x 的最大正整数值（至少+37 ）|
|`LDBL_MAX_10_EXP`|用10 的x 次幂表示规范化`long double` 类型数时，x 的最大正整数值（至少+37 ）|
|`FLT_MAX`|`float` 类型的最大有限值（至少1E+37 ）|
|`DBL_MAX`|`doble` 类型的最大有限值（至少1E+37 ）|
|`LDBL_MAX`|`long double` 类型的最大有限值（至少1E+37 ）|
|`FLT_EPSILON`|`float` 类型比1 大的最小值与1 的差值（不超过1E-9 ）|
|`DBL_EPSILON`|`double` 类型比1 大的最小值与1 的差值（不超过1E-9 ）|
|`LDBL_EPSILON`|`long double` 类型比1 大的最小值与1 的差值（不超过1E-9 ）|
|`FLT_MIN`|标准化`float` 类型的最小正值（不超过1E-37 ）|
|`DBL_MIN`|标准化`double` 类型的最小正值（不超过1E-37 ）|
|`LDBL_MIN`|标准化`long double` 类型的最小正值（不超过1E-37 ）|
|`FLT_TRUE_MIN`|`float` 类型的最小正值（不超过1E-37 ）|
|`DBL_TRUE_MIN`|`double` 类型的最小正值（不超过1E-37 ）|
|`LDBL_TRUE_MIN`|`long double` 类型的最小正值（不超过1E-37 ）|

#### B.5.7　整数类型的格式转换：inttypes.h

该头文件定义了一些宏可用作转换说明来扩展整数类型。参考资料VI“扩展的整数类型”将进一步讨论。该头文件还声明了这个类型：`imaxdiv_t` 。这是一个结构类型，表示`idivmax()` 函数的返回值。

该头文件中还包含`stdint.h` ，并声明了一些使用最大长度整数类型的函数，这种整数类型在`stdint.h` 中声明为`intmax` 。表B.5.10列出了这些函数。

**表B.5.10　使用最大长度整数的函数**

|原型|描述|
|---|---|
|`intmax_t imaxabs(intmax_t j);`|返回j 的绝对值|
|`imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);`|单独计算`numer/denom` 的商和余数，并把两个计算结果储存在返回的结构中|
|`intmax_t strtoimax(const char * restrict nptr, char ** restrict endptr, int base);`|相当于`strtol()` 函数，但是该函数把字符串转换成`intmax_t` 类型并返回该值|
|`uintmax_t strtoumax(const char * restrict nptr, char ** restrict endptr, int base);`|相当于`strtoul()` 函数，但是该函数但是该函数把字符串转换成`intmax_t` 类型并返回该值|
|`intmax_t wcstoimax(const wchar_t * restrict nptr, wchar_t ** restrict endptr, int base);`|`strtoimax()` 函数的`wchar_t` 类型的版本|
|`uintmax_t wcstoumax(const wchar_t * restrict nptr, wchar_t ** restrict endptr, int base);`|`strtoumax()` 函数的`wchar_t` 类型的版本|

#### B.5.8　可选拼写：iso646.h

该头文件提供了11个宏，扩展了指定的运算符，如表B.5.11所列。

**表B.5.11　可选拼写**

|宏|运算符|宏|运算符|宏|运算符|
|---|---|---|---|---|---|
|`and`|`&&`|`and_eq`|`&=`|`bitand`|`&`|
|`bitor`|`|`|`compl`|`~`|`not`|
|`not_eq`|`!=`|`or`|`||`|
|`xor`|`^`|`xor_eq`|`^=`|||

#### B.5.9　本地化：locale.h

本地化 是一组设置，用于控制一些特定的设置项，如表示小数点的符号。本地值储存在`struct lconv` 类型的结构中，定义在`locale.h` 头文件中。可以用一个字符串来指定本地化，该字符串指定了一组结构成员的特殊值。默认的本地化由字符串`"C"` 指定。表B.5.12列出了本地化函数，后面做了简要说明。

**表B.5.12　本地化函数**

|原型|描述|
|---|---|
|`char * setlocale(int category, const char * locale);`|该函数把某些值设置为本地和`locale` 指定的值。`category` 的值决定要设置哪些本地值（参见B.5.13）。如果成功设置本地化，该函数将返回一个在新本地化中与指定类别相关联的指针；如果不能完成本地化请求，则返回空指针|
|`struct lconv *localeconv(void);`|返回一个指向`struct lconv` 类型结构的指针，该结构中储存着当前的本地值|

`setlocale()` 函数的`locale` 形参所需的值可能是默认值`"C"` ，也可能是`""` ，表示实现定义的本地环境。实现可以定义更多的本地化设置。`category` 形参的值可能由表B.5.13中所列的宏表示。

**表B.5.13　category 宏**

|宏|描述|
|---|---|
|`NULL`|本地化设置不变，返回指向当前本地化的指针|
|`LC_ALL`|改变所有的本地值|
|`LC_COLLATE`|改变`strcoll()` 和`strxfrm()` 所用的排列顺序的本地值|
|`LC_CTYPE`|改变字符处理函数和多字节函数的本地值|
|`LC_MONETARY`|改变货币格式信息的本地值|
|`LC_NUMERIC`|改变十进制小数点符号和格式化I/O 使用的非货币格式本地值|
|`LC_TIME`|改变`strftime()` 所用的时间格式本地值|

表B.5.14列出了`struct lconv` 结构所需的成员。

**表B.5.14　struct lcconv 所需的成员**

|成员变量|描述|
|---|---|
|`char *decimal_point`|非货币值的小数点字符|
|`char *thousands_sep`|非货币值中小数点前面的千位分隔符|
|`char *grouping`|一个字符串，表示非货币量中每组数字的大小|
|`char *int_curr_symbol`|国际货币符号|
|`char *currency_symbol`|本地货币符号|
|`char *mon_decimal_point`|货币值的小数点符号|
|`char *mon_thousands_sep`|货币值的千位分隔符|
|`char *mon_grouping`|一个字符串，表示货币量中每组数字的大小|
|`char *positive_sign`|指明非负格式化货币值的字符串|
|`char *negative_sign`|指明负格式化货币值的字符串|
|`char int_frac_digits`|国际格式化货币值中，小数点后面的数字个数|
|`char frac_digits`|本地格式化货币值中，小数点后面的数字个数|
|`char p_cs_precedes`|如果该值为1 ，则`currency_symbol` 在非负格式化货币值的前面；如果该值为0 ，则`currency_symbol` 在非负格式化货币值的后面|
|`char p_sep_by_space`|如果该值为1 ，则用空格把`currency_symbol` 和非负格式化货币值隔开；如果该值为0 ，则不用空格分隔`currency_symbol` 和非负格式化货币值|
|`char n_cs_precedes`|如果该值为1 ，则`currency_symbol` 在负格式化货币值的前面；如果该值为0 ，则`currency_symbol` 在负格式化货币值的后面|
|`char n_sep_by_space`|如果该值为1 ，则用空格把`currency_symbol` 和负格式化货币值隔开；如果该值为0 ，则不用空格分隔`currency_symbol` 和负格式化货币值|
|`char p_sign_posn`|其值表示`positive_sign` 字符串的位置：0 表示用圆括号把数值和货币符号括起来, 1 表示字符串在数值和货币符号前面, 2 表示字符串在数值和货币符号后面, 3 表示直接把字符串放在货币前面, 4 表示字符串紧跟在货币符号后面|
|`char n_sign_posn`|其值表示`negative_sign` 字符串的位置，含义与`p_sign_posn` 相同|
|`char int_p_cs_precedes`|如果该值为1 ，则`int_currency_symbol` 在非负格式化货币值的前面；如果该值为0 ，则`int_currency_symbol` 在非负格式化货币值的后面|
|`char int_p_sep_by_space`|如果该值为1 ，则用空格把`int_currency_symbol` 和非负格式化货币值隔开；如果该值为0 ，则不用空格分隔`int_currency_symbol` 和非负格式化货币值|
|`char int_n_cs_precedes`|如果该值为1 ，则`int_currency_symbol` 在负格式化货币值的前面；如果该值为0 ，则`int_currency_symbol` 在负格式化货币值的后面|
|`char int_n_sep_by_space`|如果该值为1 ，则用空格把`int_currency_symbol` 和负格式化货币值隔开；如果该值为0 ，则不用空格分隔`int_currency_symbol` 和负格式化货币值|
|`char int_p_sign_posn`|其值表示`positive_sign` 相对于非负国际格式化货币值的位置|
|`char int_n_sign_posn`|其值表示`negative_sign` 相对于负国际格式化货币值的位置|

#### B.5.10　数学库：math.h

C99为`math.h` 头文件定义了两种类型：`float_t` 和`double_t` 。这两种类型分别与`float` 和`double` 类型至少等宽，是计算`float` 和`double` 时效率最高的类型。

该头文件还定义了一些宏，如表B.5.15所列。该表中除了`HUGE_VAL` 外，都是C99 新增的。在参考资料VIII：“C99数值计算增强”中会进一步详细介绍。

**表B.5.15　math.h 宏**

|宏|描述|
|---|---|
|`HUGE_VAL`|正双精度常量，不一定能用浮点数表示；在过去，函数的计算结果超过了可表示的最大值时，就用它作为函数的返回值|
|`HUGE_VALF`|与`HUGE_VAL` 类似，适用于`float` 类型|
|`HUGE_VALL`|与`HUGE_VAL` 类似，适用于`long double` 类型|
|`INFINITY`|如果允许的话，展开为一个表示无符号或正无穷大的常量`float` 表达式；否则，展开为一个在编译时溢出的正浮点常量|
|`NAN`|当且仅当实现支持`float` 类型的NaN 时才被定义（NaN 是Not-a-Number 的缩写，表示“非数”，用于处理计算中的错误情况，如除以0.0 或求负数的平方根）|
|`FP_INFINITE`|分类数，表示一个无穷大的浮点值|
|`FP_NAN`|分类数，表示一个不是数的浮点值|
|`FP_NORMAL`|分类数，表示一个正常的浮点值|
|`FP_SUBNORMAL`|分类数，表示一个低于正常浮点值的值（精度被降低）|
|`FP_ZERO`|分类数，表示0 的浮点值|
|`FP_FAST_FMA`|（可选）如果已定义，对于`double` 类型的运算对象，该宏表明`fma()` 函数与先乘法运算后加法运算的速度相当或更快|
|`FP_FAST_FMAF`|（可选）如果已定义，对于`double` 类型的运算对象，该宏表明`fmaf()` 函数与先乘法运算后加法运算的速度相当或更快|
|`FP_FAST_FMAL`|（可选）如果已定义，对于`long double` 类型的运算对象，该宏表明`fmal()` 函数与先乘法运算后加法运算的速度相当或更快|
|`FP_ILOGB0`|整型常量表达式，表示`ilogn(0)` 的返回值|
|`FP_ILOGBNAN`|整型常量表达式，表示`ilogn(NaN)` 的返回值|
|`MATH_ERRNO`|展开为整型常量1|
|`MATH_ERREXCEPT`|展开为整型常量2|
|`math_errhandling`|值为`MATH_ERRNO` 、`MATH_ERREXCEPT` 或这两个值的按位或|

数学函数通常使用`double` 类型的值。C99新增了这些函数的`float` 和`long double` 版本，其函数名为分别在原函数名后添加`f` 后缀和`l` 后缀。例如，C语言现在提供这些函数原型：

以下代码展示了 `sin` 函数针对 `double`、`float` 和 `long double` 三种不同浮点类型的函数原型。

text

```
double sin(double);
float sinf(float);
long double sinl(long double);
```

篇幅有限，表B.5.16仅列出了数学库中这些函数的`double` 版本。该表引用了`FLT_RADIX` ，该常量定义在`float.h` 中，代表内部浮点表示法中幂的底数。最常用的值是2 。

**表B.5.16　ANSI C标准数学函数**

|原型|描述|
|---|---|
|`int classify(real-floating x);`|C99宏，返回适合x 的浮点分类值|
|`int isfinite(real-floating x);`|C99宏，当且仅当x 为有穷时返回一个非0 值|
|`int isinf(real-floating x);`|C99宏，当且仅当x 为无穷时返回一个非0 值|
|`int isnan(real-floating x);`|C99宏，当且仅当x 为NaN 时返回一个非0 值|
|`int isnormal(real-floating x);`|C99宏，当且仅当x 为正常数时返回一个非0 值|
|`int signbit(real-floating x);`|C99宏，当且仅当x 的符号为负时返回一个非0 值|
|`double acos(double x);`|返回余弦为x 的角度（0 ～π弧度）|
|`double asin(double x);`|返回正弦为x 的角度（- π/2 ～π/2 弧度）|
|`double atan(double x);`|返回正切为x 的角度（- π/2 ～π/2 弧度）|
|`double atan2(double y, double x);`|返回正切为y/x 的角度（- π～π弧度）|
|`double cos(double x);`|返回x （弧度）的余弦值|
|`double sin(double x);`|返回x （弧度）的正弦值|
|`double tan(double x);`|返回x （弧度）的正切值|
|`double cosh(double x);`|返回x 的双曲余弦值|
|`double sinh(double x);`|返回x 的双曲正弦值|
|`double tanh(double x);`|返回x 的双曲切值|
|`double exp(double x);`|返回e 的x 次幂（ex ）|
|`double exp2(double x);`|返回2 的x 次幂（2x ）|
|`double expm1(double x);`|返回ex - 1 （C99）|
|`double frexp(double v, int *pt_e);`|把v 的值分成两部分，一个是返回的规范化小数；一个是2 的幂，储存在`pt_e` 指向的位置上|
|`int ilogb(double x);`|以`signed int` 类型返回x 的指数（C99）|
|`double ldexp(double x, int p);`|返回x 乘以2 的p 次幂（即x * 2p ）|
|`double log(double x);`|返回x 的自然对数|
|`double log10(double x);`|返回以10 为底x 的对数|
|`double log1p(double x);`|返回log(1 + x) （C99）|
|`double log2(double x);`|返回以2 为底x 的对数（C99）|
|`double logb(double x);`|返回`FLT_RADIX` （系统内部浮点表示法中幂的底数）为底x 的有符号对数（C99）|
|`double modf(double x, double *p);`|把x 分成整数部分和小数部分，两部分的符号相同，返回小数部分，并把整数部分储存在p 所指向的位置上|
|`double scalbn(double x, int n);`|返回x × `FLT_RADIX`n （C99）|
|`double scalbln(double x, long n);`|返回x × `FLT_RADIX`n （C99）|
|`double cbrt(double x);`|返回x 的立方根（C99）|
|`double hypot(double x, double y);`|返回x 平方与y 平方之和的平方根（C99）|
|`double pow(double x, double y);`|返回x 的y 次幂|
|`double sqrt(double x);`|返回x 的平方根|
|`double erf(double x);`|返回x 的误差函数（C99）|
|`double lgamma(double x);`|返回x 的伽马函数绝对值的自然对数（C99）|
|`double tgamma(double x);`|返回x 的伽马函数（C99）|
|`double ceil(double x);`|返回不小于x 的最小整数值|
|`double fabs(double x);`|返回x 的绝对值|
|`double floor(double x);`|返回不大于x 的最大值|
|`double nearbyint(double x);`|以浮点格式把x 四舍五入为最接近的整数；使用浮点环境指定的舍入规则（C99）|
|`double rint(double x);`|与`nearbyint()` 类似，但是该函数会抛出“不精确”异常|
|`long int lrint(double x);`|以`long int` 格式把x 舍入为最接近的整数；使用浮点环境指定的舍入规则（C99）|
|`long long int llrint(double x);`|以`long long int` 格式把x 舍入为最接近的整数；使用浮点环境指定的舍入规则（C99）|
|`double round(double x);`|以浮点格式把x 舍入为最接近的整数，总是四舍五入|
|`long int lround(double x);`|与`round()` 类似，但是该函数返回值的类型是`long int`|
|`long long int llround(double x);`|与`round()` 类似，但是该函数返回值的类型是`long long int`|
|`double trunc(double x);`|以浮点格式把x 舍入为最接近的整数，其结果的绝对值不大于x 的绝对值（C99）|
|`int fmod(double x, double y);`|返回x/y 的小数部分，如果y 不是0 ，则其计算结果的符号与x 相同，而且该结果的绝对值要小于y 的绝对值|
|`double remainder(double x, double y);`|返回x 除以y 的余数，IEC 60559 定义为x - n*y ，n 取与x/y 最接近的整数；如果(n - x/y) 的绝对值是1/2 ，n 取偶数|
|`double remquo(double x, double y, int *quo);`|返回与`remainder()` 相同的值；把x/y 的整数大小求模2k 的值储存在`quo` 所指向的位置中，符号与x/y 的符号相同，其中k 为整数，至少是3 ，具体值因实现而异（C99）|
|`double copysign(double x, double y);`|返回x 的大小和y 的符号（C99）|
|`double nan(const char *tagp);`|返回以`double` 类型表示的quiet NaN [2] ；`nan("n-char-seq")` 与`strtod("NAN(n-char-seq)", (char **)NULL)` 等价；`nan("")` 与`strtod("NAN()", (char**)NULL)` 等价。如果不支持quiet NaN ，则返回0|
|`double nextafter(double x, double y);`|返回x 在y 方向上可表示的最接近的`double` 类型值；如果x 等于y ，则返回x （C99）|
|`double nexttoward(double x, long double y);`|与`nextafter()` 类似，但该函数的第2个参数是`long double` 类型；如果x 等于y ，则返回转换为`double` 类型的y （C99）|
|`double fdim(double x, double y);`|如果x 大于y ，则返回x - y 的值；如果x 小于或等于y ，则返回0 （C99）|
|`double fmax(double x, double y);`|返回参数的最大值，如果一个参数是NaN 、另一个参数是数值，则返回数值（C99）|
|`double fmin(double x, double y);`|返回参数的最小值，如果一个参数是NaN 、另一个参数是数值，则返回数值（C99）|
|`double fma(double x, double y, double z);`|返回三元运算(x*y)+z 的大小，只在最后舍入一次（C99）|
|`int isgreater(real-floating x, real-floating y);`|C99宏，返回`(x)>(y)` 的值，如果有参数是NaN ，不会抛出“无效”浮点异常|
|`int isgreaterequal(real-floating x,real-floating y);`|C99宏，返回`(x)>=(y)` 的值，如果有参数是NaN ，不会抛出无效浮点异常|
|`int isless(real-floating x, real-floating y);`|C99宏，返回`(x)<(y)` 的值，如果有参数是NaN ，不会抛出无效浮点异常|
|`int islessequal(real-floating x, real-floating y);`|C99宏，返回`(x)<=(y)` 的值，如果有参数是NaN ，不会抛出无效浮点异常|
|`int islessgreater(real-floating x, real-floating y);`|C99宏，返回`(x)<(y)|
|`int isunordered(real-floating x, real-floating y);`|如果参数不按顺序排列（至少有一个参数是NaN ），函数返回1 ；否则，返回0|

#### B.5.11　非本地跳转：setjmp.h

`setjmp.h` 头文件可以让你不遵循通常的函数调用、函数返回顺序。`setjmp()` 函数把当前执行环境的信息（例如，指向当前指令的指针）储存在`jmp_buf` 类型（定义在`setjmp.h` 头文件中的数组类型）的变量中，然后`longjmp()` 函数把执行转至这个环境中。这些函数主要是用来处理错误条件，并不是通常程序流控制的一部分。表B.5.17列出了这些函数。

**表B.5.17　setjmp.h 中的函数**

|原型|描述|
|---|---|
|`int setjmp(jmp_buf env);`|把调用环境储存在数组`env` 中，如果是直接调用，则返回0 ；如果是通过`longjmp()` 调用，则返回非0|
|`void longjmp(jmp_buf env, int val);`|恢复最近的`setjmp()` 调用（设置`env` 数组）储存的环境；完成后，程序继续像调用`setjmp()` 那样执行该函数，返回`val` （但是该函数不允许返回0 ，会将其转换成1 ）|

#### B.5.12　信号处理：signal.h

信号 （signal ）是在程序执行期间可以报告的一种情况，可以用正整数表示。`raise()` 函数发送（或抛出）一个信号，`signal()` 函数设置特定信号的响应。

标准定义了一个整数类型：`sig_atomic_t` ，专门用于在处理信号时指定原子对象。也就是说，更新原子类型是不可分割的过程。

标准提供的宏列于表B.5.18中，它们表示可能的信号，可用作`raise()` 和`signal()` 的参数。当然，实现也可以添加更多的值。

**表B.5.18　信号宏**

|宏|描述|
|---|---|
|`SIGABRT`|异常终止，例如`abort()` 调用发出的信号|
|`SIGFPE`|错误的算术运算|
|`SIGILL`|检测到无效功能（例如，非法指令）|
|`SIGINT`|接收到交互注意信号（如，DOS 中断）|
|`SIGSEGV`|非法访问内存|
|`SIGTERM`|向程序发送终止请求|

`signal()` 函数的第2个参数接受一个指向void 函数的指针，该函数有一个`int` 类型的参数，也返回相同类型的指针。为响应一个信号而被调用的函数称为信号处理器 （signal handler ）。标准定义了3 个满足下面原型的宏：

这是一个函数指针的声明，它指向一个接受 `int` 参数且无返回值的函数。

text

```
void (*funct)(int);
```

表B.5.19列出了这3种宏。

**表B.5.19　void (*f)(int) 宏**

|宏|描述|
|---|---|
|`SIG_DFL`|当该宏与一个信号值一起作为`signal()` 的参数时，表示默认处理信号|
|`SIG_ERR`|如果`signal()` 不能返回它的第2 个参数，就用该宏作为它的返回值|
|`SIG_IGN`|当该宏与一个信号值一起作为`signal()` 的参数时，表示忽略信号|

如果产生了信号`sig` ，而且`func` 指向一个函数（参见表B.5.20中`signal()` 原型），那么大多数情况下先调用`signal(sig, SIG_DFL)` 把信号重置为默认设置，然后调用`(*func)(sig)` 。可以执行返回语句或调用`abort()` 、`exit()` 或`longjmp()` 来结束`func` 指向的信号处理函数。

**表B.5.20　信号函数**

|宏|描述|
|---|---|
|`void (*signal(int sig, void (*func) (int)))(int);`|如果产生信号`sig` ，则执行`func` 指向的函数；如果能执行则返回`func` ，否则返回`SIG_ERR`|
|`int raise(int sig);`|向执行程序发送信号`sig` ；如果成功发送则返回0 ，否则返回非0|

#### B.5.13　对齐：stdalign.h （C11）

`stdalign.h` 头文件定义了4个宏，用于确定和指定数据对象的对齐属性。表B.5.21中列出了这些宏，其中前两个创建的别名与C++的用法兼容。

**表B.5.21　void (*f)(int) 宏**

|宏|描述|
|---|---|
|`alignas`|展开为关键字`_Alignas`|
|`alignof`|展开为关键字`_Alignof`|
|`__alignas_is_defined`|展开为整型常量1 ，适用于`#if`|
|`__alignof_is_defined`|展开为整型常量1 ，适用于`#if`|

#### B.5.14　可变参数：stdarg.h

`stdarg.h` 头文件提供一种方法定义参数数量可变的函数。这种函数的原型有一个形参列表，列表中至少有一个形参后面跟有省略号：

`void f1(int n, ...);` /* 有效 _/  
`int f2(int n, float x, int k, ...);` /_ 有效 _/  
`double f3(...);` /_ 无效 */

在下面的表中， `parmN` 是省略号前面的最后一个形参的标识符。在上面的例子中，第1种情况的 `parmN` 为`n` ，第2 种情况的 `parmN` 为`k` 。

头文件中声明了`va_lis` 类型表示储存形参列表中省略号部分的形参数据对象。表B.5.22中列出了3个带可变参数列表的函数中用到的宏。在使用这些宏之前要声明一个`va_list` 类型的对象。

**表B.5.22　可变参数列表宏**

|宏|描述|
|---|---|
|`void va_start(va_list ap, parmN );`|该宏在`va_arg()` 和`va_end()` 使用`ap` 之前初始化`ap` ， `parN` 是形参列表中最后一个形参名的标识符|
|`void va_copy(va_list dest, va_list src);`|该宏把`dest` 初始化为`src` 当前状态的备份（C99）|
|`type va_arg(va_list ap, type );`|该宏展开为一个表达式，其值和类型都与`ap` 表示的形参列表的下一项相同，`type` 是该项的类型。每次调用该宏都前进到`ap` 中的下一项|
|`void va_end(va_list ap);`|该宏关闭以上过程，可能导致`ap` 在再次调用`va_start()` 之前不可用|
|`void va_copy(va_list dest, va_list src);`|该宏把`dest` 初始化为`srt` 当前状态的备份（C99）|

#### B.5.15　原子支持：stdatomic.h （C11）

`stdatomic.h` 和`threads.h` 头文件支持并发编程。并发编程的内容超过了本书讨论的范围，简单地说，`stdatomic.h` 头文件提供了创建原子操作的宏。编程社区使用原子这个术语是为了强调不可分割的特性。一个操作（如，把一个结构赋给另一个结构）从编程层面上看是原子操作，但是从机器语言层面上看是由多个步骤组成。如果程序被分成多个线程，那么其中的线程可能读或修改另一个线程正在使用的数据。例如，可以想象给一个结构的多个成员赋值，不同线程给不同成员赋值。有了`stdatomic.h` 头文件，就能创建这些可以看作是不可分割的操作，这样就能保证线程之间互不干扰。

#### B.5.16　布尔支持：stdbool.h （C99）

`stdbool.h` 头文件定义了4个宏，如表B.5.23所列。

**表B.5.23　stdbool.h 宏**

|宏|描述|
|---|---|
|`bool`|展开为`_Bool`|
|`false`|展开为整型常量0|
|`true`|展开为整型常量1|
|`__bool_true_false_ are_defined`|展开为整型常量1|

#### B.5.17　通用定义：stddef.h

该头文件定义了一些类型和宏，如表B.5.24和表B.5.25所列。

**表B.5.24　stddef.h 类型**

|类型|描述|
|---|---|
|`ptrdiff_t`|有符号整数类型，表示两个指针之差|
|`size_t`|无符号整数类型，表示`sizeof` 运算符的结果|
|`wchar_t`|整数类型，表示支持的本地化所指定的最大扩展字符集|

**表B.5.25　stddef.h 宏**

|类型|描述|
|---|---|
|`NULL`|实现定义的常量，表示空指针|
|`offsetof(type,member-designator )`|展开为`size_t` 类型的值，表示`type` 类型结构的指定成员在该结构中的偏移量，以字节为单位。如果成员是一个位字段，该宏的行为是未定义的|

**示例**

以下代码使用 `offsetof` 宏来计算 `car` 结构体中 `hp` 成员相对于结构体起始位置的字节偏移量。

text

```
#include <stddef.h>

struct car
{
    char brand[30];
    char model[30];
    double hp;
    double price;
};
int main(void)
{
    size_t into = offsetof(struct car, hp); /* hp成员的偏移量 */
    ...
```

#### B.5.18　整数类型：stdint.h

`stdint.h` 头文件中使用`typedef` 工具创建整数类型名，指定整数的属性。`stdint.h` 头文件包含在`inttypes.h` 中，后者提供输入/ 输出函数调用的宏。参考资料VI的“扩展的整数类型”中介绍了这些类型的用法。

**1．精确宽度类型**  
`stdint.h` 头文件中用一组`typedef` 标识精确宽度的类型。表B.5.26列出了它们的类型名和大小。然而，注意，并不是所有的系统都支持其中的所有类型。

**表B.5.26　确切宽度类型**

|typedef 名|属性|
|---|---|
|`int8_t`|8 位，有符号|
|`int16_t`|16 位，有符号|
|`int32_t`|32 位，有符号|
|`int64_t`|64 位，有符号|
|`uint8_t`|8 位，无符号|
|`uint16_t`|16 位，无符号|
|`uint32_t`|32 位，无符号|
|`uint64_t`|64 位，无符号|

**2．最小宽度类型**  
最小宽度类型保证其类型的大小至少是某数量位。表B.5.27列出了最小宽度类型，系统中一定会有这些类型。

**表B.5.27　最小宽度类型**

|typedef 名|属性|
|---|---|
|`int_least8_t`|至少8 位，有符号|
|`int_least16_t`|至少16 位，有符号|
|`int_least32_t`|至少32 位，有符号|
|`int_least64_t`|至少64 位，有符号|
|`uint_least8_t`|至少8 位，无符号|
|`uint_least16_t`|至少16 位，无符号|
|`uint_least32_t`|至少32 位，无符号|
|`uint_least64_t`|至少64 位，无符号|

**3．最快最小宽度类型**  
在特定系统中，使用某些整数类型比其他整数类型更快。为此，`stdint.h` 也定义了最快最小宽度类型，如表B.5.28所列，系统中一定会有这些类型。

**表B.5.28　最快最小宽度类型**

|typedef 名|属性|
|---|---|
|`int_fast8_t`|至少8 位有符号|
|`int_fast16_t`|至少16 位有符号|
|`int_fast32_t`|至少32 位有符号|
|`int_fast64_t`|至少64 位有符号|
|`uint_fast8_t`|至少8 位无符号|
|`uint_fast16_t`|至少16 位无符号|
|`uint_fast32_t`|至少32 位无符号|
|`uint_fast64_t`|至少64 位无符号|

**4．最大宽度类型**  
`stdint.h` 头文件还定义了最大宽度类型。这种类型的变量可以储存系统中的任意整数值，还要考虑符号。表B.5.29列出了这些类型。

**表B.5.29　最大宽度类型**

|typedef 名|描述|
|---|---|
|`intmax_t`|最大宽度的有符号类型|
|`uintmax_t`|最大宽度的无符号类型|

**5．可储存指针值的整数类型**  
`stdint.h` 头文件中还包括表B.5.30中所列的两种整数类型，它们可以精确地储存指针值。也就是说，如果把一个`void *` 类型的值赋给这种类型的变量，然后再把该类型的值赋回给指针，不会丢失任何信息。系统可能不支持这类型。

**表B.5.30　可储存指针值的整数类型**

|typedef 名|描述|
|---|---|
|`intptr_t`|可储存指针值的有符号类型|
|`uintptr_t`|可储存指针值的无符号类型|

**6．已定义的常量**  
`stdint.h` 头文件定义了一些常量，用于表示该头文件中所定义类型的限定值。常量都根据类型命名，即用`_MIN` 或`_MAX` 代替类型名中的`_t` ，然后把所有字母大写即得到表示该类型最小值或最大值的常量名。例如，`int32_t` 类型的最小值是`INT32_MIN` 、`unit_fast16_t` 的最大值是`UNIT_FAST16_MAX` 。表B.5.31总结了这些常量以及与之相关的`intptr_t` 、`unitptr_t` 、`intmax_t` 和`uintmax_t` 类型，其中的N 表示位数。这些常量的值应等于或大于（除非指明了一定要等于）所列的值。

**表B.5.31　整型常量**

|常量标识符|最小值|
|---|---|
|`INTN _MIN`|等于-(2N-1 -1)|
|`INTN _MAX`|等于2N-1 -1|
|`UINTN _MAX`|等于2N-1 -1|
|`INT_LEASTN _MIN`|-(2N-1 -1)|
|`INT_LEASTN _MAX`|2N-1 -1|
|`UINT_LEASTN _MAX`|2N -1|
|`INT_FASTN _MIN`|-(2N-1 -1)|
|`INT_FASTN _MAX`|2N-1 -1|
|`UINT_FASN _MAX`|2N -1|
|`INTPTR_MIN`|-(215 -1)|
|`INTPTR_MAX`|215 -1|
|`UINTPTR_MAX`|216 -1|
|`INTMAX_MIN`|-(215 -1)|
|`INTMAX_MAX`|263 -1|
|`UINTMAX_MAX`|264 -1|

该头文件还定义了一些别处定义的类型使用的常量，如表B.5.32所示。
**表B.5.32　其他整型常量**

|常量标识符|含义|
|---|---|
|`PTRDIFF_MIN`|`ptrdiff_t` 类型的最小值|
|`PTRDIFF_MAX`|`ptrdiff_t` 类型的最大值|
|`SIG_ATOMIC_MIN`|`sig_atomic_t` 类型的最小值|
|`SIG_ATOMIC_MAX`|`sig_atomic_t` 类型的最大值|
|`WCHAR_MIN`|`wchar_t` 类型的最小值|
|`WCHAR_MAX`|`wchar_t` 类型的最大值|
|`WINT_MIN`|`wint_t` 类型的最小值|
|`WINT_MAX`|`wint_t` 类型的最大值|
|`SIZE_MAX`|`size_t` 类型的最大值|

**7．扩展的整型常量**

`stdin.h` 头文件定义了一些宏用于指定各种扩展整数类型。从本质上看，这种宏是底层类型（即在特定实现中表示扩展类型的基本类型）的强制转换。  
把类型名后面的`_t` 替换成`_C` ，然后大写所有的字母就构成了一个宏名。例如，使用表达式`UNIT_LEAST64_C(1000)` 后，1000 就是`unit_least64_t` 类型的常量。

#### B.5.19　标准I/O库：stdio.h

ANSI C标准库包含一些与流相关联的标准I/O函数和`stdio.h` 头文件。表B.5.33列出了ANSI 中这些函数的原型和简介（第13章详细介绍过其中的一些函数）。`stdio.h` 头文件定义了`FILE` 类型、`EOF` 和`NULL` 的值、标准I/O流（`stdin` 、`stdout` 和`stderr` ）以及标准I/O库函数要用到的一些常量。

**表B.5.33　C标准I/O函数**

|原型|描述|
|---|---|
|`void clearerr(FILE *);`|清除文件结尾和错误指示符|
|`int fclose(FILE *);`|关闭指定的文件|
|`int feof(FILE *);`|测试文件结尾|
|`int ferror(FILE *);`|测试错误指示符|
|`int fflush(FILE *);`|刷新指定的文件|
|`int fgetc(FILE *);`|获得指定输入流的下一个字符|
|`int fgetpos(FILE *restrict, fpos_t * restrict);`|储存文件位置指示符的当前值|
|`char * fgets(char *restrict, int, FILE * restrict);`|从指定流中获取下一行（或指定的字符数）|
|`FILE * fopen(const char*restrict, const char*restrict);`|打开指定的文件|
|`int fprintf(FILE *restrict, const char *restrict, ...);`|把格式化输出写入指定流|
|`int fputc(int, FILE *);`|把指定字符写入指定流|
|`int fputs(const char* restrict, FILE * restrict);`|把第1 个参数指向的字符串写入指定流|
|`size_t fread(void *restrict, size_t, size_t, FILE * restrict);`|读取指定流中的二进制数据|
|`FILE * freopen(const char * restrict, const char * restrict, FILE *restrict);`|打开指定文件，并将其与指定流相关联|
|`int fscanf(FILE *restrict, const char * restrict, ...);`|读取指定流中的格式化输入|
|`int fsetpos(FILE *,const fpos_t *);`|设置文件位置指针指向指定的值|
|`int fseek(FILE *, long,int);`|设置文件位置指针指向指定的值|
|`long ftell(FILE *);`|获取当前文件位置|
|`size_t fwrite(const void* restrict, size_t,size_t, FILE * restrict);`|把二进制数据写入指定流|
|`int getc(FILE *);`|读取指定输入的下一个字符|
|`int getchar(void);`|读取标准输入的下一个字符|
|`char * gets(char *);`|获取标准输入的下一行（C11库已删除）|
|`void perror(const char*);`|把系统错误信息写入标准错误中|
|`int printf(const char *restrict, ...);`|把格式化输出写入标准输出中|
|`int putc(int, FILE *);`|把指定字符写入指定输出中|
|`int putchar(int);`|把指定字符写入指定输出中|
|`int puts(const char *);`|把字符串写入标准输出中|
|`int remove(const char *);`|移除已命名文件|
|`int rename(const char *,const char *);`|重命名文件|
|`void rewind(FILE *);`|设置文件位置指针指向文件开始处|
|`int scanf(const char *restrict, ...);`|读取标准输入中的格式化输入|
|`void setbuf(FILE *restrict, char * restrict);`|设置缓冲区大小和位置|
|`int setvbuf(FILE *restrict, char *restrict,int, size_t);`|设置缓冲区大小、位置和模式|
|`int snprintf(char *restrict, size_t n, const char * restrict, ...);`|把格式化输出中的前n 个字符写入指定字符串中|
|`int sprintf(char *restrict, const char *restrict, ...);`|把格式化输出写入指定字符串中|
|`int sscanf(const char*restrict, const char *restrict, ...);`|把格式化输入写入指定字符串中|
|`FILE * tmpfile(void);`|创建一个临时文件|
|`char * tmpnam(char *);`|为临时文件生成一个唯一的文件名|
|`int ungetc(int, FILE *);`|把指定字符放回输入流中|
|`int vfprintf(FILE *restrict, const char *restrict, va_list);`|与`fprintf()` 类似，但该函数用一个`va_list` 类型形参列表（由`va_start` 初始化）代替变量参数列表|
|`int vprintf(const char *restrict, va_list);`|与`printf()` 类似，但该函数用一个`va_list` 类型形参列表（由`va_start` 初始化）代替变量参数列表|
|`int vsnprintf(char *restrict, size_t n, const char * restrict,va_list);`|与`snprintf()` 类似，但该函数用一个`va_list` 类型形参列表（由`va_start` 初始化）代替变量参数列表|
|`int vsprintf(char *restrict, const char *restrict, va_list);`|与`sprintf()` 类似，但该函数用一个`va_list` 类型形参列表（由`va_start` 初始化）代替变量参数列表|
|`int vscanf(const char *restrict, va_list);`|与`scanf()` 类似，但该函数用一个`va_list` 类型形参列表（由`va_start` 初始化）代替变量参数列表|
|`int vsscanf(const char* restrict, const char * restrict,va_list);`|与`sscanf()` 类似，但该函数用一个`va_list` 类型形参列表（由`va_start` 初始化）代替变量参数列表|

#### B.5.20　通用工具：stdlib.h

ANSI C标准库在`stdlib.h` 头文件中定义了一些实用函数。该头文件定义了一些类型，如表B.5.34所示。

**表B.5.34　stdlib.h 中声明的类型**

|类型|描述|
|---|---|
|`size_t`|`sizeof` 运算符返回的整数类型|
|`wchar_t`|用于表示宽字符的整数类型|
|`div_t`|`div()` 返回的结构类型，该类型中的`quot` 和`rem` 成员都是`int` 类型|
|`ldiv_t`|`ldiv()` 返回的结构类型，该类型中的`quot` 和`rem` 成员都是`long` 类型|
|`lldiv_t`|`lldiv()` 返回的结构类型，该类型中的`quot` 和`rem` 成员都是`long long` 类型（C99）|

`stdlib.h` 头文件定义的常量列于表B.5.35中。

**表B.5.35　stdlib.h 中定义的常量**

|常量|描述|
|---|---|
|`NULL`|空指针（相当于0 ）|
|`EXIT_FAILURE`|可用作`exit()` 的参数，表示执行程序失败|
|`EXIT_SUCCESS`|可用作`exit()` 的参数，表示成功执行程序|
|`RAND_MAX`|`rand()` 返回的最大值（一个整数）|
|`MB_CUR_MAX`|当前本地化的扩展字符集中多字节字符的最大字节数|

表B.5.36列出了`stdlib.h` 中的函数原型。

**表B.5.36　通用工具**

|原型|描述|
|---|---|
|`double atof(const char * nptr);`|返回把字符串`nptr` 开始部分的数字（和符号）字符转换为`double` 类型的值，跳过开始的空白，遇到第1个非数字字符时结束转换；如果未发现数字则返回0|
|`int atoi(const char* nptr);`|返回把字符串`nptr` 开始部分的数字（和符号）字符转换为`int` 类型的值，跳过开始的空白，遇到第1个非数字字符时结束转换；如果未发现数字则返回0|
|`long atol(const char* nptr);`|返回把字符串`nptr` 开始部分的数字（和符号）字符转换为`long` 类型的值，跳过开始的空白，遇到第1个非数字字符时结束转换；如果未发现数字则返回0|
|`double strtod(const char* restrict npt,char ** restrict ept);`|返回把字符串`npt` 开始部分的数字（和符号）字符转换为`double` 类型的值，跳过开始的空白，遇到第1个非数字字符时结束转换；如果未发现数字则返回0 ；如果转换成功，则把数字后第1 个字符的地址赋给`ept` 指向的位置；如果转换失败，则把`npt` 赋给`ept` 指向的位置|
|`float strtof(const char * restrict npt, char ** restrict ept);`|与`strtod()` 类似，但是该函数把`npt` 指向的字符串转换为`float` 类型的值（C99）|
|`long double strtold(const char * restrict npt, char ** restrict ept);`|与`strtod()` 类似，但是该函数把`npt` 指向的字符串转换成`long double` 类型的值（C99）|
|`long strtol(const char * restrict npt, char ** restrict ept, int base);`|返回把字符串`npt` 开始部分的数字（和符号）字符转换成`long` 类型的值，跳过开始的空白，遇到第1个非数字字符时结束转换；如果未发现数字则返回0 ；如果转换成功，则把数字后第1 个字符的地址赋给`ept` 指向的位置；如果转换失败，则把`npt` 赋给`ept` 指向的位置；假定字符串中的数字以`base` 指定的数为基数|
|`long long strtoll(const char *restrict npt, char** restrict ept,int base);`|与`strtol()` 类似，但是该函数把`npt` 指向的字符串转换为`long long` 类型的值（C99）|
|`unsigned long strtoul(const char * restrict npt, char** restrict ept, int base);`|返回把字符串`npt` 开始部分的数字（和符号）字符转换为`unsigned long` 类型的值，跳过开始的空白，遇到第1个非数字字符时结束转换；如果未发现数字则返回0 ；如果转换成功，则把数字后第1 个字符的地址赋给`ept` 指向的位置；如果转换失败，则把`npt` 赋给`ept` 指向的位置；假定字符串中的数字以`base` 指定的数为基数|
|`unsigned long long strtoull(const char* restrict npt,char ** restrict ept, int base);`|与`strtoul()` 类似，但是该函数把`npt` 指向的字符串转换为`unsigned long long` 类型的值（C99）|
|`int rand(void);`|返回0 ～`RAND_MAX` 范围内的一个伪随机整数|
|`void srand(unsigned int seed);`|把随机数生成器种子设置为`seed` ，如果在调用`rand()` 之前调用`srand()` ，则种子为1|
|`void *aligned_alloc(size_t algn, size_t size);`|为对齐对象`algn` 分配`size` 字节的空间，应支持`algn` 对齐值，`size` 应该是`algn` 的倍数（C11 ）|
|`void *calloc(size_t nmem, size_t size);`|为内含`nmem` 个成员的数组分配空间，每个元素占`size` 字节大；空间中的所有位都初始化为0 ；如果操作成功，该函数返回数组的地址，否则返回`NULL`|
|`void free(void*ptr);`|释放`ptr` 指向的空间，`ptr` 应该是之前调用`calloc()` 、`malloc()` 或`realloc()` 返回的值，或者`ptr` 也可以是空指针，出现这种情况时什么也不做。如果`ptr` 是其他值，其行为是未定义的|
|`void *malloc(size_t size);`|分配`size` 字节的未初始化内存块；如果成功分配，该函数返回数组的地址，否则返回`NULL`|
|`void *realloc(void*ptr, size_t size);`|把`ptr` 指向的内存块大小改为`size` 字节，`size` 字节内的内存块内容不变。该函数返回块的位置，它可能被移动。如果不能重新分配空间，函数返回`NULL` ，原始块不变；如果`ptr` 为`NULL` ，其行为与调用带`size` 参数的`malloc()` 相同；如果`size` 是0 ，且`ptr` 不是`NULL` ，其行为与调用带`ptr` 参数的`free()` 相同|
|`void abort(void);`|除非捕获信号`SIGABRT` ，且相应的信号处理器没有返回，否则该函数将导致程序异常结束。是否关闭I/O 流和临时文件，因实现而异。该函数执行`raise(SIGABRT)`|
|`int atexit(void(*func) (void));`|注册`func` 指向的函数，使其在程序正常结束时被调用。实现应支持注册至少32 个函数，并根据它们注册顺序的逆序调用。如果注册成功，函数返回0 ；否则返回非0|
|`int at_quick_exit(void (*func)(void));`|注册`func` 指向的函数，如果调用`quick_exit()` 则调用被注册的函数。实现应支持注册至少32 个函数，并根据它们注册顺序的逆序调用。如果注册成功，函数返回0 ；否则返回非0 （C11）|
|`void exit(int status);`|该函数将正常结束程序。首先调用由`atexit()` 注册的函数，然后刷新所有打开的输出流、关闭所有的I/O 流、关闭`tmpfile()` 创建的所有文件，并把控制权返回主机环境中；如果`status` 是0 或`EXIT_SUCCESS` ，则返回一个实现定义的值，表明未成功结束程序|
|`void _Exit(int status);`|与`exit()` 类似，但是该函数不调用`atexit()` 注册的函数和`signal()` 注册的信号处理器，其处理打开流的方式依实现而异|
|`char *getenv(const char * name);`|返回一个指向字符串的指针，该字符串表示`name` 指向的环境变量的值。如果无法匹配指定的`name` ，则返回`NULL`|
|`_Noreturn void quick_exit(int status);`|该函数将正常结束程序。不调用`atexit()` 注册的函数和`signal()` 注册的信号处理器。根据`at_quick_exit()` 注册函数的顺序，逆序调用这些函数。如果程序多次调用`quick_exit()` 或者同时调用`quick_exit()` 和 `exit()` ，其行为是未定义的。通过调用`_Exit(status)` 将控制权返回主机环境（C11）|
|`int system(const char *str);`|把`str` 指向的字符串传递给命令处理器（如DOS或UNIX）执行的主机环境。如果`str` 是`NULL` 指针，且命令处理器可用，则该函数返回非0 ，否则返回；如果`str` 不是`NULL` ，返回值依实现而异|
|`void *bsearch(const void *key, const void *base, size_t nmem, size_t size, int (*comp)(const void *, const void *));`|查找`base` 指向的一个数组（有`nmem` 个元素，每个元素的大小为`size` ）中是否有元素匹配`key` 指向的对象。通过`comp` 指向的函数比较各项，如果`key` 指向的对象小于数组元素，那么比较函数将返回小于0 的值；如果两者相等，则返回0 ；如果`key` 指向的对象大于数组元素，则返回大于0 的值。该函数返回指向匹配元素的指针或`NULL` （如果无匹配元素）。如果有多个元素匹配，未定义返回哪一个元素|
|`void qsort(void*base, size_t nmem, size_t size, int(*comp) (const void *, const void *));`|根据`comp` 指向的函数所提供的顺排列`base` 指向的数组。该数组有`nmem` 个元素，每个元素的大小是`size` 。如果第1 个参数指向的对象小于数组元素，那么比较函数将返回小于0 的值；如果两者相等，则返回0 ；如果第1 个参数指向的对象大于数组元素，则返回大于0 的值|
|`int abs(int n);`|返回`n` 的绝对值。如果`n` 是负数但没有与之对应的正数，那么返回值是未定义的（当`n` 是以二进制补码表示的`INT_MIN` 时，会出现这种情况）|
|`div_t div(int numer, int denom);`|计算`numer` 除以`denom` 的商和余，把商和余数分别储存在`div_t` 结构的`quot` 成员和`rem` 成员中。对于无法整除的除法，商要趋零截断（即直接截去小数部分）|
|`long labs(long n);`|返回`n` 的绝对值，如果`n` 是负数但没有与之对应的正数，那么返回值是未定义的（当`n` 是以二进制补码表示的`LONG_MIN` 时，会出现这种情况）|
|`ldiv_t ldiv(long numer, long denom);`|计算`numer` 除以`denom` 的商和余，把商和余数分别储存在`ldiv_t` 结构的`quot` 成员和`rem` 成员中。对于无法整除的除法，商要趋零截断（即直接截去小数部分）|
|`long long llabs(long long n);`|返回`n` 的绝对值，如果`n` 是负数但没有与之对应的正数，那么返回值是未定义的（当`n` 是以二进制补码表示的`LONG_LONG_MIN` 时，会出现这种情况）|
|`lldiv_t lldiv(long long numer, long long denom);`|计算`numer` 除以`denom` 的商和余，把商和余数分别储存在`lldiv_t` 结构的`quot` 成员和`rem` 成员中。对于无法整除的除法，商要趋零截断（即直接截去小数部分）（C99）|
|`int mblen(const char *s, size_t n);`|返回组成`s` 指向的多字节字符的字节数（最大为`n` ）。如果`s` 指向空字符，该函数则返回0 ；如果`s` 未指向多字节字符，则返回-1 ；如果`s` 是`NULL` ，且多字节根据状态进行编码，该函数则返回非0 ，否则返回0|
|`int mbtowc(wchar_t*pw, const char *s, size_t n);`|如果`s` 不是`NULL` ，该函数确定了组成`s` 指向的多字节字符的字节数（最大为`n` ），并确定字符的`wchar_t` 类型编码。如果`pw` 不是`NULL` ，则把类型编码赋给`pw` 指向的位置。返回值与`mblen(s, n)` 相同|
|`int wctomb(char *s,wchar_t wc);`|把`wc` 中的字符代码转换成相应的多字节字符表示，并将其储存在`s` 指向的数组中，除非`s` 是`NULL` 。如果`s` 不是`NULL` ，且如果`wc` 无法转换成相应的有效多字节字符，该函数返回-1 ；如果`wc` 有效，该函数返回组成多字节的字节数；如果`s` 是`NULL` ，且如果多字节字符根据状态进行编码，该函数则返回非0 ，否则返回0|
|`size_t mbstowcs(wchar_t *restrict pwcs,const char *restrict s ,size_t n);`|把`s` 指向的多字节字符数组转换成储存在`pwcs` 开始位置的宽字符编码数组中，转换`pwcs` 数组中的`n` 个字符或转换到`s` 数组的空字节停止。如果遇到无效的多字节字符，该函数返回`(size_t)(-1)` ，否则返回已填充的数组元素个数（如果有空字符，不包含空字符）|
|`size_t wcstombs(char * restrict s, const wchar_t* restrict pwcs,size_t n);`|把储存在`pwcs` 指向数组中的宽字符编码序列转换成一个多字节字符序列，并把它拷贝到`s` 指向的位置上，储存`n` 个字节或遇到空字符时停止转换。如果遇到无效的宽字符编码，该函数返回`(size_t)(-1)` ，否则返回已填充数组的字节数（如果有空字符，不包含空字符）|
#### B.5.21　_Noreturn ：stdnoreturn.h

`stdnoreturn.h` 定义了`noreturn` 宏，该宏展开为`_Noreturn` 。

#### B.5.22　处理字符串：string.h

`string.h` 库定义了`size_t` 类型和空指针要使用的`NULL` 宏。`string.h` 头文件提供了一些分析和操控字符串的函数，其中一些函数以更通用的方式处理内存。表B.5.37列出了这些函数。

**表B.5.37　字符串函数**

|原型|描述|
|---|---|
|`void *memchr(const void *s, int c, size_t n);`|在`s` 指向对象的前`n` 个字符中查找是否有`c` 。如果找到，则返回首次出现`c` 处的指针，如果未找到则返回`NULL`|
|`int memcmp(const void*s1, const void *s2,size_t n);`|比较`s1` 指向对象中的前`n` 个字符和`s2` 指向对象的前`n` 个字符，每个值都解释为`unsigned char` 类型。如果`n` 个字符都匹配，则两个对象完全相同；否则，比较两个对象中首次不匹配的字符对。如果两个对象相同，函数返回0 ；如果在数值上第1 个对象小于第2 个对象，函数返回小于0 的值；如果在数值上第1 个对象大于第2 个对象，函数返回大于0 的值|
|`void *memcpy(void *restrict s1, const void * restrict s2,size_t n);`|把`s2` 所指向位置上的`n` 字节拷贝到`s1` 指向的位置上，函数返回`s1` 的值。如果两个位置出现重叠，其行为是未定义的|
|`void *memmove(void*s1, const void *s2, size_t n);`|把`s2` 所指向位置上的`n` 字节拷贝到`s1` 指向的位置上，其行为与拷贝类似，返回`s1` 的值。但是，如果出现局部重叠情况，该函数会先把重叠的内容拷贝至临时位置|
|`void *memset(void *s,int v, size_t n);`|把`v` 的值（转换为`unsigned char` ）拷贝至`s` 指向的前`n` 字节中，函数返回`s`|
|`char *strcat(char *restrict s1, const char * restrict s2);`|把`s2` 指向的字符串拷贝到`s1` 指向字符串后面，`s2` 字符串的第1 个字符覆盖`s1` 字符串的空字符。该函数返回`s1`|
|`char *strncat(char *restrict s1, const char * restrict s2,size_t n);`|把`s2` 指向字符串的`n` 个字符拷贝到`s1` 指向的字符串后面（或拷贝到`s2` 的空字符为止）。`s2` 字符串的第1 个字符覆盖`s1` 字符串的空字符。函数返回`s1`|
|`char *strcpy(char *restrict s1, const char * restrict s2);`|把`s2` 指向的字符串拷贝到`s1` 指向的位置。函数返回`s1`|
|`char *strncpy(char *restrict s1, const char * restrict s2,size_t n);`|把`s2` 指向字符串的`n` 个字符拷贝到`s1` 指向的位置（或拷贝到`s2` 的空字符为止）。如果在拷贝`n` 个字符之前遇到空字符，则在拷贝字符后面添加若干个空字符，使其长度为`n` ；如果拷贝n 个字符没有遇到空字符，则不添加空字符。函数返回`s1`|
|`int strcmp(const char*s1, const char *s2);`|比较`s1` 和`s2` 指向的两个字符串。如果完全匹配，则两字符串相同，否则比较首次出现不匹配的字符对。通过字符编码值比较字符。如果两个字符串相同，函数返回0 ；如果第1 个字符串小于第2 个字符串，函数返回小于0 的值；如果第1 个字符串大于第2 个字符串，函数返回大于0 的值|
|`int strcoll(const char *s1, const char *s2);`|与`strcmp()` 类似，但是该函数使用当前本地化的`LC_COLLATE` 类别（由`setlocale()` 函数设置）所指定的排序方式进行比较|
|`int strncmp(const char *s1, const char *s2, size_t n);`|比较`s1` 和`s2` 指向数组中的前`n` 个字符，或比较到第1 个空字符位置。如果所有的字符对都匹配，则两个数组相同否则比较两个数组中首次不匹配的字符对。通过字符编码值比较字符。如果两个数组相同，函数返回0 ；如果第1 个数组小于第2 个数组，函数返回小于0 的值；如果第1 个数组大于第2 个数组，函数返回大于0 的值|
|`size_t strxfrm(char* restrict s1, const char * restrict s2,size_t n);`|转换`s2` 中的字符串，并把转换后的前`n` 个字符（包括空字符）拷贝到`s1` 指向的数组中。用`strcmp()` 比较转换后的两个字符串的结果和用`strcoll()` 比较两个未转换字符串的结果相同。函数返回转换后的字符串长度（不包括末尾的空字符）|
|`char *strchr(const char *s, int c);`|查找`s` 指向的字符串中首次出现`c` 的位置。空字符是字符串的一部分。函数返回一个指针，指向首次出现`c` 的位置。如果没有找到指定的`c` 则返回`NULL`|
|`size_t strcspn(const char *s1, const char*s2);`|返回`s1` 中未出现`s2` 中任何字符的最大起始段长度|
|`char *strpbrk(const char *s1, const char*s2);`|返回一个指针，指向`s1` 中与`s2` 任意字符匹配的第1 个字符的位置。如果未发现任何匹配的字符，函数返回`NULL`|
|`char *strrchr(const char *s, int c);`|在`s` 指向的字符串中查找末次出现`c` 的位置（即从`s2` 右侧开始查找字符`c` 首次出现的位置）。空字符是字符串的一部分。如果找到，函数返回指向该位置的指针；如果未找到，则返回`NULL`|
|`size_t strspn(const char *s1, const char*s2);`|返回`s1` 中包含`s2` 所有字符的最大起始段长度|
|`char *strstr(const char *s1, const char*s2);`|返回一个指针，指向`s1` 中首次出现`s2` 中字符序列（不包括结束的空字符）的位置。如果未找到，函数返回`NULL`|
|`char *strtok(char *restrict s1, const char * restrict s2);`|该函数把`s1` 字符串分解为单独的记号。`s2` 字符串包含了作为记号分隔符的字符。按顺序调用该函数。第1 次调用时，`s1` 应指向待分解的字符串。函数定位到非分隔符后的第1 个记号分隔符，并用空字符替换它。函数返回一个指针，指向储存第1 个记号的字符串。如果未找到记号，函数返回`NULL` 。在此次调用`strtok()` 查找字符串中的更多记号。每次调用都返回指向下一个记号的指针，如果未找到则返回`NULL` （请参看表后面的示例）|
|`char * strerror(int errnum);`|返回一个指针，指向与储存在`errnum` 中的错误号相对应的错误信息字符串（依实现而异）|
|`size_t strlen(const char* s);`|返回字符串`s` 中的字符数（末尾的空字除外）|

`strtok()` 函数的用法有点不常`见，下面演示一个简短的示例。

以下程序演示了 `strtok()` 函数的用法，它使用一组分隔符将字符串 `data` 分解成多个独立的记号（token），并逐个打印出来。

text

```
#include <stdio.h>
#include <string.h>
int main(void)
{
char data[] = " C is\t too#much\nfun!";
const char tokseps[] = " \t\n#";/* 分隔符 */
char * pt;
puts(data);
pt = strtok(data,tokseps); /* 首次调用 */
while (pt) /* 如果pt是NULL，则退出 */
{
puts (pt); /* 显示记号 */
pt = strtok(NULL, tokseps); /* 下一个记号 */
}
return 0;
}
```

下面是该示例的输出，首先打印原始字符串，然后逐行打印分解出的每个记号。

text

```
 C is	 too#much
fun!
C
is
too
much
fun!
```

#### B.5.23　通用类型数学：tgmath.h （C99）

`math.h` 和`complex.h` 库中有许多类型不同但功能相似的函数。例如,下面6个都是计算正弦的函数：

`double sin(double);`  
`float sinf(float);`  
`long double sinl(long double);`  
`double complex csin(double complex);`  
`float csinf(float complex);`  
`long double csinl(long double complex);`

`tgmath.h` 头文件定义了展开为通用调用的宏，即根据指定的参数类型调用合适的函数。下面的代码演示了使用`sin()` 宏时，展开为正弦函数的不同形式：

这段代码展示了 `tgmath.h` 中的 `sin` 通用宏如何根据传入参数的类型，自动解析为对应的具体函数，如 `sin()`、`sinf()` 或 `csinl()`。

text

```
#include <tgmath.h>
...
double dx, dy;
float fx, fy;
long double complex clx, cly;
dy = sin(dx); // 展开为dy = sin(dx) （函数）
fy = sin(fx); // 展开为fy = sinf(fx)
cly = sin(clx); // 展开为cly = csinl(clyx)
```

`tgmath.h` 头文件为3 类函数定义了通用宏。第1类由`math.h` 和`complex.h` 中定义的6 个函数的变式组成，用`l` 和`f` 后缀和`c` 前缀，如前面的`sin()` 函数所示。在这种情况下，通用宏名与该函数`double` 类型版本的函数名相同。

第2类由`math.h` 头文件中定义的3 个函数变式组成，使用`l` 和`f` 后缀，没有对应的复数函数（如，`erf()` ）。在这种情况下，宏名与没有后缀的函数名相同，如`erf()` 。使用带复数参数的这种宏的效果是未定义的。

第3类由`complex.h` 头文件中定义的3 个函数变式组成，使用`l` 和`f` 后缀，没有对应的实数函数，如`cimag()` 。使用带实数参数的这种宏的效果是未定义的。

表B.5.38列出了一些通用宏函数。

**表B.5.38　通用数学函数**

`acos` `asin` `atan` `acosh` `asinh` `atanh`  
`cos` `sin` `tan` `cosh` `sinh` `tanh`  
`exp` `log` `pow` `sqrt` `fabs` `atan2`  
`cbrt` `ceil` `copysign` `erf` `erfc` `exp2`  
`expm1` `fdim` `floor` `fma` `fmax` `fmin`  
`fmod` `frexp` `hypot` `ilogb` `ldexp` `lgamma`  
`llrint` `llround` `log10` `log1p` `log2` `logb`  
`lrint` `lround` `nearbyint` `nextafter` `nexttoward` `remainder`  
`remquo` `rint` `round` `scalbn` `scalbln` `tgamma`  
`trunc` `carg` `cimag` `conj` `cproj` `creal`

在C11以前，编写实现必须依赖扩展标准才能实现通用宏。但是使用C11新增的`_Generic` 表达式可以直接实现。

#### B.5.24　线程：threads.h （C11）

`threads.h` 和`stdatomic.h` 头文件支持并发编程。这方面的内容超出了本书讨论的范围，简而言之，该头文件支持程序执行多线程，原则上可以把多个线程分配给多个处理器处理。

#### B.5.25　日期和时间：time.h

`time.h` 定义了3个宏。第1个宏是表示空指针的`NULL` ，许多其他头文件中也定义了这个宏。第2个宏是`CLOCKS_PER_SEC` ，该宏除以`clock()` 的返回值得以秒为单位的时间值。第3个宏（C11）是`TIME_UTC` ，这是一个正整型常量，用于指定协调世界时 [3] （即UTC）。该宏是`timespec_get()` 函数的一个可选参数。

UTC是目前主要世界时间标准，作为互联网和万维网的普通标准，广泛应用于航空、天气预报、同步计算机时钟等各领域。  
`time.h` 头文件中定义的类型列在表B.5.39中。

**表B.5.39　time.h 中定义的类型**

|类型|描述|
|---|---|
|`size_t`|`sizeof` 运算符返回的整数类型|
|`clock_t`|适用于表示时间的算术类型|
|`time_t`|适用于表示时间的算术类型|
|`struct timespec`|以秒和纳秒为单位储存指定时间间隔的结构（C11 ）|
|`struct tm`|储存日历时间的各部分|

`timespec` 结构中至少有两个成员，如表B.5.40所列。

**表B.5.40　timespec 结构中的成员**

|成员|描述|
|---|---|
|`time_t tv_sec`|秒（>=0 ）|
|`long tv_nsec`|纳秒（[0,999999999] ）|

日历类型的各组成部分被称为分解时间 （broken-down time ）。表B.5.41列出了`struct tm` 结构中所需的成员。

**表B.5.41　struct tm 结构中的成员**

|成员|描述|
|---|---|
|`int tm_sec`|分后的秒（0-61 ）|
|`int tm_min`|小时后的分（0-59 ）|
|`int tm_hour`|小时（0-23 ）|
|`int tm_mday`|一个月的天数（0-31 ）|
|`int tm_mon`|一月后的月数（0-11 ）|
|`int tm_year`|1900 年后的年数|
|`int tm_wday`|星期日开始的天数（0-6 ）|
|`int tm_yday`|从1 月1 日开始的天数(0-365)|
|`int tm_isdst`|夏令时标志（大于0 说明夏令时有效，等于0 说明无效，小于0 说明信息不可用）|

日历时间 （calendar time ）表示当前的日期和时间，例如，可以是从1900年的第1秒开始经过的秒数。本地时间 （local time ）指的是本地时区的日历时间。表B.5.42列出了一些时间函数。

**表B.5.42　时间函数**

|原型|描述|
|---|---|
|`clock_t clock(void);`|该函数返回实现从开始执行程序到调用该函数时，处理器经过的最接近的时间。该函数的返回值除以`CLOCK_PER_SEC` 得到以秒为单位的时间。如果时间不可用或无法表示，函数返回`(clock_t)(-1)`|
|`double difftime(time_t t1, time_t t0);`|返回两个日历时间`(t1 - t0)` 的差值。该函数返回计算结果，单位是秒|
|`time_t mktime(struct tm *tmptr);`|把`tmptr` 指向的结构中的分解时间转换为日历时间。其编码与`time()` 函数相同，但是结构改变了，以便对结构中超出范围的值进行调整（例如，2 分100 秒会调整为4 分40 秒），而且把`tm_wday` 和`tm_yday` 设置为其他成员指定的值。如果无法表示日历时间，该函数返回`(time_t)(-1)` ；否则以`time_t` 格式返回日历时间|
|`time_t time(time_t *ptm);`|返回当前日历时间，并将其储存在`ptm` 指向的位置，假设`ptm` 不是空指针。如果日期时间不可用，该函数返回`(time_t)(-1)`|
|`int timespec_get(struct timespec * ts, int base);`|根据指定的时基，把`ts` 指向的结构设置为当前日历时间。如果成功，返回`base` （非0 值），否则返回0 （C11）|
|`char *asctime(const struct tm *tmpt);`|把`tmpt` 指向的结构中的分解时间转换成 `Thu Feb 26 13:14:33 1998\n\0` 格式的字符串，并返回指向该字符串的指针|
|`char *ctime(const time_t*ptm);`|把`ptm` 指向的结构中的分解时间转换成 `Wed Aug 11 10:48:24 1999\n\0` 格式的字符串，并返回指向该字符串的指针|
|`struct tm *gmtime(const time_t *ptm);`|把`ptm` 指向的日历时间转换成协调世界时（UTC ）表示的分解时间，返回一个指向结构的指针，该结构中储时时间信息。如果UTC 不可用，则返回`NULL`|
|`struct tm*localtime(const time_t *ptm);`|把`ptm` 指向的日历时间转换成本地时间表示的分解时间，储存`tm` 结构并返回指向该结构的指针|
|`size_t strftime(char *restrict s, size_t max, const char * restrict fmt, const struct tm *restrict tmpt);`|把字符串`fmt` 拷贝到字符串`s` 中，用`tmp` 指向的分解时间结构中的合适数据替换`fmt` 中的转换说明（见表B.5.43 ）。最多在`s` 中放入`max` 个字符。该函数返回放入`s` 中的字符数（不包括空格）；如果字符串中的字符数大于`max` ，函数返回0 ，且`s` 中的内容不确定|

表B.5.43列出了`strftime()` 函数中使用的转换说明。其中许多替换的值（如，月份名）都取决于当前的本地化设置。

**表B.5.43　strftime() 函数中使用的转换说明**

| 转换说明 | 被替换为                                                                 |
| ---- | -------------------------------------------------------------------- |
| `%a` | 本地化的星期名称缩写                                                           |
| `%A` | 本地化的星期名称全名                                                           |
| `%b` | 本地化的月份名称缩写                                                           |
| `%B` | 本地化的月份名称全名                                                           |
| `%c` | 本地化指定的日期和时间                                                          |
| `%C` | 年份的后两位数字（年份除以100 ，取小数部分的数）（00-99 ）                                   |
| `%d` | 十进制数表示的月份中的某天（01-31 ）                                                |
| `%D` | 月/ 日/ 年，等价于“%m/%d/%y ”                                               |
| `%e` | 十进制数表示的月份中的某天，在仅一位的数字前有一个空格（ 1-31 ）                                  |
| `%F` | 年- 月- 日，等价于“%Y-%m-%d ”                                               |
| `%g` | 基于周的年份的最后两位数字（00-99 ）                                                |
| `%G` | 十进制数表示的基于周的年份                                                        |
| `%h` | 等价于“%b ”                                                             |
| `%H` | 十进制数（00-23 ）表示的小时（24 小时制）                                            |
| `%I` | 十进制数（01-12 ）表示的小时（12 小时制）                                            |
| `%j` | 十进制数表示的一年中的某天（001-366 ）                                              |
| `%m` | 十进制数表示的月份（01-12 ）                                                    |
| `%n` | 换行符                                                                  |
| `%M` | 十进制数表示的分钟（00-59 ）                                                    |
| `%p` | 等价于本地12 小时制中的am/pm                                                   |
| `%r` | 本地的12 小时制                                                            |
| `%R` | 小时: 分钟，等价于“%H:%M ”                                                   |
| `%S` | 十进制数表示的秒（00-61 ）                                                     |
| `%t` | 水平制表符                                                                |
| `%T` | 小时: 分钟：秒，等价于“%H:%M:%S ”                                              |
| `%u` | ISO 8601 的星期数（1 ～7 ），星期一为1                                           |
| `%U` | 一年中的周数（00 ～53 ），把星期天作为一周的第1 天                                        |
| `%V` | ISO 8601 的一年周数（00 ～53 ），把星期天作为一周的第1 天                                |
| `%w` | 十进制表示的星期数（0 ～6 ），从星期天开始                                              |
| `%W` | 一年的周数（00 ～53 ），把星期一作为一周的第1 天                                         |
| `%x` | 本地化日期表示                                                              |
| `%X` | 本地化时间表示                                                              |
| `%y` | 不带世纪的十进制年份（00 ～99 ）                                                  |
| `%Y` | 带世纪的十进制年份                                                            |
| `%z` | 按照ISO 8601 格式的相对UTC 偏移（“-800 ”表示格林威治时间后的8 小时，即是向西8 小时），如果无可用信息则无替换字符 |
| `%Z` | 时区名，如果无可用信息则无替换字符                                                    |
| `%%` | % （即百分号                                                              |
#### B.5.26　统一码工具：uchar.h （C11）

C99的`wchar.h` 头文件提供两种途径支持大型字符集。C11专门针对统一码（Unicode）新增了适用于UTF-16 和UTF-32 编码的类型（见表B.5.44）。

**表B.5.44　uchar.h 中声明的类型**

|类型|描述|
|---|---|
|`char16_t`|使用16 位字符的无符号整数类型（与`stdint.h` 中的`unit_least16_t` 相同）|
|`char32_t`|使用32 位字符的无符号整数类型（与`stdint.h` 中的`unit_least32_t` 相同）|
|`size_t`|`sizeof` 运算符(`stddef.h`) 返回的整数类型|
|`mbstate_t`|非数组类型，可储存多字节字符序列和宽字符相互转换的转换状态信息|

该头文件中还声明了一些多字节字符串与`char16_t` 、`char32_t` 格式相互转换的函数（见表B.5.45）。

**表B.5.45　宽字符与多字节转换函数**

|原型|描述|
|---|---|
|`size_t mbrto16(char16_t* restrict pwc, const char * restrict s, size_t n, mbstate_t* restrict ps);`|与`mbrtowc()` 函数相同（`wchar.h` ），但该函数是把字符转换为`char_16` 类型，而不是`wchar_t` 类型|
|`size_t mbrto32( char32_t * restrict pwc, const char * restrict s, size_t n, mbstate_t * restrict ps);`|与`mbrto16()` 函数相同，但该函数是把字符转换为`char32_t` 类型|
|`size_t c16rtomb(char * restrict s, wchar_t wc, mbstate_t * restrict ps);`|与`wcrtobm()` 函数相同（`wchar.h` ），但该函数转换的是`char16_t` 类型字符，而不是`wchar_t` 类型|
|`size_t c32rtomb(char * restrict s, wchar_t wc, mbstate_t * restrict ps);`|与`wcrtobm()` 函数相同（`wchar.h` ），但该函数转换的是`char32_t` 类型字符，而不是`wchar_t` 类型|

#### B.5.27　扩展的多字节字符和宽字符工具：wchar.h （C99）

每种实现都有一个基本字符集，要求C的`char` 类型足够宽，以便能处理这个字符集。实现还要支持扩展的字符集，这些字符集中的字符可能需要多字节来表示。可以把多字节字符与单字节字符一起储存在普通的`char` 类型数组，用特定的字节值指定多字节字符本身及其大小。如何解释多字节字符取决于移位状态 （shift state ）。在最初的移位状态中，单字节字符保留其通常的解释。特殊的多字节字符可以改变移位状态。除非显式改变特定的移位状态，否则移位状态一直保持有效。

`wchar_t` 类型提供另一种表示扩展字符的方法，该类型足够宽，可以表示扩展字符集中任何成员的编码。用这种宽字符类型来表示字符时，可以把单字符储存在`wchar_t` 类型的变量中，把宽字符的字符串储存在`wchar_t` 类型的数组中。字符的宽字符表示和多字节字符表示不必相同，因为后者可能使用前者并不使用的移位状态。

`wchar.h` 头文件提供了一些工具用于处理扩展字符的两种表示法。该头文件中定义的类型列在表B.5.46中（其中有些类型也定义在其他的头文件中）。

**表B.5.46　wchar.h 中定义的类型**

|类型|描述|
|---|---|
|`wchar_t`|整数类型，可表示本地化支持的最大扩展字符集|
|`wint_t`|整数类型，可储存扩展字符集的任意值和至少一个不是扩展字符集成员的值|
|`size_t`|`sizeof` 运算符返回的整数类型|
|`mbstate_t`|非数组类型，可储存多字节字符序列和宽字符之间转换所需的转换状态信息|
|`struct tm`|结构类型，用于储存日历时间的组成部分|

`wchar.h` 头文件中还定义了一些宏，如表B.5.47所列。

**表B.5.47　wchar.h 中定义的宏**

|宏|描述|
|---|---|
|`NULL`|空指针|
|`WCHAR_MAX`|`wchar_t` 类型可储存的最大值|
|`WCHAR_MIN`|`wchar_t` 类型可储存的最小值|
|`WEOF`|`wint_t` 类型的常量表达式，不与扩展字符集的任何成员对；相当于`EOF` 的宽字符表示，用于指定宽字符输入的文件结尾|

该库提供的输入/输出函数类似于`stdio.h` 中的标准输入/输出函数。在标准I/O函数返回`EOF` 的情况中，对应的宽字符函数返回`WEOF`。表B.5.48中列出了这些函数。

**表B.5.48　宽字符I/O函数**

|函数原型|
|---|
|`int fwprintf(FILE * restrict stream, const wchar_t * restrict format, ...);`|
|`int fwscanf(FILE * restrict stream, const wchar_t * restrict format, ...);`|
|`int swprintf(wchar_t * restrict s, size_t n, const wchar_t * restrict format, ...);`|
|`int swscanf(const wchar_t * restrict s, const wchar_t * restrict format,...);`|
|`int vfwprintf(FILE * restrict stream, const wchar_t * restrict format,va_list arg);`|
|`int vfwscanf(FILE * restrict stream, const wchar_t * restrict format,va_list arg);`|
|`int vswprintf(wchar_t * restrict s, size_t n, const wchar_t * restrict format, va_list arg);`|
|`int vswscanf(const wchar_t * restrict s, const wchar_t * restrict format,va_list arg);`|
|`int vwprintf(const wchar_t * restrict format, va_list arg);`|
|`int vwscanf(const wchar_t * restrict format, va_list arg);`|
|`int wprintf(const wchar_t * restrict format, ...);`|
|`int wscanf(const wchar_t * restrict format, ...);`|
|`wint_t fgetwc(FILE *stream);`|
|`wchar_t *fgetws(wchar_t * restrict s, int n, FILE * restrict stream);`|
|`wint_t fputwc(wchar_t c, FILE *stream);`|
|`int fputws(const wchar_t * restrict s, FILE * restrict stream);`|
|`int fwide(FILE *stream, int mode);`|
|`wint_t getwc(FILE *stream);`|
|`wint_t getwchar(void);`|
|`wint_t putwc(wchar_t c, FILE *stream);`|
|`wint_t putwchar(wchar_t c);`|
|`wint_t ungetwc(wint_t c, FILE *stream);`|

有一个宽字符I/O函数没有对应的标准I/O函数：  
`int fwide(FILE *stream, int mode);` [4]  
如果`mode` 为正，函数先尝试把形参表示的流指定为宽字符定向（wide-charaacter oriented ）；如果`mode` 为负，函数先尝试把流指定为字节定向 （byte oriented ）；如果`mode` 为0 ，函数则不改变流的定向。该函数只有在流最初无定向时才改变其定向。在以上所有的情况中，如果流是宽字符定向，函数返回正值；如果流是字节定向，函数返回负值；如果流没有定向，函数则返回0 。

`wchar.h` 头文件参照`string.h` ，也提供了一些转换和控制字符串的函数。一般而言，用`wcs` 代替`string.h` 中的`str` 标识符，这样`wcstod()` 就是`strtod()` 函数的宽字符版本。表B.5.49列出了这些函数。

**表B.5.49　宽字符字符串工具**

|函数原型|
|---|
|`double wcstod(const wchar_t * restrict nptr, wchar_t ** restrict endptr);`|
|`float wcstof(const wchar_t * restrict nptr, wchar_t ** restrict endptr);`|
|`long double wcstold(const wchar_t * restrict nptr, wchar_t ** restrict endptr);`|
|`long int wcstol(const wchar_t * restrict nptr, wchar_t ** restrict endptr,int base);`|
|`long long int wcstoll(const wchar_t * restrict nptr, wchar_t ** restrict endptr, int base);`|
|`unsigned long int wcstoul(const wchar_t * restrict nptr, wchar_t ** restrict endptr, int base);`|
|`unsigned long long int wcstoull( const wchar_t * restrict nptr, wchar_t **restrict endptr, int base);`|
|`wchar_t *wcscpy(wchar_t * restrict s1, const wchar_t * restrict s2);`|
|`wchar_t *wcsncpy(wchar_t * restrict s1, const wchar_t * restrict s2, size_t n);`|
|`wchar_t *wcscat(wchar_t * restrict s1, const wchar_t * restrict s2);`|
|`wchar_t *wcsncat(wchar_t * restrict s1, const wchar_t * restrict s2, size_t n);`|
|`int wcscmp(const wchar_t *s1, const wchar_t *s2);`|
|`int wcscoll(const wchar_t *s1, const wchar_t *s2);`|
|`int wcsncmp(const wchar_t *s1, const wchar_t *s2, size_t n);`|
|`size_t wcsxfrm(wchar_t * restrict s1, const wchar_t * restrict s2, size_t n);`|
|`wchar_t *wcschr(const wchar_t *s, wchar_t c);`|
|`size_t wcscspn(const wchar_t *s1, const wchar_t *s2);`|
|`size_t wcslen(const wchar_t *s);`|
|`wchar_t *wcspbrk(const wchar_t *s1, const wchar_t *s2);`|
|`wchar_t *wcsrchr(const wchar_t *s, wchar_t c);`|
|`size_t wcsspn(const wchar_t *s1, const wchar_t *s2);`|
|`wchar_t *wcsstr(const wchar_t *s1, const wchar_t *s2);`|
|`wchar_t *wcstok(wchar_t * restrict s1, const wchar_t * restrict s2, wchar_t** restrict ptr);`|
|`wchar_t *wmemchr(const wchar_t *s, wchar_t c, size_t n);`|
|`int wmemcmp(wchar_t * restrict s1, const wchar_t * restrict s2, size_t n);`|
|`wchar_t *wmemcpy(wchar_t * restrict s1,const wchar_t * restrict s2, size_t n);`|
|`wchar_t *wmemmove(wchar_t *s1, const wchar_t *s2, size_t n);`|
|`wchar_t *wmemset(wchar_t *s, wchar_t c, size_t n);`|

该头文件还参照`time.h` 头文件中的`strtime()` 函数，声明了一个时间函数：  
`size_t wcsftime(wchar_t * restrict s, size_t maxsize,const wchar_t * restrict format, const struct tm * restrict timeptr);`

除此之外，该头文件还声明了一些用于宽字符字符串和多字节字符相互转换的函数，如表B.5.50所列。

**表B.5.50　宽字节和多字节字符转换函数**

|函数原型|描述|
|---|---|
|`wint_t btowc(int c);`|如果在初始移位状态中`c` （`unsigned char` ）是有效的单字节字符，那么该函数返回宽字节表示；否则，返回`WEOF`|
|`int wctob(wint_t c);`|如果`c` 是一个扩展字符集的成员，它在初始移位状态中的多字节字符表示的是单字节，该函数就返回一个转换为`int` 类型的`unsigned char` 的单字节表示；否则，函数返回`EOF`|
|`int mbsinit(const mbstate_t *ps);`|如果`ps` 是空指针或指向一个指定为初始转换状态的数据对象，函数就返回非零值；否则，函数返回0|
|`size_t mbrlen(const char * restrict s, size_t n, mbstate_t * restrict ps);`|`mbrlen()` 函数相当于调用`mbrtowc(NULL, s, n, ps != NULL ? ps : &internal)` ，其中`internal` 是`mbrlen()` 函数的`mbstate_t` 对象，除非`ps` 指定的表达式只计算一次|
|`size_t mbrtowc(wchar_t * restrict pwc, const char * restrict s, size_t n, mbstate_t * restrict ps);`|如果`s` 是空指针，调用该函数相当于把`pwc` 设置为空指针、把`n` 设置为1 。如果`s` 不是空指针，该函数最多检查`n` 字节以确定下一个完整的多字节字符所需的字节数（包括所有的移位序列）。如果该函数确定了下一个多字节字符的结束处且合法，它就确定了对应宽字符的值。然后，如果`pwc` 不为空，则把值储存在`pwc` 指向的对象中。如果对应的宽字符是空的宽字符，描述的最终状态就是初始转换状态。如果检测到空的宽字符，函数返回0 ；如果检测到另一个有效宽字符，函数返回完整字符所需的字节数。如果`n` 字节不足以表示一个有效的宽字符，但是能表示其中的一部分，函数返回-2 。如果出现编码错误，函数返回-1 ，并把`EILSEQ` 储存在`errno` 中，且不储存任何值|
|`size_t wcrtomb(char * restrict s, wchar_t wc, mbstate_t * restrict ps);`|如果`s` 是空指针，那么调用该函数相当于把`wc` 设置为空的宽字符，并为第1 个参数使用内部缓冲区。如果`s` 不是空指针，`wcrtomb()` 函数则确定表示`wc` 指定宽字符对应的多字节字符表示所需的字节数（包括所有移位序列），并把多字节字符表示储存在一个数组中（`s` 指向该数组的第1 个元素），最多储存`MB_CUR_MAX` 字节。如果`wc` 是空的宽字符，就在初始移位状态所需的移位序列后储存一个空字节。描述的结果状态就是初始转换状态。如果`wc` 是有效的宽字符，该函数返回储存多字节字符所需的字节数（包括指定移位状态的字节）。如果`wc` 无效，函数则把`EILSEQ` 储存在`errno` 中，并返回-1|
|`size_t mbsrtowcs(wchar_t * restrict dst, const char ** restrict src, size_t len, mbstate_t * restrict ps);`|`mbstrtows()` 函数把`src` 间接指向的数组中的多字节字符序列转换成对应的宽字符序列，从`ps` 指向的对象所描述的转换状态开始，一直转换到结尾的空字符（包括该字符并储存）或转换了`len` 个宽字符。如果`dst` 不是空指针，则待转换的字符将储存在`dst` 指向的数组中。出现这两种情况时停止转换：如果字节序列无法构成一个有效的多字节字符，或者（如果`dst` 不是空指针）`len` 个宽字符已储存在`dst` 指向的数组中。每转换一次都相当于调用一次`mbrtowc()` 函数。如果`dst` 不是空指针，就把空指针（如果因到达结尾的空字符而停止转换）或最后一个待转换多字节字符的地址赋给`src` 指向的指针对象。如果由于到达结尾的空字符而停止转换，且`dst` 不是空指针，那么描述的结果状态就是初始转状态。如果执行成功，函数返回成功转换的多字节字符数（不包括空字符）；否则函数返回-1|
|`size_t wcsrtombs(char * restrict dst,const wchar_t ** restrict src,size_t len,mbstate_t * restrict ps);`|`wcsrtombs()` 函数把`src` 间接指向的数组中的宽字符序列转换成对应的多字节字符序列（从`ps` 指向的对象描述的转换状态开始）。如果`dst` 不是空指针，待转换的字符将被储存在`dst` 指向的数组中。一直转换到结尾的空字符（包括该字符并储存）或换了`len` 个多字节字符。出现这两种情况时停止转换：如果宽字符没有对应的有效多字节字符，或者（如果`dst` 不是空指针）下一个多字节字超过了储存在`dst` 指向的数组中的总字节数`len` 的限制。每转换一次都相当于调用一次`wcrtomb()` 函数。如果`dst` 不是空指针，就把空指针（如果因到达结尾的空字符而停止转换）或最后一个待转换多字节字符的地址赋给`src` 指向的指针对象。如果由于到达结尾的空字符而停止转换，描述的结果状态就是初始转状态。如果执行成功，函数返回成功转换的多字节字符数（不包括空字符）；否则函数返回-1|

#### B.5.28　宽字符分类和映射工具：wctype.h （C99）

`wctype.h` 库提供了一些与`ctype.h` 中的字符函数类似的宽字符函数，以及其他函数。`wctype.h` 还定义了表B.5.51中列出的3种类型和宏。

**表B.5.51　wctpe.h 中定义的类型和宏**

|类型/宏|描述|
|---|---|
|`wint_t`|整数类型，用于储存扩展字符集中的任意值，还可以储存至少一个不是扩展字符成员的值|
|`wctrans_t`|标量类型，可以表示本地化指定的字符映射|
|`wctype_t`|标量类型，可以表示本地化指定的字符分类|
|`WEOF`|`wint_t` 类型的常量表达式，不对应扩展字符集中的任何成员，相当于宽字符中的`EOF` ，用于表示宽字符输入的文件结尾|

在该库中，如果宽字符参数满足字符分类函数的条件时，函数返回真（非0 ）。一般而言，因为单字节字符对应宽字符，所以如果`ctype.h` 中对应的函数返回真，宽字符函数也返回真。表B.5.52列出了这些函数。

**表B.5.52　宽字节分类函数**

|函数原型|描述|
|---|---|
|`int iswalnum(wint_t wc);`|如果`wc` 表示一个字母数字字符（字母或数字），函数返回真|
|`int iswalpha(wint_t wc);`|如果`wc` 表示一个字母字符，函数返回真|
|`int iswblank(wint_t wc);`|如果`wc` 表示一个空格，函数返回真|
|`int iswcntrl(wint_t wc);`|如果`wc` 表示一个控制字符，函数返回真|
|`int iswdigit(wint_t wc);`|如果`wc` 表示一个数字，函数返回真|
|`int iswgraph(wint_t wc);`|如果`iswprint(wc)` 为真，且`iswspace(wc)` 为假，函数返回真|
|`int iswlower(wint_t wc);`|如果`wc` 表示一个小写字符，函数返回真|
|`int iswprint(wint_t wc);`|如果`wc` 表示一个可打印字符，函数返回真|
|`int iswpunct(wint_t wc);`|如果`wc` 表示一个标点字符，函数返回真|
|`int iswspace(wint_t wc);`|如果`wc` 表示一个制表符、空格或换行符，函数返回真|
|`int iswupper(wint_t wc);`|如果`wc` 表示一个大写字符，函数返回真|
|`int iswxdigit(wint_t wc);`|如果`wc` 表示一个十六进制数字，函数返回真|

该库还包含两个可扩展 的分类函数，因为它们使用当前本地化的`LC_CTYPE` 值进行分类。表B.5.53列出了这些函数。

**表B.5.53　可扩展的宽字符分类函数**

|原型|描述|
|---|---|
|`int iswctype(wint_t wc, wctype_t desc);`|如果`wc` 具有`desc` 描述的属性，函数返回真|
|`wctype_t wctype(const char *property);`|`wctype()` 函数构建了一个`wctpe_t` 类型的值，它描述了由字符串参数`property` 指定的宽字符分类。如果根据当前本地化的`LC_CTYPE` 类别，`property` 识别宽字符分类有效，`wctype()` 函数则返回非零值（可作为`iswctype()` 函数的第2 个参数）；否则，函数返回0|

`wctype()` 函数的有效参数名即是宽字符分类函数名去掉`isw` 前缀。例如，`wctype("alpha")` 表示的是`iswalpha()` 函数判断的字符类别。因此，调用`iswctype(wc, wctype("alpha"))` 相当于调用`iswalpha(wc)` ，唯一的区别是前者使用`LC_CTYPE` 类别进行分类。

该库还有4个与转换相关的函数。其中有两个函数分别与`ctype.h` 库中`toupper()` 和`tolower()` 相对应。第3个函数是一个可扩展的版本，通过本地化的`LC_CTYPE` 设置确定字符是大写还是小写。第4个函数为第3个函数提供合适的分类参数。表B.5.54列出了这些函数。

**表B.5.54　宽字符转换函数**

| 原型                                             | 描述                                                                                                                                      |
| ---------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| `wint_t towlower(wint_t wc);`                  | 如果`wc` 是大写字符，返回其小写形式；否则返回`wc`                                                                                                           |
| `wint_t towupper(wint_t wc);`                  | 如果`wc` 是小写字符，返回其大写形式；否则返回`wc`                                                                                                           |
| `wint_t towctrans(wint_t wc, wctrans_t desc);` | 如果`desc` 等于`wctrans("lower")` 的返回值，函数返回`wc` 的小写形式（由`LC_CTYPE` 设置确定）；如果`dest` 等于`wctrans("upper")` 的返回值，函数返回`wc` 的大写形式（由`LC_CTYPE` 设置确定） |
| `wctrans_t wctrans(const char *property);`     | 如果参数是`"lower"` 或`"upper"` ，函数返回一个`wctrans_t` 类型的值，可用作`towctrans()` 的参数并反映`LC_CTYPE` 设置，否则函数返回0                                          |
### B.6　参考资料VI：扩展的整数类型

第3章介绍过，C99的`inttypes.h` 头文件为不同的整数类型提供一套系统的别名。这些名称与标准名称相比，能更清楚地描述类型的性质。例如，`int` 类型可能是16 位、32 位或64 位，但是`int32_t` 类型一定是32 位。

更精确地说，`inttypes.h` 头文件定义的一些宏可用于`scanf()` 和`printf()` 函数中读写这些类型的整数。`inttypes.h` 头文件包含的`stdlib.h` 头文件提供实际的类型定义。格式化宏可以与其他字符串拼接起来形成合适格式化的字符串。

该头文件中的类型都使用`typedef` 定义。例如，32 位系统的`int` 可能使用这样的定义：

这是一个 `typedef` 定义示例，它将 `int32_t` 定义为 `int` 类型的别名。

text

```
typedef int int32_t;
```

用`#define` 指令定义转换说明。例如，使用之前定义的`int32_t` 的系统可以这样定义：

这两个宏定义了用于 `printf` 和 `scanf` 的格式说明符，以匹配 `int32_t` 类型。

text

```
#define PRId32 "d" // 输出说明符
#define SCNd32 "d" // 输入说明符
```

使用这些定义，可以声明扩展的整型变量、输入一个值和显示该值：

这段代码演示了如何使用 `int32_t` 类型和对应的格式化宏 `SCNd32`、`PRId32` 来进行输入和输出操作。

text

```
int32_t cd_sales; // 32位整数类型
scanf("%" SCNd32, &cd_sales);
printf("CD sales = %10" PRId32 " units\n", cd_sales);
```

如果需要，可以把字符串拼接起得到最终的格式字符串。因此，上面的代码可以这样写：

在支持32位 `int` 的系统上，之前的代码实际上等同于这段使用标准 `int` 和 `%d` 格式说明符的代码。

text

```
int cd_sales; // 32位整数类型
scanf("%d", &cd_sales);
printf("CD sales = %10d units\n", cd_sales);
```

如果把原始代码移植到16位`int` 的系统中，该系统可能把`int32_t` 定义为`long` ，把`PRId32` 定义为`"ld"` 。但是，仍可以使用相同的代码，只要知道系统使用的是32位整型即可。

该参考资料的其余部分列出了扩展类型、转换说明以及表示类型限制的宏。

#### B.6.1　精确宽度类型

`typedef` 标识了一组精确宽度的类型，通用形式是`intN _t` （有符号类型）和`uintN _t` （无符号类型），其中 N 表示位数（即类型的宽度）。但是要注意，不是所有的系统都支持所有的这些类型。例如，最小可用内存大小是16 位的系统就不支持`int8_t` 和`uint8_t` 类型。格式宏可以使用`d` 或`i` 表示有符号类型，所以`PRIi8` 和`SCNi8` 都有效。对于无符号类型，可以使用`o` 、`x` 或`u` 以获得`%o` 、`%x` 或`%X` 转换说明来代替`%u` 。例如，可以使用`PRIX32` 以十六进制格式打印`uint32_t` 类型的值。表B.6.1列出了精确宽度类型、格式说明符和最小值、最大值。

**表B.6.1　精确宽度类型**

|类型名|`printf()` 说明符|`scanf()` 说明符|最小值|最大值|
|---|---|---|---|---|
|`int8_t`|`PRId8`|`SCNd8`|`INT8_MIN`|`INT8_MAX`|
|`int16_t`|`PRId16`|`SCNd16`|`INT16_MIN`|`INT16_MAX`|
|`int32_t`|`PRId32`|`SCNd32`|`INT32_MIN`|`INT32_MAX`|
|`int64_t`|`PRId64`|`SCNd64`|`INT64_MIN`|`INT64_MAX`|
|`uint8_t`|`PRIu8`|`SCNu8`|0|`UINT8_MAX`|
|`uint16_t`|`PRIu16`|`SCNu16`|0|`UINT16_MAX`|
|`uint32_t`|`PRIu32`|`SCNu32`|0|`UINT32_MAX`|
|`uint64_t`|`PRIu64`|`SCNu64`|0|`UINT64_MAX`|

#### B.6.2　最小宽度类型

最小宽度类型保证一种类型的大小至少是某位。这些类型一定存在。例如，不支持8 位单元的系统可以把`int_least_8` 定义为16位类型。表B.6.2列出了最小宽度类型、格式说明符和最小值、最大值。

**表B.6.2　最小宽度类型**

|类型名|`printf()` 说明符|`scanf()` 说明符|最小值|最大值|
|---|---|---|---|---|
|`int_least8_t`|`PRILEASTd8`|`SCNLEASTd8`|`INT_LEAST8_MIN`|`INT_LEAST8_MAX`|
|`int_least16_t`|`PRILEASTd16`|`SCNLEASTd16`|`INT_LEAST16_MIN`|`INT_LEAST16_MAX`|
|`int_least32_t`|`PRILEASTd32`|`SCNLEASTd32`|`INT_LEAST32_MIN`|`INT_LEAST32_MAX`|
|`int_least64_t`|`PRILEASTd64`|`SCNLEASTd64`|`INT_LEAST64_MIN`|`INT_LEAST64_MAX`|
|`uint_least8_t`|`PRILEASTu8`|`SCNLEASTu8`|0|`UINT_LEAST8_MAX`|
|`uint_least16_t`|`PRILEASTu16`|`SCNLEASTu16`|0|`UINT_LEAST16_MAX`|
|`uint_least32_t`|`PRILEASTu32`|`SCNLEASTu32`|0|`UINT_LEAST32_MAX`|
|`uint_least64_t`|`PRILEASTu64`|`SCNLEASTu64`|0|`UINT_LEAST64_MAX`|

#### B.6.3　最快最小宽度类型

对于特定的系统，用特定的整型更快。例如，在某些实现中`int_least16_t` 可能是`short` ，但是系统在进行算术运算时用`int` 类型会更快些。因此，`inttypes.h` 还定义了表示为某位数的最快类型。这些类型一定存在。在某些情况下，可能并未明确指定哪种类型最快，此时系统会简单地选择其中的一种。表B.6.3列出了最快最小宽度类型、格式说明符和最小值、最大值。

**表B.6.3　最快最小宽度类型**

|类型名|`printf()` 说明符|`scanf()` 说明符|最小值|最大值|
|---|---|---|---|---|
|`int_fast8_t`|`PRIFASTd8`|`SCNFASTd8`|`INT_FAST8_MIN`|`INT_FAST8_MAX`|
|`int_fast16_t`|`PRIFASTd16`|`SCNFASTd16`|`INT_FAST16_MIN`|`INT_FAST16_MAX`|
|`int_fast32_t`|`PRIFASTd32`|`SCNFASTd32`|`INT_FAST32_MIN`|`INT_FAST32_MAX`|
|`int_fast64_t`|`PRIFASTd64`|`SCNFASTd64`|`INT_FAST64_MIN`|`INT_FAST64_MAX`|
|`uint_fast8_t`|`PRIFASTu8`|`SCNFASTu8`|0|`UINT_FAST8_MAX`|
|`uint_fast16_t`|`PRIFASTu16`|`SCNFASTu16`|0|`UINT_FAST16_MAX`|
|`uint_fast32_t`|`PRIFASTu32`|`SCNFASTu32`|0|`UINT_FAST32_MAX`|
|`uint_fast64_t`|`PRIFASTu64`|`SCNFASTu64`|0|`UINT_FAST64_MAX`|

#### B.6.4　最大宽度类型

有些情况下要使用最大整数类型，表B.6.4列出了这些类型。实际上，由于系统可能会提供比所需类型更大宽度的类型，因此这些类型的宽度可能比`long long` 或`unsigned long long` 更大。

**表B.6.4　最大宽度类型**

|类型名|`printf()` 说明符|`scanf()` 说明符|最小值|最大值|
|---|---|---|---|---|
|`intmax_t`|`PRIdMAX`|`SCNdMAX`|`INTMAX_MIN`|`INTMAX_MAX`|
|`uintmax_t`|`PRIuMAX`|`SCNuMAX`|0|`UINTMAX_MAX`|

#### B.6.5　可储存指针值的整型

`inttypes.h` 头文件（通过包含`stdint.h` 即可包含该头文件）定义了两种整数类型，可精确地储存指针值，见表B.6.5。

**表B.6.5　可储存指针值的整数类型**

|类型名|`printf()` 说明符|`scanf()` 说明符|最小值|最大值|
|---|---|---|---|---|
|`intptr_t`|`PRIdPTR`|`SCNdPTR`|`INTPTR_MIN`|`INTPTR_MAX`|
|`uintptr_t`|`PRIuPTR`|`SCNuPTR`|0|`UINTPTR_MAX`|

#### B.6.6　扩展的整型常量

在整数后面加上`L` 后缀可表示`long` 类型的常量，如`445566L` 。如何表示`int32_t` 类型的常量？要使用`inttypes.h` 头文件中定义的宏。例如，表达式`INT32_C(445566)` 展开为一个`int32_t` 类型的常量。从本质上看，这种宏相当于把当前类型强制转换成底层类型，即特殊实现中表示`int32_t` 类型的基本类型。

宏名是把相应类型名中的`_C` 用`_t` 替换，再把名称中所有的字母大写。例如，要把1000 设置为`unit_least64_t` 类型的常量，可以使用表达式`UNIT_LEAST64_C(1000)` 。

### B.7　参考资料VII：扩展字符支持

C语言最初并不是作为国际编程语言设计的，其字符的选择或多或少是基于标准的美国键盘。但是，随着后来C在世界范围内越来越流行，不得不扩展来支持不同且更大的字符集。这部分参考资料概括介绍了一些相关内容。

#### B.7.1　三字符序列

有些键盘没有C中使用的所有符号，因此C提供了一些由三个字符组成的序列（即三字符序列 ）作为这些符号的替换表示。如表B.7.1所示。

**表B.7.1　三字符序列**

|三字符序列|符号|三字符序列|符号|三字符序列|符号|
|---|---|---|---|---|---|
|`??=`|`#`|`??(`|`[`|`??/`|`\`|
|`??)`|`]`|`??'`|`^`|`??<`|`{`|
|`??!`|`|`|`??>`|`}`|`??-`|

C替换了源代码文件中的这些三字符序列，即使它们在双引号中也是如此。因此，下面的代码：

这段C代码使用了三字符序列来代替 `#`, `{`, `[`, `]`, `\` 和 `}` 等符号。

text

```
??=include <stdio.h>
??=define LIM 100
int main()
??<
int q??(LIM??);
printf("More to come.??/n");
...
??>
```

会变成这样：

这是经过编译器预处理后，将三字符序列替换为标准C符号的等效代码。

text

```
#include <stdio.h>
#define LIM 100
int main()
{
int q[LIM];
printf("More to come.\n");
...
}
```

当然，要在编译器中设置相关选项才能激活这个特性。

#### B.7.2　双字符

意识到三字符系统很笨拙，C99提供了双字符 （digraph ），可以使用它们来替换某些标准C标点符号。

**表B.7.2　双字符**

|双字符|符号|双字符|符号|双字符|符号|
|---|---|---|---|---|---|
|`<:`|`[`|`:>`|`]`|`<%`|`{`|
|`%>`|`}`|`%:`|`#`|`%:%:`|`##`|

与三字符不同的是，不会替换双引号中的双字符。因此，下面的代码：

这段代码使用了双字符序列来代替 `#`, `{`, `[`, `]` 和 `}` 等符号。

text

```
%:include <stdio.h>
%:define LIM 100
int main()
<%
int q<:LIM:>;
printf("More to come.:>");
...
%>
```

会变成这样：

这是经过预处理后的代码，双字符被替换成标准符号，但字符串字面量中的 `:>` 保持不变。

text

```
#include <stdio.h>
#define LIM 100
int main()
{
int q[LIM];
printf("More to come.:>"); // :>是字符串的一部分
...
} // :>与 }相同
```

#### B.7.3　可选拼写：iso646.h

使用三字符序列可以把`||` 运算符写成`??!??!` ，这看上去比较混乱。C99通过`iso646.h` 头文件（参考资料V中的表B.5.11）提供了可展开为运算符的宏。C标准把这些宏称为可选拼写（alternative spelling ）。

如果包含了`iso646.h` 头文件，以下代码：

这段代码使用了 `iso646.h` 中定义的 `or` 和 `and_eq` 宏作为逻辑运算符 `||` 和 `&=` 的替代拼写。

text

```
if(x == M1 or x == M2)
x and_eq 0XFF;
```

可展开为下面的代码：

这是 `or` 和 `and_eq` 宏被预处理器展开后的等效标准C代码。

text

```
if(x == M1 || x == M2)
x &= 0XFF;
```

#### B.7.4　多字节字符

C标准把多字节字符描述为一个或多个字节的序列，表示源环境或执行环境中的扩展字符集成员。源环境指的是编写源代码的环境，执行环境指的是用户运行已编译程序的环境。这两个环境不同。例如，可以在一个环境中开发程序，在另一个环境中运行该程序。扩展字符集是C语言所需的基本字符集的超集。

有些实现会提供扩展字符集，方便用户通过键盘输入与基本字符集不对应的字符。这些字符可用于字符串字面量和字符常量中，也可出现在文件中。有些实现会提供与基本字符集等效的多字节字符，可替换三字符和双字符。

**统一码和ISO 10646**  
例如，德国的一个实现也许会允许用户在字符串中使用日耳曼元音变音字符：  
`puts("eins zwei drei vier fünf");`

一般而言，程序可使用的扩展字符集因本地化设置而异。

#### B.7.5　通用字符名（UCN）

多字节字符可以用在字符串中，但是不能用在标识符中。C99新增了通用字符名 （UCN），允许用户在标识名中使用扩展字符集中的字符。系统扩展了转义序列的概念，允许编码ISO/IEC 10646标准中的字符。该标准由国际标准化组织（ISO）和国际电工技术委员会（IEC）共同制定，为大量的字符提供数值码。10646标准和统一码（Unicode ）关系密切。

有两种形式的UCN序列。第1种形式是`\u`_hexquard_ ，其中_hexquard_ 是一个4 位的十六进制数序列（如，`\u00F6` ）。第2种形式是`\U`_hexquardhexquard_ ，如`\U0000AC01` 。因为十六进制每一位上的数对应4位，`\u` 形式可用于16位整数表示的编码，`\U` 形式可用于32 位整数表示的编码。

如果系统实现了UCN，而且包含了扩展字符集中所需的字符，就可以在字符串、字符常量和标识符中使用UCN：  
`wchar_t value\u00F6\u00F8 = L'\u00f6';`

**统一码和ISO 10646**  
统一码为表示不同的字符集提供了一种解决方案，可以根据类型为大量字符和符号制定标准的编号系统。例如，ASCII码被合并为统一码的子集，因此美国拉丁字符（如A～Z）在这两个系统中的编码相同。但是，统一码还合并了其他拉丁字符（如，欧洲语言中使用的一些字符）和其他语言中的字符，包括希腊文、西里尔字母、希伯来文、切罗基文、阿拉伯文、泰文、孟加拉文和形意文字（如中文和日文）。到目前为止，统一码表示的符号超过了110000个，而且仍在发展中。欲了解更多细节，请查阅统一码联合站点：`www.unicode.org`。

统一码为每个字符分配一个数字，这个数字称为代码点（code point ）。典型的统一码代码点类似：U-222B。U表示该字符是统一字符，222B是表示该字符的一个十六进制数，在这种情况下，表示积分号。

国际标准化组织（ISO）组建了一个团队开发ISO 10646和标准编码的多语言文本。ISO 10646团队和统一码团队从1991年开始合作，一直保持两个标准的相互协调。

#### B.7.6　宽字符

C99为使用宽字符提供更多支持，通过`wchar.h` 和`wctype.h` 库包含了更多大型字符集。这两个头文件把`wchar_t` 定义为一种整型类型，其确切的类型依赖实现。该类型用于储存扩展字符集中的字符，扩展字符集是是基本字符集的超集。根据定义，`char` 类型足够处理基本字符集，而`wchar_t` 类型则需要更多位才能储存更大范围的编码值。例如，`char` 可能是8 位字节，`wchar_t` 可能是16 位的`unsigned short` 。

用`L` 前缀标识宽字符常量和字符串字面量，用`%lc` 和`%ls` 显示宽字符数据：  
`wchar_t wch = L'I';`  
`wchar_t w_arr[20] = L"am wide!";`  
`printf("%lc %ls\n", wch, w_arr);`

例如，如果把`wchar_t` 实现为2字节单元，`'I'` 的1字节编码应储存在`wch` 的低位字节。不是标准字符集中的字符可能需要两个字节储存字符编码。例如，可以使用通用字符编码表示超出`char` 类型范围的字符编码：  
`wchar_t w = L'\u00E2'; /* 16位编码值 */`

内含`wchar_t` 类型值的数组可用于储存宽字符串，每个元素储存一个宽字符编码。编码值为0 的`wchar_t` 值是空字符的`wchar_t` 类型等价字符。该字符被称为空宽字符 （null wide character ），用于表示宽字符串的结尾。

可以使用`%lc` 和`%ls` 读取宽字符：  
`wchar_t wch1;`  
`wchar_t w_arr[20];`  
`puts("Enter your grade:");`  
`scanf("%lc", &wch1);`  
`puts("Enter your first name:");`  
`scanf("%ls",w_arr);`

`wchar_t` 头文件为宽字符提供更多支持，特别是提供了宽字符I/O函数、宽字符转换函数和宽字符串控制函数。例如，可以用`fwprintf()` 和`wprintf()` 函数输出，用`fwscanf()` 和`wscanf()` 函数输入。与一般输入/ 输出函数的主要区别是，这些函数需要宽字符格式字符串，处理的是宽字符输入/ 输出流。例如，下面的代码把信息作为宽字符显示：

这段代码使用 `wprintf` 函数打印一个宽字符字符串。

text

```
wchar_t * pw = L"Points to a wide-character string";
int dozen = 12;
wprintf(L"Item %d: %ls\n", dozen, pw);
```

类似地，还有`getwchar()` 、`putwchar()` 、`fgetws()` 和`fputws()` 函数。`wchar_t` 头文件定义了一个`WEOF` 宏，与`EOF` 在面向字节的I/O中起的作用相同。该宏要求其值是一个与任何有效字符都不对应的值。因为`wchar_t` 类型的值都有可能是有效字符，所以`wchar_t` 库定义了一个`wint_t` 类型，包含了所有`wchar_t` 类型的值和`WEOF` 的值。

该库中还有与`string.h` 库等价的函数。例如，`wcscpy(ws1, ws2)` 把`ws1` 指定的宽字符串拷贝到`ws2` 指向的宽字符数组中。类似地，`wcscmp()` 函数比较宽字符串，等等。

`wctype.h` 头文件新增了字符分类函数，例如，如果`iswdigit()` 函数的宽字符参数是数字，则返回真；如果`iswblank()` 函数的参数是空白，则返回真。空白的标准值是空格和水平制表符，分别写作`L' '` 和`L'\t'` 。

C11标准通过`uchar.h` 头文件为宽字符提供更多支持，为匹配两种常用的统一码格式，定义了两个新类型。第1种类型是`char16_t` ，可储存一个16位编码，是可用的最小无符号整数类型，用于`hexquard` UCN形式和统一码UTF-16编码方案。  
`char16_t ch = '\u00F6';`

第2种类型是`char32_t` ，可储存一个32位编码，最小的可用无符号整数类型。可用于 `hexquard` UCN形式和统一码UTF-32编码方案。  
`char32_t ch = '\U0000AC01';`

前缀`u` 和`U` 分别表示`char16_t` 和`char32_t` 字符串。  
`char16_t ws16[11] = u"Tannh\u00E4user";`  
`char32_t ws32[13] = U"caf\U000000E9 au lait";`

注意，这两种类型比`wchar_t` 类型更具体。例如，在一个系统中，`wchar_t` 可以储存32位编码，但是在另一个系统中也许只能储存16位的编码。另外，这两种新类型都与C++兼容。

#### B.7.7　宽字符和多字节字符

宽字符和多字节字符是处理扩展字符集的两种不同的方法。例如，多字节字符可能是一个字节、两个字节、三个字节或更多字节，而所有的宽字符都只有一个宽度。多字节字符可能使用移位状态（移位状态是一个字节，确定如何解释后续字节）；而宽字符没有移位状态。可以把多字节字符的文件读入使用标准输入函数的普通`char` 类型数组，把宽字节的文件读入使用宽字符输入函数的宽字节数组。

C99在`wchar.h` 库中提供了一些函数，用于多字节和宽字节之间的转换。`mbrtowc()` 函数把多字节字符转换为宽字符，`wcrtomb()` 函数把宽字符转换为多字节字符。类似地，`mbstrtowcs()` 函数把多字节字符串转换为宽字节字符串，`wcstrtombs()` 函数把宽字节字符串转换为多字节字符串。

C11在`uchar.h` 库中提供了一些函数，用于多字节和`char16_t` 之间的转换，以及多字节和`char32_t` 之间的转换。

### B.8　参考资料VIII：C99/C11数值计算增强

过去，FORTRAN是数值科学计算和工程计算的首选语言。C90使C的计算方法更接近于FORTRAN。例如，`float.h` 中使用的浮点特性规范都是基于FORTRAN标准委员会开发的模型。C99和C11标准继续增强了C的计算能力。例如，C99新增的变长数组（C11成为可选的特性），比传统的C数组更符合FORTRAN的用法（如果实现不支持变长数组，C11指定了`__STDC_NO_VLA__` 宏的值为1 ）。

#### B.8.1　IEC浮点标准

国际电工技术委员会（IEC）已经发布了一套浮点计算的标准（IEC 60559）。该标准包括了浮点数的格式、精度、NaN、无穷值、舍入规则、转换、异常以及推荐的函数和算法等。C99纳入了该标准，将其作为C实现浮点计算的指导标准。C99新增的大部分浮点工具（如，`fenv.h` 头文件和一些新的数学函数）都基于此。另外，`float.h` 头文件定义了一些与IEC浮点模型相关的宏。

**1．浮点模型**

下面简要介绍一下浮点模型。标准把浮点数x 看作是一个基数的某次幂乘以一个分数，而不是C语言的E 记数法（例如，可以把876.54 写成`0.87654E3` ）。正式的浮点表示更为复杂：

$$x=sb^e\sum_{k=1}^p{{f_k}^b}^{-k}$$

简单地说，这种表示法把一个数表示为有效数 （significand ）与b 的e 次幂的乘积。  
下面是各部分的含义。

- s 代表符号（±1 ）。
- b 代表基数。最常见的值是2 ，因为浮点处理器通常使用二进制数学。
- e 代表整数指数（不要与自然对数中使用的数值常量e 混淆），限制最小值和最大值。这些值依赖于留出储存指数的位数。
- fk 代表基数为b 时可能的数字。例如，基数为2 时，可能的数字是0 和1 ；在十六进制中，可能的数字是0 ～F 。
- p 代表精度，基数为b 时，表示有效数的位数。其值受限于预留储存有效数字的位数。

明白这种表示法的关键是理解`float.h` 和`fenv.h` 的内容。下面，举两个例子解释内部如何表示浮点数。

首先，假设一个浮点数的基数b 为10 ，精度p 为5 。那么，根据上面的表示法，24.51 应写成：  
`(+1)10^3 (2/10 + 4/100 + 5/1000 + 1/10000 + 0/100000)`

假设计算机可储存十进制数（0 ～9 ），那么可以储存符号、指数3 和5 个fk 值：2 、4 、5 、1 、0 （这里，f 1 是2，f 2 是4，等等）。因此，有效数是0.24510 ，乘以10^3 得24.51 。

接下来，假设符号为正，基数b 是2 ，p 是7 （即，用7 位二进制数表示），指数是5 ，待储存的有效数是1011001 。下面，根据上面的公式构造该数：

text

```
x = (+1)2^5 (1/2 +0/4 + 1/8 + 1/16 + 0/32 + 0/64 + 1/128)
　= 32(1/2 +0/4 + 1/8 + 1/16 + 0/32 + 0/64 + 1/128)
　= 16 + 0 + 4 + 2 +0 + 0 + 1/4 = 22.25
```

`float.h` 中的许多宏都与该浮点表示相关。例如，对于一个`float` 类型的值，表示基数的`FLT_RADIX` 是b ，表示有效数位数（基数为b 时）的`FLT_MANT_DIG` 是p 。

**2．正常值和低于正常的值**

正常浮点值 （normalized floating-point value ）的概念非常重要，下面简要介绍一下。为简单起见，先假设系统使用十进制（b = `FLT_RADIX` = 10 ）和浮点值的精度为5 （p = `FLT_MANT_DIG` = 5 ）（标准要求的精度更高）。考虑下面表示31.841 的方式：

指数 = 3 ，有效数 = .31841 （ `.31841E3` ）  
指数 = 4 ，有效数 = .03184 （ `.03184E4` ）  
指数 = 5 ，有效数 = .00318 （ `.00318E5` ）

显而易见，第1 种方法精度最高，因为在有效数中使用了所有的5位可用位。规范化浮点非零值是第1 位有效位为非零的值，这也是通常储存浮点数的方式。

现在，假设最小指数（`FLT_MIN_EXP` ）是-10 ，那么最小的规范值是：  
指数 = -10 ，有效数 = .10000 （ `.10000E-10` ）

通常，乘以或除以10 意味着使指数增大或减小，但是在这种情况下，如果除以10 ，却无法再减小指数。但是，可以改变有效数获得这种表示：  
指数 = -10 ，有效数 = .01000 （ `.01000E-10` ）

这个数被称为低于正常的 （subnormal ），因为该数并未使用有效数的全精度。例如，`0.12343E-10` 除以10 得`.01234E-10` ，损失了一位的信息。

对于这个特例，`0.1000E-10` 是最小的非零正常值（`FLT_MIN`），最小的非零低于正常值是`0.00001E-10` （`FLT_TRUE_MIN` ）。

`float.h` 中的宏`FLT_HAS_SUBNURM` 、`DBL_HAS_SUBNORM` 和`LDBL_HAS_SUBNORM` 表征实现如何处理低于正常的值。下面是这些宏可能会用到的值及其含义：

- -1 　　 　 不确定（尚未统一）
- 0 　　　　不存在（例如，实现可能会用 0 替换低于正常的值）
- 1 　　　　存在

`math.h` 库提供一些方法，包括`fpclassify()` 和`isnormal()` 宏，可以识别程序何时生成低于正常的值，这样会损失一些精度。

**3．求值方案**

`float.h` 中的宏`FLT_EVAL_METHOD` 确定了实现采用何种浮点表达式的求值方案，如下所示（有些实现还会提供其他负值选项）。

- -1 　 　 不确定
- 0 　　　对在所有浮点类型范围和精度内的操作、常量求值
- 1 　　　对在 `double` 类型的精度内和 `float` 、 `double` 类型的范围内的操作、常量求值，对 `longdouble` 范围内的 `long double` 类型的操作、常量求值
- 2 　　　对所有浮点类型范围内和 `long double` 类型精度内的操作和常量求值

例如，假设程序中要把两个`float` 类型的值相乘，并把乘积赋给第3 个`float` 类型变量。对于选项1 （即K&R C采用的方案），这两个`float` 类型的值将被扩展为`double` 类型，使用`double` 类型完成乘法计算，然后在赋值计算结果时再把乘积转为`float` 类型。

如果选择0 （即ANSI C采用的方案），实现将直接使用这两个`float` 类型的值相乘，然后赋值乘积。这样做比选项1 快，但是会稍微损失一点精度。

**4．舍入**

`float.h` 中的宏`FLT_ROUNDS` 确定了系统如何处理舍入，其指定值所对应的舍入方案如下所示。

- -1 　　 　 不确定
- 0 　　　　趋零截断
- 1 　　　　舍入到最接近的值
- 2 　　　　趋向正无穷
- 3 　　　　趋向负无穷

系统可以定义其他值，对应其他舍入方案。  
一些系统提供控制舍入的方案，在这种情况下，`fenv.h` 中的`festround()` 函数提供编程控制。

如果只是计算制作37 个蛋糕需要多少面粉，这些不同的舍入方案可能并不重要，但是对于金融和科学计算而言，这很重要。显然，把较高精度的浮点值转换成较低精度值时需要使用舍入方案。例如，把`double` 类型的计算结果赋给`float` 类型的变量。另外，在改变进制时，也会用到舍入方案。不同进制下精确表示的分数不同。例如，考虑下面的代码：  
`float x = 0.8;`

在十进制下，8/10 或4/5 都可以精确表示0.8 。但是大部分计算机系统都以二进制储存结果，在二进制下，4/5 表示为一个无限循环小数：  
`0.1100110011001100...`

因此，在把0.8 储存在x 中时，将其舍入为一个近似值，其具体值取决于使用的舍入方案。

尽管如此，有些实现可能不满足IEC 60559的要求。例如，底层硬件可能无法满足要求。因此，C99定义了两个可用作预处理器指令的宏，检查实现是否符合规范。第1 个宏是`__STDC_IEC_559__` ，如果实现遵循IEC 60559浮点规范，该宏被定义为常量1 。第2 个宏是`__STDC_IEC_559_COMPLEX__` ，如果实现遵循IEC 60559兼容复数运算，该宏被定义为常量1 。

如果实现中未定义这两个宏，则不能保证遵循IEC 60559。
### B.8.2　fenv.h 头文件

`fenv.h` 头文件提供一些与浮点环境交互的方法。也就是说，允许用户设置浮点控制模式值 （该值管理如何执行浮点运算）并确定浮点状态标志（或异常）的值（报告运算效果的信息）。例如，控制模式设置可指定舍入的方案；如果运算出现浮点溢出则设置一个状态标志。设置状态标志的操作叫作抛出异常 。  
状态标志和控制模式只有在硬件支持的前提下才能发挥作用。例如，如果硬件没有这些选项，则无法更改舍入方案。  
使用下面的编译指示开启支持：  
`#pragma STDC FENV_ACCESS ON`  
这意味着程序到包含该编译指示的块末尾一直支持，或者如果该编译指示是外部的，则支持到该文件或翻译单元的末尾。使用下面的编译指示关闭支持：  
`#pragma STDC FENV_ACCESS OFF`  
使用下面的编译指示可恢复编译器的默认设置，具体设置取决于实现：  
`#pragma STDC FENV_ACCESS DEFAULT`  
如果涉及关键的浮点运算，这个功能非常重要。但是，一般用户使用的程度有限，所以本附录不再深入讨论。

### B.8.3　STDC FP_CONTRACT 编译指示

一些浮点数处理器可以把有多个运算符的浮点表达式合并成一个运算。例如，处理器只需一步就求出下面表达式的值：  
`x*y - z`  
这加快了运算速度，但是减少了运算的可预测性。`STDC FP_CONTRACT` 编译指示允许用户开启或关闭这个特性。默认状态取决于实现。

这段代码展示了如何使用 `STDC FP_CONTRACT` 编译指示来为特定的运算关闭合并特性，然后再重新开启它。

text

```
#pragma STDC FP_CONTRACT OFF
val = x * y - z;
#pragma STDC FP_CONTRACT ON
```

### B.8.4　math.h 库增补

大部分C90数学库中都声明了`double` 类型参数和`double` 类型返回值的函数，例如：  
`double sin(double);`  
`double sqrt(double);`  
C99和C11库为所有这些函数都提供了`float` 类型和`long double` 类型的函数。这些函数的名称由原来函数名加上f 或l 后缀构成，例如：  
`float sinf(float); /* sin()的float版本 */`  
`long double sinl(long double); /* sin()的long double版本 */`  
有了这些不同精度的函数系列，用户可以根据具体情况选择最效率的类型和函数组合。  
C99还新增了一些科学、工程和数学运算中常用的函数。表B.5.16 列出了所有数学函数的double 版本。在许多情况下，这些函数的返回值都可以使用现有的函数计算得出，但是新函数计算得更快更精确。例如，`loglp(x)` 表示的值与与`log(1 + x)` 相同，但是`loglp(x)` 使用了不同的算法，对于较小的x 值而言计算更精确。因此，可以使用`log()` 函数作普通运算，但是对于精确要求较高且x 值较小时，用`loglp()` 函数更好。  
除这些函数以外，数学库中还定义了一些常量和与数字分类、舍入相关的函数。例如，可以把值分为无穷值、非数（`NaN` ）、正常值、低于正常的值、真零。[ `NaN` 是一个特别的值，用于表示一个不是数的值。例如，`asin(2.0)` 返回`NaN` ，因为定义了`asin()` 函数的参数必须是-1 ～1 范围内的值。低于正常的值是比使用全精度表示的最小值还要小的数。] 还有一些专用的比较函数，如果一个或多个参数是非正常值时，函数的行为与标准的关系运算符不同。  
使用C99的分类方案可以检测计算的规律性。例如，`math.h` 中的`isnormal()` 宏，如果其参数是一个正常的数，则返回真。

下面的代码片段使用 `isnormal()` 宏来控制一个循环，当变量 `num` 的值不再是正常的（即全精度的）浮点数时，循环结束。

text

```
#include <math.h> // 为了使用isnormal()
...
float num = 1.7e-19;
float numprev = num;
while (isnormal(num)) // 当num为全精度的float类型值
{
numprev = num;
num /= 13.7f;
}
```

简而言之，数学库为更好地控制如何计算浮点数，提供了扩展支持。

### B.8.5　对复数的支持

复数是有实部和虚部的数。实部是普通的实数，如浮点类型表示的数。虚部表示一个虚数。虚数是-1 的平方根的倍数。在数学中，复数通常写作类似4.2 + 2.0i 的形式，其中i 表示-1 的平方根。  
C99支持3种复数类型（在C11中为可选）：  
`float _Complex`  
`double _Complex`  
`long double _Compplex`  
...  
例如，储存`float _Complex` 类型的值时，使用与两个`float` 类型元素的数组相同的内存布局，实部值储存在第1 个元素中，虚部值储存在第2 个元素中。  
C99和C11还支持下面3种虚类型：  
`float _Imaginary`  
`double _Imaginary`  
`long double _Imaginary`  
包含了`complex.h` 头文件，就可以用`complex` 代替`_Complex` ，用`imaginary` 代替`_Imaginary` 。  
为复数类型定义的算术运算遵循一般的数学规则。例如，

(a+b∗I)∗(c+d∗I) 即是 (a∗c−b∗d)+(b∗c+a∗d)∗I(a+b∗I)∗(c+d∗I) 即是 (a∗c−b∗d)+(b∗c+a∗d)∗I

`complex.h` 头文件定义了一些宏和接受复数参数并返回复数的函数。特别是，宏`I` 表示-1 的平方根。因此，可以编写这样的代码：  
`double complex c1 = 4.2 + 2.0 * I;`  
`float imaginary c2= -3.0 * I;`  
C11提供了另一种方法，通过`CMPLX()` 宏给复数赋值。例如，如果`re` 和`im` 都是`double` 类型的值，可以这样做：  
`double complex c3 = CMPLX(re, im);`  
...  
这种方法的目的是，宏在处理不常见的情况（如，`im` 是无穷大或非数）时比直接赋值好。  
`complex.h` 头文件提供了一些复数函数的原型，其中许多复数函数都有对应`math.h` 中的函数，其函数名即是对应函数名前加上c 前缀。例如，`csin()` 返回其复数参数的复正弦。其他函数与特定的复数特性相关。例如，`creal()` 函数返回一个复数的实部，`cimag()` 函数返回一个复数的虚部。也就是说，给定一个`double conplex` 类型的`z` ，下面的代码为真：  
`z = creal(z) + cimag(z) * I;`  
如果熟悉复数，需要使用复数，请详细阅读`complex.h` 中的内容。

下面的示例程序 `complex.c` 演示了 C 语言对复数的支持，包括如何声明复数变量、从用户输入创建复数、进行复数的加法和乘法运算，以及计算共轭复数。

text

```
// complex.c -- 复数
#include <stdio.h>
#include <complex.h>
void show_cmlx(complex double cv);
int main(void)
{
complex double v1 = 4.0 + 3.0*I;
double re, im;
complex double v2;
complex double sum, prod, conjug;
printf("Enter the real part of a complex number: ");
scanf("%lf", &re);
printf("Enter the imaginary part of a complex number: ");
scanf("%lf", &im);
// CMPLX()是C11中的一个特性
// v2 = CMPLX(re, im);
v2 = re + im * I;
printf("v1: ");
show_cmlx(v1);
putchar('\n');
printf("v2: ");
show_cmlx(v2);
putchar('\n');
sum = v1 + v2;
prod = v1 * v2;
conjug =conj(v1);
printf("sum: ");
show_cmlx(sum);
putchar('\n');
printf("product: ");
show_cmlx(prod);
putchar('\n');
printf("complex congjugate of v1: ");
show_cmlx(conjug);
putchar('\n');
return 0;
}
void show_cmlx(complex double cv)
{
printf("(%.2f, %.2fi)", creal(cv), cimag(cv));
return;
}
```

如果使用C++，会发现C++的`complex` 头文件提供一种基于类的方式处理复数，这与C的`complex.h` 头文件使用的方法不同
### B.9　参考资料IX：C和C++的区别

在很大程度上，C++是C的超集，这意味着一个有效的C程序也是一个有效的C++程序。C和C++的主要区别是，C++支持许多附加特性。但是，C++中有许多规则与C稍有不同。这些不同使得C程序作为C++程序编译时可能以不同的方式运行或根本不能运行。本节着重讨论这些区别。如果使用C++的编译器编译C程序，就知道这些不同之处。虽然C和C++的区别对本书的示例影响很小，但如果把C代码作为C++程序编译的话，会导致产生错误的消息。  
C99标准的发布使得问题更加复杂，因为有些情况下使得C更接近C++。例如，C99标准允许在代码中的任意处进行声明，而且可以识别`//` 注释指示符。在其他方面，C99使其与C++的差异变大。例如，新增了变长数组和关键字`restrict` 。C11缩小了与C++的差异。例如，引进了`char16_t` 类型，新增了关键字`_Alignas` ，新增了`alignas` 宏与C++的关键字匹配。C11 仍处于起步阶段，许多编译器开发商甚至都没有完全支持C99。我们要了解C90、C99、C11之间的区别，还要了解C++11与这些标准之间的区别，以及每个标准与C标准之间的区别。这部分主要讨论C99、C11和C++之间的区别。当然，C++ 也正在发展，因此，C和C++的异同也在不断变化。

#### B.9.1　函数原型

在C++中，函数原型必不可少，但是在C中是可选的。这一区别在声明一个函数时让函数名后面的圆括号为空，就可以看出来。在C中，空圆括号说明这是前置原型，但是在C++中则说明该函数没有参数。也就是说，在C++中，`int slice();` 和`int slice(void);` 相同。

下面的代码是一个旧风格的C程序示例。在C语言中，这是可以接受的，但如果作为C++程序编译则会产生错误，因为C++编译器会认为 `slice()` 是一个无参函数，与后面的定义和调用不匹配。

text

```
int slice();
int main()
{
...
slice(20, 50);
...
}
int slice(int a, int b)
{
...
}
```

在C中，编译器假定用户使用旧风格声明函数。在C++中，编译器假定`slice()` 与`slice(void)` 相同，且未声明`slice(int, int)` 函数。  
另外，C++允许用户声明多个同名函数，只要它们的参数列表不同即可。

#### B.9.2　char 常量

C把`char` 常量视为`int` 类型，而C++ 将其视为`char` 类型。例如，考虑下面的语句：  
`char ch = 'A';`  
在C中，常量`'A'` 被储存在`int` 大小的内存块中，更精确地说，字符编码被储存为一个`int` 类型的值。相同的数值也储存在变量`ch` 中，但是在`ch` 中该值只占内存的1 字节。  
在C++中，`'A'` 和`ch` 都占用1字节。它们的区别不会影响本书中的示例。但是，有些C程序利用`char` 常量被视为`int` 类型这一特性，用字符来表示整数值。例如，如果一个系统中的`int` 是4字节，就可以这样编写C代码：  
`int x = 'ABCD'; /*对于int是4字节的系统，该语句出现在C程序中没问题，但是出现在C++程序中会出错 */`  
`'ABCD'` 表示一个4字节的`int` 类型值，其中第1个字节储存A 的字符编码，第2个字节储存B 的字符编码，以此类推。注意，`'ABCD'` 和`"ABCD"` 不同。前者只是书写`int` 类型值的一种方式，而后者是一个字符串，它对应一个5字节内存块的地址。

下面的代码演示了在C语言环境中，`'ABCD'` 如何被当作 `int` 类型和 `char` 类型处理。

text

```
int x = 'ABCD';
char c = 'ABCD';
printf("%d %d %c %c\n", x, 'ABCD', c, 'ABCD');
```

在我们的系统中，得到的输出如下：

text

```
1094861636 1094861636 D D
```

该例说明，如果把`'ABCD'` 视为`int` 类型，它是一个4字节的整数值。但是，如果将其视为`char` 类型，程序只使用最后一个字节。在我们的系统中，尝试用`%s` 转换说明打印`'ABCD'` 会导致程序奔溃，因为`'ABCD'` 的数值（1094861636 ）已超出该类型可表示的范围。  
可以这样使用的原因是C提供了一种方法可单独设置`int` 类型中的每个字节，因为每个字符都对应一个字节。但是，由于要依赖特定的字符编码，所以更好的方法是使用十六进制的整型常量，因为每两位十六进制数对应一个字节。第15章详细介绍过相关内容（C 的早期版本不提供十六进制记法，这也许是多字符常量技术首先得到发展的原因）。

#### B.9.3　const 限定符

在C中，全局的`const` 具有外部链接，但是在C++中，具有内部链接。也就是说，下面C++的声明：  
`const double PI = 3.14159;`  
相当于下面C中的声明：  
`static const double PI = 3.14159;`  
假设这两条声明都在所有函数的外部。C++规则的意图是为了在头文件更加方便地使用`const` 。如果`const` 变量是内部链接，每个包含该头文件的文件都会获得一份`const` 变量的备份。如果`const` 变量是外部链接，就必须在一个文件中进行定义式声明，然后在其他文件中使用关键字`extern` 进行引用式声明。  
顺带一提，C++可以使用关键字`extern` 使一个`const` 值具有外部链接。所以两种语言都可以创建内部链接和外部链接的`const` 变量。它们的区别在于默认使用哪种链接。  
另外，在C++中，可以用`const` 来声明普通数组的大小：  
`const int ARSIZE = 100;`  
`double loons[ARSIZE]; /* 在C++中，与double loons[100];相同 */`  
当然，也可以在C99中使用相同的声明，不过这样的声明会创建一个变长数组。

这段代码展示了C++允许使用 `const` 变量初始化另一个 `const` 变量，而C语言（C99之前）则不允许。

text

```
const double RATE = 0.06; // C++和C都可以
const double STEP = 24.5; // C++和C都可以
const double LEVEL = RATE * STEP; // C++可以，C不可以
```

#### B.9.4　结构和联合

声明一个有标记的结构或联合后，就可以在C++中使用这个标记作为类型名：  
`struct duo { int a; int b; };`  
`struct duo m; /* C和C++都可以 */`  
`duo n; /* C不可以，C++可以*/`  
结果是结构名会与变量名冲突。

下面的程序在C中可以编译通过，但在C++中会编译失败。原因是C++将 `printf()` 语句中的 `duo` 解释为结构类型，与同名的全局变量产生了冲突。

text

```
#include <stdio.h>
float duo = 100.3;
int main(void)
{
struct duo { int a; int b;};
struct duo y = { 2, 4};
printf ("%f\n", duo); /* 在C中没问题，但是在C++不行 */
return 0;
}
```

在C和C++中，都可以在一个结构的内部声明另一个结构：

这段代码定义了一个嵌套结构，其中 `struct point` 定义在 `struct box` 内部。

text

```
struct box
{
struct point {int x; int y; } upperleft;
struct point lowerright;
};
```

在C中，随后可以使用任意使用这些结构，但是在C++中使用嵌套结构时要使用一个特殊的符号：

下面的代码片段展示了C和C++在访问嵌套结构类型时的语法差异。

text

```
struct box ad; /* C和 C++都可以 */
struct point dot; /* C可以，C++不行 */
box::point dot; /* C不行，C++可以 */
```

#### B.9.5　枚举

C++使用枚举比C严格。特别是，只能把`enum` 常量赋给`enum` 变量，然后把变量与其他值作比较。不经过显式强制类型转换，不能把`int` 类型值赋给`enum` 变量，而且也不能递增一个`enum` 变量。

下面的代码说明了C++对枚举类型更严格的类型检查规则。

text

```
enum sample {sage, thyme, salt, pepper};
enum sample season;
season = sage; /* C和C++都可以 */
season = 2; /* 在C中会发出警告，在C++中是一个错误 */
season = (enum sample) 3; /* C和C++都可以*/
season++; /* C可以，在C++中是一个错误 */
```

另外，在C++中，不使用关键字`enum` 也可以声明枚举变量：

下面的代码展示了在C++中声明枚举变量可以省略 `enum` 关键字，这在C中是不允许的。

text

```
enum sample {sage, thyme, salt, pepper};
sample season; /* C++可以，在C中不可以 */
```

与结构和联合的情况类似，如果一个变量和`enum` 类型的同名会导致名称冲突。

#### B.9.6　指向void 的指针

C++可以把任意类型的指针赋给指向`void` 的指针，这点与C相同。但是不同的是，只有使用显式强制类型转换才能把指向`void` 的指针赋给其他类型的指针。

这段代码演示了将 `void` 指针赋值给其他类型指针时C和C++的差异：C允许隐式转换，而C++要求显式转换。

text

```
int ar[5] = {4, 5, 6,7, 8};
int * pi;
void * pv;
pv = ar; /* C和C++都可以 */
pi = pv; /* C可以，C++不可以 */
pi = (int * ) pv; /* C和C++都可以 */
```

C++与C的另一个区别是，C++可以把派生类对象的地址赋给基类指针，但是在C中没有这里涉及的特性。

#### B.9.7　布尔类型

在C++中，布尔类型是`bool` ，而且`ture` 和`false` 都是关键字。在C 中，布尔类型是`_Bool` ，但是要包含`stdbool.h` 头文件才可以使用`bool` 、`true` 和`false` 。

#### B.9.8　可选拼写

在C++中，可以用`or` 来代替`||` ，还有一些其他的可选拼写，它们都是关键字。在C99和C11中，这些可选拼写都被定义为宏，要包含`iso646.h` 才能使用它们。

#### B.9.9　宽字符支持

在C++中，`wchar_t` 是内置类型，而且`wchar_t` 是关键字。在C99和C11中，`wchar_t` 类型被定义在多个头文件中（`stddef.h` 、`stdlib.h` 、`wchar.h` 、`wctype.h` ）。与此类似，`char16_t` 和`char32_t` 都是C++11的关键字，但是在C11中它们都定义在`uchar.h` 头文件中。  
C++通过`iostream` 头文件提供宽字符I/O支持（`wchar_t` 、`char16_t` 和`char32_t` ），而C99通过`wchar.h` 头文件提供一种完全不同的I/O支持包。

**注意**

#### B.9.10　复数类型

C++在`complex` 头文件中提供一个复数类来支持复数类型。C 有内置的复数类型，并通过`complex.h` 头文件来支持。这两种方法区别很大，不兼容。C更关心数值计算社区提出的需求。

#### B.9.11　内联函数

C99支持了C++的内联函数特性。但是，C99的实现更加灵活。在C++中，内联函数默认是内部链接。在C++中，如果一个内联函数多次出现在多个文件中，该函数的定义必须相同，而且要使用相同的语言记号。例如，不允许在一个文件的定义中使用`int` 类型形参，而在另一个文件的定义中使用`int32_t` 类型形参。即使用`typedef` 把`int32_t` 定义为`int` 也不能这样做。但是在C中可以这样做。另外，在第15章中介绍过，C允许混合使用内联定义和外部定义，而C++不允许。

#### B.9.12　C++11中没有的C99/C11特性

虽然在过去C或多或少可以看作是C++的子集，但是C99标准增加了一些C++没有的新特性。下面列出了一些只有C99/C11中才有的特性：

- 指定初始化器；
- 复合初始化器（Compound initializer）；
- 受限指针（Restricted pointer ）（即，`restric`指针）；
- 变长数组；
- 伸缩型数组成员；
- 带可变数量参数的宏。

以上所列只是在特定时期内的情况，随着时间的推移和C、C++的不断发展，列表中的项会有所增减。例如，C++14新增的一个特性就与C99的变长数组类似。  
......

---

**脚注**

1. `FLT_RADIX`用于表示3种浮点数类型的基数。——译者注
2. NaN 分为两类：quite NaN 和singaling NaN 。两者的区别是：quite NaN 的尾数部分最高位定义为1 ，而singaling NaN 最高位定义为0 。——译者注
3. 也称为世界标准时间，简称UTC，从英文“Coordinated Universal Time”/法文“Temps Universel Cordonné”而来。中国内地的时间与UTC的时差为+8，也就是UTC+8。——译者注
4. `fwide()` 函数用于设置流的定向，根据mode 的不同值来执行不同的工作。——译者注
