# 单字符I/O：getchar() 和 putchar()
getchar() 和putchar() 每次只处理一个字符。自从ANSI C标准发布以后，C就把stdio.h 头文件与使用 getchar() 和putchar() 相关联，这就是为什么程序中要包含这个头文件的原因
# 缓冲区
大部分系统在用户按下Enter 键之前不会重复打印刚输入的字符，这种输入形式属于缓冲输入。用户输入的字符被收集并储存在一个被称为缓冲区 （buffer ）的临时存储区，按下 Enter 键后，程序才可使用用户输入的字符。
为什么要有缓冲区？首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间。其次，如果用户打错字符，可以直接通过键盘修正错误。当最后按下Enter 键时，传输的是正确的输入。
虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入。例如，在游戏中，你希望按下一个键就执行相应的指令。因此， 缓冲输入和无缓冲输入都有用武之地。
缓冲分为两类：完全缓冲 I/O和行缓冲 I/O。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是512字节和4096字节。行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter 键后才刷新缓冲区。
那么，使用缓冲输入还是无缓冲输入？ANSI C和后续的C标准都规定输入是缓冲的，不过最初K&R把这个决定权交给了编译器的编写者。读者可以运行echo.c 程序观察输出的情况，了解所用的输出类型。
==ANSI C决定把缓冲输入作为标准的原因是：一些计算机不允许无缓冲输入。==如果你的计算机允许无缓冲输入，那么你所用的C编译器很可能会提供一个无缓冲输入的选项。例如，许多IBM PC兼容机的编译器都为支持无缓冲输入提供一系列特殊的函数，其原型都在 conio.h 头文件中。这些函数包括用于回显无缓冲输入的getche() 函数和用于无回显无缓冲输入的getch() 函数（回显输入意味着用户输入的字符直接显示在屏幕上，无回显输入意味着击键后对应的字符不显示）。UNIX系统使用另一种不同的方式控制缓冲。在UNIX系统中，可以使用ioctl() 函数（该函数属于UNIX库，但是不属于C标准）指定待输入的类型，然后用getchar() 执行相应的操作。在 ANSI C中，用setbuf() 和setvbuf() 函数控制缓冲，但是受限于一些系统的内部设置，这些函数可能不起作用。总之，ANSI没有提供调用无缓冲输入的标准方式，这意味着是否能进行无缓冲输入取决于计算机系统。这里假设所有的输入都是缓冲输入。
# 结束键盘输入
应该用一个在文本中用不到的字符来标记输入完成， 这样的字符不会无意间出现在输入中，在你不希望结束程序的时候终止程序。C的确提供了这样的字符，不过在此之前，先来了解一下C处理文件的方式。
## 文件、流和键盘输入
文件 （file ）是存储器中储存信息的区域。通常，文件都保存在某种永久存储器中（如，硬盘、U盘或DVD等）。
C是一门强大、灵活的语言，有许多用于打开、读取、写入和关闭文件的库函数。从较低层面上，C可以使用主机操作系统的基本文件工具直接处理文件，这些直接调用操作系统的函数被称为底层 I/O （ low-level I/O ） 。由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库，ANSI C也不打算这样做。然而从较高层面上，C还可以通过标准 I/O包 （standard I/O package ）来处理文件。这涉及创建用于处理文件的标准模型和一套标准I/O函数。在这一层面上，具体的C实现负责处理不同系统的差异，以便用户使用统一的界面。
上面讨论的差异指的是什么？例如，不同的系统储存文件的方式不同。有些系统把文件的内容储存在一处，而文件相关的信息储存在另一处；有些系统在文件中创建一份文件描述。在处理文件方面，有些系统使用单个换行符标记行末尾，而其他系统可能使用回车符和换行符的组合来表示行末尾。有些系统用最小字节来衡量文件的大小， 有些系统则以字节块的大小来衡量。
如果使用标准I/O包，就不用考虑这些差异。因此，可以用if (ch == '\n') 检查换行符。即使系统实际用的是回车符和换行符的组合来标记行末尾，I/O函数会在两种表示法之间相互转换。
从概念上看，C程序处理的是流而不是直接处理文件。流 （stream ）是一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。
C把输入和输出设备视为存储设备上的普通文件，尤其是把键盘和显示设备视为每个C程序自动打开的文件。stdin 流表示键盘输入，stdout 流表示屏幕输出。getchar() 、putchar() 、printf() 和scanf() 函数都是标准I/O包的成员，处理这两个流。
以上讨论的内容说明，可以用处理文件的方式来处理键盘输入。例如，程序读文件时要能检测文件的末尾才知道应在何处停止。因此，C的输入函数内置了文件结尾检测器。既然可以把键盘输入视为文件，那么也应该能使用文件结尾检测器结束键盘输入。下面我们从文件开始，学习如何结束文件。
## 文件结尾
计算机操作系统要以某种方式判断文件的开始和结束。检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾。 CP/M、IBM-DOS和MS-DOS的文本文件曾经用过这种方法。如今，这些操作系统可以使用内嵌的Ctrl+Z 字符来标记文件结尾。这曾经是操作系统使用的唯一标记，不过现在有一些其他的选择，例如记录文件的大小。所以现代的文本文件不一定有嵌入的Ctrl+Z ，但是如果有，该操作系统会将其视为一个文件结尾标记。
操作系统使用的另一种方法是储存文件大小的信息。如果文件有 3000字节，程序在读到3000字节时便达到文件的末尾。MS-DOS及其相关系统使用这种方法处理二进制文件，因为用这种方法可以在文件中储存所有的字符，包括Ctrl+Z 。新版的DOS也使用这种方法处理文本文件。UNIX使用这种方法处理所有的文件。
无论操作系统实际使用何种方法检测文件结尾，在C语言中，用 getchar() 读取文件检测到文件结尾时将返回一个特殊的值，即EOF （end of file的缩写）。scanf() 函数检测到文件结尾时也返回EOF 。通常，EOF 定义在stdio.h 文件中：
```c
#define EOF (-1)
```
为什么是-1 ？因为getchar() 函数的返回值通常都介于0 ～ 127 ，这些值对应标准字符集。但是，如果系统能识别扩展字符集， 该函数的返回值可能在0 ～255 之间。无论哪种情况，-1 都不对应任何字符，所以，该值可用于标记文件结尾。
某些系统也许把EOF 定义为-1 以外的值，但是定义的值一定与输入字符所产生的返回值不同。如果包含stdio.h 文件，并使用EOF 符号，就不必担心EOF 值不同的问题。这里关键要理解EOF 是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号。
那么，如何在程序中使用EOF ？把getchar() 的返回值和EOF 作比较。如果两值不同，就说明没有到达文件结尾。也就是说，可以使用下面这样的表达式：
```
while ((ch = getchar()) != EOF)
```
如果正在读取的是键盘输入不是文件会怎样？绝大部分系统（不是全部）都有办法通过键盘模拟文件结尾条件。
要设法输入EOF 字符。不能只输入字符EOF ，也不能只输入-1 （输入-1 会传送两个字符：一个连字符和一个数字1 ）。正确的方法是，必须找出当前系统的要求。例如，在大多数UNIX和Linux系统中，在一行开始处按下Ctrl+D 会传输文件结尾信号。许多微型计算机系统都把一行开始处的 Ctrl+Z 识别为文件结尾信号，一些系统把任意位置的Ctrl+Z 解释成文件结尾信号。

**模拟EOF和图形界面**
模拟EOF 的概念是在使用文本界面的命令行环境中产生的。在这种环境中，用户通过击键与程序交互，由操作系统生成EOF 信号。但是在一些实际应用中，却不能很好地转换成图形界面（如Windows和Macintosh），这些用户界面包含更复杂的鼠标移动和按钮点击。程序要模拟EOF 的行为依赖于编译器和项目类型。例如，Ctrl+Z 可以结束输入或整个程序，这取决于特定的设置。
# 重定向和文件
程序如何知道去哪里查找输入？
在默认情况下，C程序使用标准I/O包查找标准输入作为输入源。这就是前面介绍过的stdin 流，它是把数据读入计算机的常用方式。它可以是一个过时的设备，如磁带、穿孔卡或电传打印机，或者（假设）是键盘，甚至是一些先进技术，如语音输入。然而，现代计算机非常灵活，可以让它到别处查找输入。尤其是，可以让一个程序从文件中查找输入，而不是从键盘。
程序可以通过两种方式使用文件。第1种方法是，显式使用特定的函数打开文件、关闭文件、读取文件、写入文件，诸如此类。第2种方法是，设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出。换言之，把stdin 流重新赋给文件。继续使用getchar() 函数从输入流中获取数据，但它并不关心从流的什么位置获取数据。虽然这种重定向的方法在某些方面有些限制，但是用起来比较简单，而且能让读者熟悉普通的文件处理技术。
重定向的一个主要问题是它与操作系统有关，与C无关。尽管如此，许多C环境中（包括UNIX、Linux和Windows命令提示模式）都有重定向特性，而且一些C实现还在某些缺乏重定向特性的系统中模拟它。苹果OS X运行在UNIX上，故可用Terminal应用程序来使用UNIX命令行模式。接下来我们介绍UNIX、Linux和Windows的重定向。
## UNIX、Linux和DOS重定向
UNIX（运行命令行模式时）、Linux（ditto）和Window命令行提示（模仿旧式DOS命令行环境）都能重定向输入、输出。重定向输入让程序使用文件而不是键盘来输入，重定向输出让程序输出至文件而不是屏幕。
### 重定向输入
文本文件 （text file ）是内含文本的文件，其中储存的数据是我们可识别的字符。文件的内容可以是一篇散文或者C程序。内含机器语言指令的文件（如储存可执行程序的文件）不是文本文件。
假设已经编译了echo_eof.c 程序，并把可执行版本放入一个名为echo_eof （或者在Windows系统中名为echo_eof.exe ）的文件中。运行该程序，输入可执行文件名：
```
echo_eof
```
该程序的运行情况和前面描述的一样，获取用户从键盘输入的输入。现在，假设你要用该程序处理名为words 的文本文件。
由于该程序的操作对象是字符，所以要使用文本文件。只需用下面的命令代替上面的命令即可：
```
echo_eof < words
```
< 符号是UNIX和DOS/Windows的重定向运算符。该运算符使 words 文件与stdin 流相关联，把文件中的内容导入echo_eof 程序。echo_eof 程序本身并不知道（或不关心）输入的内容是来自文件还是键盘，它只知道这是需要导入的字符流，所以它读取这些内容并把字符逐个打印在屏幕上，直至读到文件结尾。因为C把文件和I/O 设备放在一个层面，所以文件就是现在的I/O设备。
下面是一个特殊的words 文件的运行示例，$ 是UNIX和Linux的标准提示符。在Windows/DOS系统中见到的DOS提示可能是A> 或C> 。
```
$ echo_eof < words
The world is too much with us: late and soon,
Getting and spending, we lay waste our powers:
Little we see in Nature that is ours;
We have given our hearts away, a sordid boon!
$
```
### 重定向输出
现在假设要用echo_eof 把键盘输入的内容发送到名为mywords 的文件中。然后，输入以下命令并开始输入：
```
echo_eof>mywords
```
 符号是第2个重定向运算符。它创建了一个名为mywords 的新文件，然后把echo_eof 的输出（即，你输入字符的副本）重定向至该文件中。重定向把stdout 从显示设备（即，显示器）赋给 mywords 文件。如果已经有一个名为mywords 的文件，通常会擦除该文件的内容，然后替换新的内容（但是，许多操作系统有保护现有文件的选项，使其成为只读文件）。所有出现在屏幕的字母都是你刚才输入的，其副本储存在文件中。在下一行的开始处按下Ctrl+D （UNIX）或Ctrl+Z （DOS）即可结束该程序。如果不知道输入什么内容，可参照下面的示例。这里，我们使用UNIX提示符$ 。记住在每行的末尾单击Enter 键，这样才能把缓冲区的内容发送给程序。
```
$ echo_eof > mywords
You should have no problem recalling which redirection
operator does what. Just remember that each operator points
in the direction the information flows. Think of it as
a funnel.
[Ctrl+D]
$
```
按下Ctrl+D 或Ctrl+Z 后，程序会结束，你的系统会提示返回。程序是否起作用了？UNIX的ls 命令或Windows命令行提示模式的 dir 命令可以列出文件名，会显示mywords 文件已存在。可以使用 UNIX或Linux的cat 或DOS的type 命令检查文件中的内容，或者再次使用echo_eof ，这次把文件重定向到程序：
```
$ echo_eof < mywords
You should have no problem recalling which redirection
operator does what. Just remember that each operator points
in the direction the information flows. Think of it as a
funnel.
$
```
### 组合重定向
现在，假设你希望制作一份mywords 文件的副本，并命名为 savewords 。只需输入以下命令即可：
```
./echo_eof < mywords > savewords
```
下面的命令也起作用，因为命令与重定向运算符的顺序无关：
```
./echo_eof > savewords < mywords
```
注意：在一条命令中，输入文件名和输出文件名不能相同。
```
./echo_eof < mywords > mywords....<--错误
```
原因是> mywords 在输入之前已导致原mywords 的长度被截断为0 。
总之，在UNIX、Linux或Windows/DOS系统中使用两个重定向运算符（< 和> ）时，要遵循以下原则。
重定向运算符连接一个可执行程序（包括标准操作系统命令）和一个数据文件，不能用于连接一个数据文件和另一个数据文件， 也不能用于连接一个程序和另一个程序。
使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件。
通常，文件名和运算符之间的空格不是必须的，除非是偶尔在 UNIX shell、Linux shell或Windows命令行提示模式中使用的有特殊含义的字符。例如，我们用的`./echo_eof<words` 

以上介绍的都是正确的例子，下面来看一下错误的例子，addup 和count 是两个可执行程序，fish 和beets 是两个文本文件：
```
./fish > beets ←违反第1条规则
./addup < count ←违反第1条规则
./addup < fish < beets ←违反第2条规则
./count > beets fish ←违反第2条规则
```
UNIX、Linux或Windows/DOS还有>>运算符，该运算符可以把数据添加到现有文件的末尾，而 | 运算符能把一个文件的输出连接到另一个文件的输入。
### 注释
重定位让你能使用键盘输入程序文件。要完成这一任务，程序要测试文件的末尾。
重定向是一个命令行概念，因为我们要在命令行输入特殊的符号发出指令。
如果不使用命令行环境，也可以使用重定向。首先，一些集成开发环境提供了菜单选项，让用户指定重定向。其次，对于 Windows系统，可以打开命令提示窗口，并在命令行运行可执行文件。Microsoft Visual Studio的默认设置是把可执行文件放在项目文件夹的子文件夹，称为Debug。文件名和项目名的基本名相同，文件名的扩展名为.exe。默认情况下，Xcode在给项目命名后才能命名可执行文件，并将其放在Debug文件夹中。在UNIX系统中，可以通过 Terminal工具运行可执行文件。从使用上看，Terminal比命令行编译器 （GCC或Clang）简单。如果用不了重定向，可以用程序直接打开文件。
# 创建更友好的用户界面
## 使用缓冲输入
缓冲输入要求用户按下Enter 键发送输入。这一动作也传送了换行符，程序必须妥善处理这个麻烦的换行符。以一个猜谜程序为例。用户选择一个数字，程序猜用户选中的数字是多少。
```c
/* guess.c -- 一个拖沓且错误的猜数字程序 */
#include <stdio.h>
int main(void)
{
int guess = 1;
printf("Pick an integer from 1 to 100. I will try to guess ");
printf("it.\nRespond with a y if my guess is right and with");
printf("\nan n if it is wrong.\n");
printf("Uh...is your number %d?\n", guess);
while (getchar() != 'y') /* 获取响应，与 y 做对比 */
printf("Well, then, is it %d?\n", ++guess);
printf("I knew I could do it!\n");
return 0;
}
```
当用户输入n时，程序会读取读取n 作为用户否定了数字1 ，然后还读取了一个换行符作为用户否定了数字2 ，导致输出两个数字。
一种解决方案是，使用while 循环丢弃输入行最后剩余的内容， 包括换行符。这种方法的优点是，能把no 和no way 这样的响应视为简单的n 。
修改如下：
```c
/* guess.c -- 一个拖沓且错误的猜数字程序(修改) */
#include <stdio.h>
int main(void)
{
int guess = 1;
printf("Pick an integer from 1 to 100. I will try to guess ");
printf("it.\nRespond with a y if my guess is right and with");
printf("\nan n if it is wrong.\n");
printf("Uh...is your number %d?\n", guess);
while (getchar() != 'y') /* 获取响应，与 y 做对比*/ 
{ 
printf("Well, then, is it %d?\n", ++guess);
 while (getchar() != '\n') 
 continue; /* 跳过剩余的输入行 */ 
}
printf("I knew I could do it!\n");
return 0;
}
```

```c
 while (getchar() != '\n') 
 continue; /* 跳过剩余的输入行 */ 
```
这段循环的作用就是从缓冲区取出字符，直到取出\n循环停止，从而达到清空缓冲区的目的。
这的确是解决了换行符的问题。但是，该程序还是会把f 视为n 。我们用if 语句筛选其他响应。首先，添加一个char 类型的变量储存响应：
```c
char response;
```
修改后的如下：
```c
/* guess.c -- 一个拖沓且错误的猜数字程序(修改) */
#include <stdio.h>
int main(void)
{
int guess = 1;
printf("Pick an integer from 1 to 100. I will try to guess ");
printf("it.\nRespond with a y if my guess is right and with");
printf("\nan n if it is wrong.\n");
printf("Uh...is your number %d?\n", guess);
while (getchar() != 'y') /* 获取响应，与 y 做对比*/ 
{ 
if (response == 'n') 
printf("Well, then, is it %d?\n", ++guess); 
else 
printf("Sorry, I understand only y or n.\n");
 while (getchar() != '\n') 
 continue; /* 跳过剩余的输入行 */ 
}
printf("I knew I could do it!\n");
return 0;
}
```
在编写交互式程序时，应该事先预料到用户可能会输入错误，然后设计程序处理用户的错误输入。在用户出错时通知用户再次输入。
## 混合数值和字符输入
假设程序要求用getchar() 处理字符输入，用scanf() 处理数值输入，这两个函数都能很好地完成任务，但是不能把它们混用。因为getchar() 读取每个字符，包括空格、制表符和换行符；而 scanf() 在读取数字时则会跳过空格、制表符和换行符。
以下程序可以说明这种情况导致的问题：
```c
/* showchar1.c -- 有较大 I/O 问题的程序 */
#include <stdio.h>
void display(char cr, int lines, int width);
int main(void)
{
int ch; /* 待打印字符 */
int rows, cols; /* 行数和列数 */
printf("Enter a character and two integers:\n");
while ((ch = getchar()) != '\n')
{
scanf("%d %d", &rows, &cols);
display(ch, rows, cols);
printf("Enter another character and two integers;\n");
printf("Enter a newline to quit.\n");
}
printf("Bye.\n");
return 0;
}
void display(char cr, int lines, int width)
{
int row, col;
for (row = 1; row <= lines; row++)
{
for (col = 1; col <= width; col++)
putchar(cr);
putchar('\n'); /* 结束一行并开始新的一行 */
}
}
```
该程序开始时运行良好。你输入c 2 3 ，程序打印c 字符2行3 列。然后，程序提示输入第2组数据，还没等你输入数据程序就退出了！这次是输入行中紧跟在3后面的换行符。scanf() 函数把这个换行符留在输入队列中。和 scanf() 不同，getchar() 不会跳过换行符，所以在进入下一轮迭代时，你还没来得及输入字符，它就读取了换行符，然后将其赋给ch 。而ch 是换行符正式终止循环的条件。
要解决这个问题，程序要跳过一轮输入结束与下一轮输入开始之间的所有换行符或空格。另外，如果该程序不在getchar() 测试时，而在scanf() 阶段终止程序会更好。
修改如下：
```c
/* showchar2.c -- 按指定的行列打印字符 */
#include <stdio.h>
void display(char cr, int lines, int width);
int main(void)
{
int ch; /* 待打印字符*/
int rows, cols; /* 行数和列数 */
printf("Enter a character and two integers:\n");
while ((ch = getchar()) != '\n')
{
if (scanf("%d %d", &rows, &cols) != 2)
break;
display(ch, rows, cols);
while (getchar() != '\n')
continue;
printf("Enter another character and two integers;\n");
printf("Enter a newline to quit.\n");
}
printf("Bye.\n");
return 0;
}
void display(char cr, int lines, int width)
{
int row, col;
for (row = 1; row <= lines; row++)
{
for (col = 1; col <= width; col++)
putchar(cr);
putchar('\n'); /* 结束一行并开始新的一行 */
}
}
```

老方法，用while循环清除缓冲区。在if 语句中使用一个break 语句，可以在scanf() 的返回值不等于2 时终止程序，即如果一个或两个输入值不是整数或者遇到文件结尾就终止程序。
## 输入验证
在实际应用中，用户不一定会按照程序的指令行事。用户的输入和程序期望的输入不匹配时常发生，这会导致程序运行失败。作为程序员，除了完成编程的本职工作，还要事先预料一些可能的输入错误，这样才能编写出能检测并处理这些问题的程序。
例如，假设你编写了一个处理非负数整数的循环，但是用户很可能输入一个负数。你可以使用关系表达式来排除这种情况：
```c
long n;
scanf("%ld", &n); // 获取第1个值
while (n >= 0) // 检测不在范围内的值
{
// 处理n
scanf("%ld", &n); // 获取下一个值
}
```
另一类潜在的陷阱是，用户可能输入错误类型的值，如字符q 。排除这种情况的一种方法是，检查scanf() 的返回值。因此，下面的表达式当且仅当用户输入一个整数时才为真：
```
scanf("%ld", &n) == 1
```
结合上面的while 循环，可改进为：
```c
long n;
while (scanf("%ld", &n) == 1 && n >= 0)
{
// 处理n
}
```
while 循环条件可以描述为“当输入是一个整数且该整数为正时”。
对于最后的例子，当用户输入错误类型的值时，程序结束。然而，也可以让程序友好些，提示用户再次输入正确类型的值。在这种情况下，要处理有问题的输入。如果scanf() 没有成功读取，就会将其留在输入队列中。这里要明确，输入实际上是字符流。可以使用 getchar() 函数逐字符地读取输入，甚至可以把这些想法都结合在一个函数中，如下所示：
```c
long get_long(void)
{
long input;
char ch;
while (scanf("%ld", &input) != 1)
{
while ((ch = getchar()) != '\n')
putchar(ch); // 处理错误的输入
printf(" is not an integer.\nPlease enter an ");
printf("integer value, such as 25, -178, or 3: ");
}
return input;
}
```
该函数要把一个int 类型的值读入变量input 中。如果读取失败，函数则进入外层while 循环体。然后内层循环逐字符地读取错误的输入。注意，该函数丢弃该输入行的所有剩余内容。还有一个方法是，只丢弃下一个字符或单词，然后该函数提示用户再次输入。外层循环重复运行，直到用户成功输入整数，此时scanf() 的返回值为1

在用户输入整数后，程序可以检查该值是否有效。考虑一个例子，要求用户输入一个上限和一个下限来定义值的范围。在该例中， 你可能希望程序检查第1个值是否大于第2个值（通常假设第1个值是较小的那个值），除此之外还要检查这些值是否在允许的范围内。
假设程序中包含了stdbool.h 头文件。如果当前系统不允许使用_Bool ，把bool 替换成int ，把true 替换成1 ，把false 替换成0 即可。注意，如果输入无效，该函数返回true ，所以函数名为 bad_limits() ：
```c
bool bad_limits(long begin, long end,long low, long high)
{
bool not_good = false;
if (begin > end)
{
printf("%ld isn't smaller than %ld.\n", begin, end);
not_good = true;
}
if (begin < low || end < low)
{
printf("Values must be %ld or greater.\n", low);
not_good = true;
}
if (begin > high || end > high)
{
printf("Values must be %ld or less.\n", high);
not_good = true;
}
return not_good;
}
```
## 知识应用
以下程序使用了上面的两个函数为一个进行算术运算的函数提供整数，该函数计算特定范围内所有整数的平方和。程序限制了范围的上限是10000000 ，下限是-10000000 。
```c
// checking.c -- 输入验证
#include <stdio.h>
#include <stdbool.h>
// 验证输入是一个整数
long get_long(void);
// 验证范围的上下限是否有效
bool bad_limits(long begin, long end,
long low, long high);
// 计算a～b之间的整数平方和
double sum_squares(long a, long b);
int main(void)
{
const long MIN = -10000000L; // 范围的下限
const long MAX = +10000000L; // 范围的上限
long start; // 用户指定的范围最小值
long stop; // 用户指定的范围最大值
double answer;
printf("This program computes the sum of the squares of "
"integers in a range.\nThe lower bound should not "
"be less than -10000000 and\nthe upper bound "
"should not be more than +10000000.\nEnter the "
"limits (enter 0 for both limits to quit):\n"
"lower limit: ");
start = get_long();
printf("upper limit: ");
stop = get_long();
while (start != 0 || stop != 0)
{
if (bad_limits(start, stop, MIN, MAX))
printf("Please try again.\n");
else
{
answer = sum_squares(start, stop);
printf("The sum of the squares of the integers ");
printf("from %ld to %ld is %g\n",
start, stop, answer);
}
printf("Enter the limits (enter 0 for both "
"limits to quit):\n");
printf("lower limit: ");
start = get_long();
printf("upper limit: ");
stop = get_long();
}
printf("Done.\n");
return 0;
}
long get_long(void)
{
long input;
char ch;
while (scanf("%ld", &input) != 1)
{
while ((ch = getchar()) != '\n')
putchar(ch); // 处理错误输入
printf(" is not an integer.\nPlease enter an ");
printf("integer value, such as 25, -178, or 3: ");
}
return input;
}
double sum_squares(long a, long b)
{
double total = 0;
long i;
for (i = a; i <= b; i++)
total += (double) i * (double) i;
return total;
}
bool bad_limits(long begin, long end,
long low, long high)
{
bool not_good = false;
if (begin > end)
{
printf("%ld isn't smaller than %ld.\n", begin, end);
not_good = true;
}
if (begin < low || end < low)
{
printf("Values must be %ld or greater.\n", low);
not_good = true;
}
if (begin > high || end > high)
{
printf("Values must be %ld or less.\n", high);
not_good = true;
}
return not_good;
}
```
### 分析
程序遵循模块化的编程思想，使用独立函数（模块）来验证输入和管理显示。程序越大，使用模块化编程就越重要。main() 函数管理程序流，为其他函数委派任务。它使用 get_long() 获取值、while 循环处理值、badlimits() 函数检查值是否有效、sum_squres() 函数处理实际的计算：
```c
start = get_long();
printf("upper limit: ");
stop = get_long();
while (start != 0 || stop != 0)
{
if (bad_limits(start, stop, MIN, MAX))
printf("Please try again.\n");
else
{
answer = sum_squares(start, stop);
printf("The sum of the squares of the integers ");
printf("from %ld to %ld is %g\n", start, stop, answer);
}
printf("Enter the limits (enter 0 for both "
"limits to quit):\n");
printf("lower limit: ");
start = get_long();
printf("upper limit: ");
stop = get_long();
}
```

## 菜单浏览
许多计算机程序都把菜单作为用户界面的一部分。菜单给用户提供方便的同时，却给程序员带来了一些麻烦。我们看看其中涉及了哪些问题。菜单给用户提供了一份响应程序的选项。假设有下面一个例子：
```c
Enter the letter of your choice:
a. advice b. bell
c. count  q. quit
```
理想状态是，用户输入程序所列选项之一，然后程序根据用户所选项完成任务。作为一名程序员，自然希望这一过程能顺利进行。因此，第1个目标是：当用户遵循指令时程序顺利运行；第2个目标是： 当用户没有遵循指令时，程序也能顺利运行。显而易见，要实现第2 个目标难度较大，因为很难预料用户在使用程序时的所有错误情况。
现在的应用程序通常使用图形界面，可以点击按钮、查看对话框、触摸图标，而不是我们示例中的命令行模式。但是，两者的处理过程大致相同：给用户提供选项、检查并执行用户的响应、保护程序不受误操作的影响。除了界面不同，它们底层的程序结构也几乎相同。但是，使用图形界面更容易通过限制选项控制输入。
### 程序
任务分析：获取选项，当选项不是'q'时，转至相应的选项并执行获取下一个选项
代码：
```c
#include <stdio.h>
char get_choice(void);
void count(void);
int main(void)
{
int choice;
while ((choice = get_choice()) != 'q')
{
switch (choice)
{
case 'a': printf("Buy low, sell high.\n");
break;
case 'b': putchar('\a'); /* ANSI */
break;
case 'c': count();
break;
default: printf("Program error!\n");
break;
}
}
return 0;
}
```
定义get_choice() 函数只能返回'a' 、'b' 、'c' 和'q' 。 get_choice() 的用法和getchar() 相同，两个函数都是获取一个值，并与终止值（该例中是'q' ）作比较。
```c
char get_choice(void)
{
int ch;
printf("Enter the letter of your choice:\n");
printf("a. advice b. bell\n");
printf("c. count q. quit\n");
ch = getchar();
while ((ch < 'a' || ch > 'c') && ch != 'q')
{
printf("Please respond with a, b, c, or q.\n");
ch = getchar();
}
return ch;
}
```
缓冲输入依旧带来些麻烦，程序把用户每次按下Return 键产生的换行符视为错误响应。为了让程序的界面更流畅，该函数应该跳过这些换行符。
这类问题有多种解决方案。一种是用名为get_first() 的新函数替换getchar() 函数，读取一行的第1个字符并丢弃剩余的字符。
```c
char get_choice(void)
{
int ch;
printf("Enter the letter of your choice:\n");
printf("a. advice b. bell\n");
printf("c. count  q. quit\n");
ch = get_first();
while ((ch < 'a' || ch > 'c') && ch != 'q')
{
printf("Please respond with a, b, c, or q.\n");
ch = get_first();
}
return ch;
}
char get_first(void)
{
int ch;
ch = getchar(); /* 读取下一个字符 */
while (getchar() != '\n')
continue; /* 跳过该行剩下的内容 */
return ch;
}
```
混合字符和数值输入会产生一些问题，创建菜单也有这样的问题。例如，假设count() 函数（选择c ）的代码如下：
```c
void count(void)
{
int n, i;
printf("Count how far? Enter an integer:\n");
scanf("%d", &n);
for (i = 1; i <= n; i++)
printf("%d\n", i);
}
```
如果输入3 作为响应，scanf() 会读取3 并把换行符留在输入队列中。下次调用get_choice() 将导致get_first() 返回这个换行符，从而导致我们不希望出现的行为。
重写get_first() ，使其返回下一个非空白字符而不仅仅是下一个字符，即可修复这个问题。（利用循环，有空白字符就getchar（），非空白字符就break）
另一种方法是，在count() 函数中清理换行符，如下所示：
```c
void count(void)
{
int n, i;
printf("Count how far? Enter an integer:\n");
n = get_int();
for (i = 1; i <= n; i++)
printf("%d\n", i);
while (getchar() != '\n')
continue;
}
```
结合以上讨论，可得出最终程序。
```c
/* menuette.c -- 菜单程序 */
#include <stdio.h>
char get_choice(void);
char get_first(void);
int get_int(void);
void count(void);
int main(void)
{
int choice;
void count(void);
while ((choice = get_choice()) != 'q')
{
switch (choice)
{
case 'a': printf("Buy low, sell high.\n");
break;
case 'b': putchar('\a'); /* ANSI */
break;
case 'c': count();
break;
default: printf("Program error!\n");
break;
}
}
printf("Bye.\n");
return 0;
}
void count(void)
{
int n, i;
printf("Count how far? Enter an integer:\n");
n = get_int();
for (i = 1; i <= n; i++)
printf("%d\n", i);
while (getchar() != '\n')
continue;
}
char get_choice(void)
{
int ch;
printf("Enter the letter of your choice:\n");
printf("a. advice b. bell\n");
printf("c. count q. quit\n");
ch = get_first();
while ((ch < 'a' || ch > 'c') && ch != 'q')
{
printf("Please respond with a, b, c, or q.\n");
ch = get_first();
}
return ch;
}
char get_first(void)
{
int ch;
ch = getchar();
while (getchar() != '\n')
continue;
return ch;
}
int get_int(void)
{
int input;
char ch;
while (scanf("%d", &input) != 1)
{
while ((ch = getchar()) != '\n')
putchar(ch); // 处理错误输出
printf(" is not an integer.\nPlease enter an ");
printf("integer value, such as 25, -178, or 3: ");
}
return input;
}
```
