设计程序时，最重要的步骤之一是选择表示数据的方法。在许多情况下，简单变量甚至是数组还不够。为此，C提供了结构变量（structure variable）提高你表示数据的能力，它能让你创造新的形式。如果熟悉Pascal的记录（record），应该很容易理解结构。如果不懂Pascal也没关系，本章将详细介绍C结构。我们先通过一个示例来分析为何需要C结构，学习如何创建和使用结构。

## 14.1　示例问题：创建图书目录

Gwen Glenn要打印一份图书目录。她想打印每本书的各种信息：书名、作者、出版社、版权日期、页数、册数和价格。其中的一些项目（如，书名)可以储存在字符数组中，其他项目需要一个int数组或float数组。用7个不同的数组分别记录每一项比较繁琐，尤其是Gwen还想创建多份列表：一份按书名排序、一份按作者排序、一份按价格排序等。如果能把图书目录的信息都包含在一个数组里更好，其中每个元素包含一本书的相关信息。

因此，Gwen需要一种即能包含字符串又能包含数字的数据形式，而且还要保持各信息的独立。C结构就满足这种情况下的需求。我们通过一个示例演示如何创建和使用数组。但是，示例进行了一些限制。第一，该程序示例演示的书目只包含书名、作者和价格。第二，只有一本书的数目。当然，别忘了这只是进行了限制，我们在后面将扩展该程序。请看程序清单14.1及其输出，然后阅读后面的一些要点。

程序清单14.1　book.c 程序

这个程序定义了一个book结构，包含书名、作者和价格三个成员，并使用s_gets函数安全读取字符串输入：

text

```
/* book.c -- 一本书的图书目录 */
#include <stdio.h>
#include <string.h>
char * s_gets(char * st, int n);
#define MAXTITL 41 /* 书名的最大长度 + 1 */
#define MAXAUTL 31 /* 作者姓名的最大长度 + 1 */
struct book { /* 结构模版：标记是 book */
char title[MAXTITL];
char author[MAXAUTL];
float value;
}; /* 结构模版结束 */
int main(void)
{
struct book library; /* 把 library 声明为一个 book 类型的变量
*/
printf("Please enter the book title.\n");
s_gets(library.title, MAXTITL); /* 访问title部分*/
printf("Now enter the author.\n");
s_gets(library.author, MAXAUTL);
printf("Now enter the value.\n");
scanf("%f", &library.value);
printf("%s by %s: $%.2f\n", library.title,
library.author, library.value);
printf("%s: \"%s\" ($%.2f)\n", library.author,
library.title, library.value);
printf("Done.\n");
return 0;
}
char * s_gets(char * st, int n)
{
char * ret_val;
char * find;
ret_val = fgets(st, n, stdin);
if (ret_val)
{
find = strchr(st, '\n'); // 查找换行符
if (find) // 如果地址不是 NULL,
*find = '\0'; // 在此处放置一个空字符
else
while (getchar() != '\n')
continue; //处理输入行中剩余的字符
}
return ret_val;
}
```

我们使用前面章节中介绍的`s_gets()`函数去掉`fgets()`储存在字符串中的换行符。下面是该例的一个运行示例：

text

```
Please enter the book title.
Chicken of the Andes
Now enter the author.
Disma Lapoult
Now enter the value.
29.99
Chicken of the Andes by Disma Lapoult: $29.99
Disma Lapoult: "Chicken of the Andes" ($29.99)
Done.
```

程序清单14.1中创建的结构有3部分，每个部分都称为成员（member）或字段（field）。这3部分中，一部分储存书名，一部分储存作者名，一部分储存价格。下面是必须掌握的3个技巧：  
为结构建立一个格式或样式；  
声明一个适合该样式的变量；  
访问结构变量的各个部分。

## 14.2　建立结构声明

结构声明（structure declaration）描述了一个结构的组织布局。声明类似下面这样：

text

```
struct book {
char title[MAXTITL];
char author[MAXAUTL];
float value;
};
```

该声明描述了一个由两个字符数组和一个float类型变量组成的结构。该声明并未创建实际的数据对象，只描述了该对象由什么组成。〔有时，我们把结构声明称为模板，因为它勾勒出结构是如何储存数据的。如果读者知道C++的模板，此模板非彼模板，C++中的模板更为强大。〕我们来分析一些细节。首先是关键字`struct`，它表明跟在其后的是一个结构，后面是一个可选的标记（该例中是`book`），稍后程序中可以使用该标记引用该结构。所以，我们在后面的程序中可以这样声明：

`struct book library;`

这把`library`声明为一个使用`book`结构布局的结构变量。

在结构声明中，用一对花括号括起来的是结构成员列表。每个成员都用自己的声明来描述。例如，`title`部分是一个内含`MAXTITL`个元素的`char`类型数组。成员可以是任意一种C的数据类型，甚至可以是其他结构！右花括号后面的分号是声明所必需的，表示结构布局定义结束。可以把这个声明放在所有函数的外部（如本例所示），也可以放在一个函数定义的内部。如果把结构声明置于一个函数的内部，它的标记就只限于该函数内部使用。如果把结构声明置于函数的外部，那么该声明之后的所有函数都能使用它的标记。例如，在程序的另一个函数中，可以这样声明：

`struct book dickens;`

这样，该函数便创建了一个结构变量`dickens`，该变量的结构布局是`book`。

结构的标记名是可选的。但是以程序示例中的方式建立结构时（在一处定义结构布局，在另一处定义实际的结构变量），必须使用标记。我们学完如何定义结构变量后，再来看这一点。

## 14.3　定义结构变量

结构有两层含义。一层含义是"结构布局"，刚才已经讨论过了。结构布局告诉编译器如何表示数据，但是它并未让编译器为数据分配空间。下一步是创建一个结构变量，即是结构的另一层含义。程序中创建结构变量的一行是:

`struct book library;`

编译器执行这行代码便创建了一个结构变量`library`。编译器使用`book`模板为该变量分配空间：一个内含`MAXTITL`个元素的`char`数组、一个内含`MAXAUTL`个元素的`char`数组和一个`float`类型的变量。这些存储空间都与一个名称`library`结合在一起（见图14.1）。

图14.1　一个结构的内存分配

在结构变量的声明中，`struct book`所起的作用相当于一般声明中的`int`或`float`。例如，可以定义两个`struct book`类型的变量，或者甚至是指向`struct book`类型结构的指针：

`struct book doyle, panshin, * ptbook;`

结构变量`doyle`和`panshin`中都包含`title`、`author`和`value`部分。指针`ptbook`可以指向`doyle`、`panshin`或任何其他`book`类型的结构变量。从本质上看，`book`结构声明创建了一个名为`struct book`的新类型。

就计算机而言，下面的声明：

`struct book library;`

是以下声明的简化：

text

```
struct book {
char title[MAXTITL];
char author[AXAUTL];
float value;
} library; /* 声明的右右花括号后跟变量名*/
```

换言之，声明结构的过程和定义结构变量的过程可以组合成一个步骤。如下所示，组合后的结构声明和结构变量定义不需要使用结构标记：

text

```
struct { /* 无结构标记 */
char title[MAXTITL];
char author[MAXAUTL];
float value;
} library;
```

然而，如果打算多次使用结构模板，就要使用带标记的形式；或者，使用本章后面介绍的`typedef`。

这是定义结构变量的一个方面，在这个例子中，并未初始化结构变量。

### 14.3.1　初始化结构

初始化变量和数组如下：

`int count = 0;`  
`int fibo[7] = {0,1,1,2,3,5,8};`

结构变量是否也可以这样初始化？是的，可以。初始化一个结构变量（ANSI之前，不能用自动变量初始化结构；ANSI之后可以用任意存储类别）与初始化数组的语法类似：

text

```
struct book library = {
"The Pious Pirate and the Devious Damsel",
"Renee Vivotte",
1.95
};
```

简而言之，我们使用在一对花括号中括起来的初始化列表进行初始化，各初始化项用逗号分隔。因此，`title`成员可以被初始化为一个字符串，`value`成员可以被初始化为一个数字。为了让初始化项与结构中各成员的关联更加明显，我们让每个成员的初始化项独占一行。这样做只是为了提高代码的可读性，对编译器而言，只需要用逗号分隔各成员的初始化项即可。

注意  
初始化结构和类别储存期  
第12章中提到过，如果初始化静态存储期的变量（如，静态外部链接、静态内部链接或静态无链接），必须使用常量值。这同样适用于结构。如果初始化一个静态存储期的结构，初始化列表中的值必须是常量表达式。如果是自动存储期，初始化列表中的值可以不是常量。

### 14.3.2　访问结构成员

结构类似于一个"超级数组"，这个超级数组中，可以是一个元素为`char`类型，下一个元素为`float`类型，下一个元素为`int`数组。可以通过数组下标单独访问数组中的各元素，那么，如何访问结构中的成员？使用结构成员运算符——点（`.`）访问结构中的成员。例如，`library.value`即访问`library`的`value`部分。可以像使用任何`float`类型变量那样使用`library.value`。与此类似，可以像使用字符数组那样使用`library.title`。因此，程序清单14.1中的程序中有`s_gets(library.title, MAXTITL);`和`scanf("%f", &library.value);`这样的代码。

本质上，`.title`、`.author`和`.value`的作用相当于`book`结构的下标。

注意，虽然`library`是一个结构，但是`library.value`是一个`float`类型的变量，可以像使用其他`float`类型变量那样使用它。例如，`scanf("%f",...)`需要一个`float`类型变量的地址，而`&library.value`正好符合要求。`.`比`&`的优先级高，因此这个表达式和`&(library.value)`一样。

如果还有一个相同类型的结构变量，可以用相同的方法：

`struct book bill, newt;`  
`s_gets(bill.title, MAXTITL);`  
`s_gets(newt.title, MAXTITL);`

`.title`引用`book`结构的第1个成员。注意，程序清单14.1中的程序以两种不同的格式打印了`library`结构变量中的内容。这说明可以自行决定如何使用结构成员。

### 14.3.3　结构的初始化器

C99和C11为结构提供了指定初始化器（designated initializer）[1]，其语法与数组的指定初始化器类似。但是，结构的指定初始化器使用点运算符和成员名（而不是方括号和下标）标识特定的元素。例如，只初始化`book`结构的`value`成员，可以这样做：

`struct book surprise = { .value = 10.99};`

可以按照任意顺序使用指定初始化器：

text

```
struct book gift = { .value = 25.99,
.author = "James Broadfool",
.title = "Rue for the Toad"};
```

与数组类似，在指定初始化器后面的普通初始化器，为指定成员后面的成员提供初始值。另外，对特定成员的最后一次赋值才是它实际获得的值。例如，考虑下面的代码：

结构和内存

text

```
struct book gift= {.value = 18.90,
.author = "Philionna Pestle",
0.25};
```

赋给`value`的值是`0.25`，因为它在结构声明中紧跟在`author`成员之后。新值`0.25`取代了之前的`18.9`。在学习了结构的基本知识后，可以进一步了解结构的一些相关类型。

## 14.4　结构数组

接下来，我们要把程序清单14.1的程序扩展成可以处理多本书。显然，每本书的基本信息都可以用一个`book`类型的结构变量来表示。为描述两本书，需要使用两个变量，以此类推。可以使用这一类型的结构数组来处理多本书。在下一个程序中（程序清单14.2）就创建了一个这样的数组。如果你使用Borland C/C++，请参阅本节后面的"Borland C和浮点数"。

manybook.c程序创建了一个内含100个结构变量的数组。由于该数组是自动存储类别的对象，其中的信息被储存在栈（stack）中。如此大的数组需要很大一块内存，这可能会导致一些问题。如果在运行时出现错误，可能抱怨栈大小或栈溢出，你的编译器可能使用了一个默认大小的栈，这个栈对于该例而言太小。要修正这个问题，可以使用编译器选项设置栈大小为10000，以容纳这个结构数组；或者可以创建静态或外部数组（这样，编译器就不会把数组放在栈中）；或者可以减小数组大小为16。为何不一开始就使用较小的数组？这是为了让读者意识到栈大小的潜在问题，以便今后再遇到类似的问题，可以自己处理好。

程序清单14.2　manybook.c 程序

这个程序创建了一个结构数组library，用循环读取多本书的信息，并在最后遍历输出所有图书信息：

text

```
/* manybook.c -- 包含多本书的图书目录 */
#include <stdio.h>
#include <string.h>
char * s_gets(char * st, int n);
#define MAXTITL 40
#define MAXAUTL 40
#define MAXBKS 100 /* 书籍的最大数量 */
struct book { /* 建立 book 模板 */
char title[MAXTITL];
char author[MAXAUTL];
float value;
};
int main(void)
{
struct book library[MAXBKS]; /* book 类型结构的数组 */
int count = 0;
int index;
printf("Please enter the book title.\n");
printf("Press [enter] at the start of a line to stop.\n");
while (count < MAXBKS && s_gets(library[count].title, MAXTITL)
!= NULL
&& library[count].title[0] != '\0')
{
printf("Now enter the author.\n");
s_gets(library[count].author, MAXAUTL);
printf("Now enter the value.\n");
scanf("%f", &library[count++].value);
while (getchar() != '\n')
continue; /* 清理输入行*/
if (count < MAXBKS)
printf("Enter the next title.\n");
}
if (count > 0)
{
printf("Here is the list of your books:\n");
for (index = 0; index < count; index++)
printf("%s by %s: $%.2f\n", library[index].title,
library[index].author, library[index].value);
}
else
printf("No books? Too bad.\n");
return 0;
}
char * s_gets(char * st, int n)
{
char * ret_val;
char * find;
ret_val = fgets(st, n, stdin);
if (ret_val)
{
find = strchr(st, '\n'); // 查找换行符
if (find) // 如果地址不是 NULL，
*find = '\0'; // 在此处放置一个空字符
else
while (getchar() != '\n')
continue; // 处理输入行中剩余的字符
}
return ret_val;
}
```

下面是该程序的一个输出示例：

text

```
Please enter the book title.
Press [enter] at the start of a line to stop.
My Life as a Budgie
Now enter the author.
Mack Zackles
Now enter the value.
12.95
Enter the next title.
...
Here is the list of your books:
My Life as a Budgie by Mack Zackles: $12.95
Thought and Unthought Rethought by Kindra Schlagmeyer: $43.50
Concerto for Financial Instruments by Filmore Walletz: $49.99
The CEO Power Diet by Buster Downsize: $19.25
C++ Primer Plus by Stephen Prata: $59.99
Fact Avoidance: Perception as Reality by Polly Bull: $19.97
Coping with Coping by Dr. Rubin Thonkwacker: $0.02
Diaphanous Frivolity by Neda McFey: $29.99
Murder Wore a Bikini by Mickey Splats: $18.95
A History of Buvania, Volume 8, by Prince Nikoli Buvan: $50.04
Mastering Your Digital Watch, 5nd Edition, by Miklos Mysz: $28.95
A Foregone Confusion by Phalty Reasoner: $5.99
Outsourcing Government: Selection vs. Election by Ima Pundit:
$33.33
```

Borland C和浮点数

如果程序不使用浮点数，旧式的Borland C编译器会尝试使用小版本的`scanf()`来压缩程序。然而，如果在一个结构数组中只有一个浮点值（如程序清单14.2中那样），那么这种编译器（DOS的Borland C/C++ 3.1之前的版本，不是Borland C/C++ 4.0）就无法发现它存在。结果，编译器会生成如下消息：

text

```
scanf : floating point formats not linked
Abnormal program termination
```

一种解决方案是，在程序中添加下面的代码：

text

```
#include <math.h>
double dummy = sin(0.0);
```

这段代码强制编译器载入浮点版本的`scanf()`。

首先，我们学习如何声明结构数组和如何访问数组中的结构成员。然后，着重分析该程序的两个方面
## 14.4.1　声明结构数组

声明结构数组和声明其他类型的数组类似。下面是一个声明结构数组的例子：

C

```
struct book library[MAXBKS];
```

以上代码把`library`声明为一个内含`MAXBKS`个元素的数组。数组的每个元素都是一个`book`类型的结构变量。因此，`library[0]`是第1个`book`类型的结构变量，`library[1]`是第2个`book`类型的结构变量，以此类推。参看图14.2可以帮助读者理解。数组名`library`本身不是结构名，它是一个数组名，该数组中的每个元素都是`struct book`类型的结构变量。

## 14.4.2　标识结构数组的成员

为了标识结构数组中的成员，可以采用访问单独结构的规则：在结构名后面加一个点运算符，再在点运算符后面写上成员名。如下所示：

C

```
library[0].value /* 第1个数组元素与value 相关联 */
library[4].title /* 第5个数组元素与title 相关联 */
```

注意，数组下标紧跟在`library`后面，不是成员名后面：

C

```
library.value[2] // 错误
library[2].value // 正确
```

使用`library[2].value`的原因是：`library[2]`是结构变量名，正如`library[1]`是另一个变量名。

顺带一提，下面的表达式代表什么？

C

```
library[2].title[4]
```

这是`library`数组第3个结构变量（`library[2]`部分）中书名的第5个字符（`title[4]`部分）。以程序清单14.2的输出为例，这个字符是`e`。该例指出，点运算符右侧的下标作用于各个成员，点运算符左侧的下标作用于结构数组。

最后，总结一下：

- `library` // 一个`book`结构的数组
- `library[2]` // 一个数组元素，该元素是`book`结构
- `library[2].title` // 一个`char`数组（`library[2]`的`title`成员）
- `library[2].title[4]` // 数组中`library[2]`元素的`title`成员的一个字符

## 14.4.3　程序讨论

较之程序清单14.1，该程序主要的改动之处是：插入一个`while`循环读取多个项。该循环的条件测试是：

C

```
while (count < MAXBKS && s_gets(library[count].title, MAXTITL) != NULL
&& library[count].title[0] != '\0')
```

表达式`s_gets(library[count].title, MAXTITL)`读取一个字符串作为书名，如果`s_gets()`尝试读到文件结尾后面，该表达式则返回`NULL`。表达式`library[count].title[0] != '\0'`判断字符串中的首字符是否是空字符（即，该字符串是否是空字符串）。如果在一行开始处用户按下Enter键，相当于输入了一个空字符串，循环将结束。程序中还检查了图书的数量，以免超出数组的大小。

然后，该程序中有如下几行：

C

```
while (getchar() != '\n')
continue; /* 清理输入行 */
```

前面章节介绍过，这段代码弥补了`scanf()`函数遇到空格和换行符就结束读取的问题。当用户输入书的价格时，可能输入如下信息：

text

```
12.50[Enter]
```

其传送的字符序列如下：

text

```
12.50\n
```

`scanf()`函数接受`1`、`2`、`.`、`5`和`0`，但是把`\n`留在输入序列中。如果没有上面两行清理输入行的代码，就会把留在输入序列中的换行符当作空行读入，程序以为用户发送了停止输入的信号。我们插入的这两行代码只会在输入序列中查找并删除`\n`，不会处理其他字符。这样`s_gets()`就可以重新开始下一次输入。

## 14.5　嵌套结构

有时，在一个结构中包含另一个结构（即嵌套结构）很方便。例如，Shalala Pirosky创建了一个有关她朋友信息的结构。显然，结构中需要一个成员表示朋友的姓名。然而，名字可以用一个数组来表示，其中包含名和姓这两个成员。程序清单14.3是一个简单的示例。

程序清单14.3　friend.c 程序

C

```
// friend.c -- 嵌套结构示例
#include <stdio.h>
#define LEN 20
const char * msgs[5] =
{
" Thank you for the wonderful evening, ",
"You certainly prove that a ",
"is a special kind of guy. We must get together",
"over a delicious ",
" and have a few laughs"
};
struct names { // 第1个结构
char first[LEN];
char last[LEN];
};
struct guy { // 第2个结构
struct names handle; // 嵌套结构
char favfood[LEN];
char job[LEN];
float income;
};
int main(void)
{
struct guy fellow = { // 初始化一个结构变量
{ "Ewen", "Villard" },
"grilled salmon",
"personality coach",
68112.00
};
printf("Dear %s, \n\n", fellow.handle.first);
printf("%s%s.\n", msgs[0], fellow.handle.first);
printf("%s%s\n", msgs[1], fellow.job);
printf("%s\n", msgs[2]);
printf("%s%s%s", msgs[3], fellow.favfood, msgs[4]);
if (fellow.income > 150000.0)
puts("!!");
else if (fellow.income > 750000.0)
puts("!");
else
puts(".");
printf("\n%40s%s\n", " ", "See you soon,");
printf("%40s%s\n", " ", "Shalala");
return 0;
}
```

下面是该程序的输出：

text

```
Dear Ewen,

Thank you for the wonderful evening, Ewen.
You certainly prove that a personality coach
is a special kind of guy. We must get together
over a delicious grilled salmon and have a few laughs.
.
See you soon,
Shalala
```

首先，注意如何在结构声明中创建嵌套结构。和声明`int`类型变量一样，进行简单的声明：

C

```
struct names handle;
```

该声明表明`handle`是一个`struct names`类型的变量。当然，文件中也应包含结构`names`的声明。

其次，注意如何访问嵌套结构的成员，这需要使用两次点运算符：

C

```
printf("Hello, %s!\n", fellow.handle.first);
```

从左往右解释`fellow.handle.first`：  
`(fellow.handle).first`

也就是说，找到`fellow`，然后找到`fellow`的`handle`的成员，再找到`handle`的`first`成员。

## 14.6　指向结构的指针

喜欢使用指针的人一定很高兴能使用指向结构的指针。至少有4个理由可以解释为何要使用指向结构的指针。第一，就像指向数组的指针比数组本身更容易操控（如，排序问题）一样，指向结构的指针通常比结构本身更容易操控。第二，在一些早期的C实现中，结构不能作为参数传递给函数，但是可以传递指向结构的指针。第三，即使能传递一个结构，传递指针通常更有效率。第四，一些用于表示数据的结构中包含指向其他结构的指针。

下面的程序（程序清单14.4）演示了如何定义指向结构的指针和如何用这样的指针访问结构的成员。

程序清单14.4　friends.c 程序

C

```
/* friends.c -- 使用指向结构的指针 */
#include <stdio.h>
#define LEN 20
struct names {
char first[LEN];
char last[LEN];
};
struct guy {
struct names handle;
char favfood[LEN];
char job[LEN];
float income;
};
int main(void)
{
struct guy fellow[2] = {
{ { "Ewen", "Villard" },
"grilled salmon",
"personality coach",
68112.00
},
{ { "Rodney", "Swillbelly" },
"tripe",
"tabloid editor",
432400.00
}
};
struct guy * him; /* 这是一个指向结构的指针 */
printf("address #1: %p #2: %p\n", &fellow[0], &fellow[1]);
him = &fellow[0]; /* 告诉编译器该指针指向何处 */
printf("pointer #1: %p #2: %p\n", him, him + 1);
printf("him->income is $%.2f: (*him).income is $%.2f\n",
him->income, (*him).income);
him++; /* 指向下一个结构 */
printf("him->favfood is %s: him->handle.last is %s\n",
him->favfood, him->handle.last);
return 0;
}
```

该程序的输出如下：

text

```
address #1: 0x7fff5fbff820 #2: 0x7fff5fbff874
pointer #1: 0x7fff5fbff820 #2: 0x7fff5fbff874
him->income is $68112.00: (*him).income is $68112.00
him->favfood is tripe: him->handle.last is Swillbelly
```

我们先来看如何创建指向`guy`类型结构的指针，然后再分析如何通过该指针指定结构的成员。
## 14.6.1　声明和初始化结构指针

声明结构指针很简单：

C

```
struct guy * him;
```

首先是关键字`struct`，其次是结构标记`guy`，然后是一个星号（`*`），其后跟着指针名。这个语法和其他指针声明一样。

该声明并未创建一个新的结构，但是指针`him`现在可以指向任意现有的`guy`类型的结构。例如，如果`barney`是一个`guy`类型的结构变量，可以这样写：

C

```
him = &barney;
```

和数组不同的是，结构变量名并不是结构的地址，因此要在结构变量名前面加上`&`运算符。

在本例中，`fellow`是一个结构数组，这意味着`fellow[0]`是一个结构。所以，要让`him`指向`fellow[0]`，可以这样写：

C

```
him = &fellow[0];
```

输出的前两行说明赋值成功。比较这两行发现，`him`指向`fellow[0]`，`him + 1`指向`fellow[1]`。注意，`him`加1相当于`him`指向的地址加84。在十六进制中，`874 - 820 = 54`（十六进制）`= 84`（十进制），因为每个`guy`结构都占用84字节的内存：

- `names.first`占用20字节
- `names.last`占用20字节
- `favfood`占用20字节
- `job`占用20字节
- `income`占用4字节（假设系统中`float`占用4字节）

顺带一提，在有些系统中，一个结构的大小可能大于它各成员大小之和。这是因为系统对数据进行校准的过程中产生了一些“缝隙”。例如，有些系统必须把每个成员都放在偶数地址上，或4的倍数的地址上。在这种系统中，结构的内部就存在未使用的“缝隙”。

## 14.6.2　用指针访问成员

指针`him`指向结构变量`fellow[0]`，如何通过`him`获得`fellow[0]`的成员的值？程序清单14.4中的第3行输出演示了两种方法。

第1种方法也是最常用的方法：使用`->`运算符。该运算符由一个连接号（`-`）后跟一个大于号（`>`）组成。我们有下面的关系：

- 如果`him == &barney`，那么`him->income`即是`barney.income`
- 如果`him == &fellow[0]`，那么`him->income`即是`fellow[0].income`

换句话说，指向结构的指针后面的`->`运算符和结构变量名后面的`.`运算符工作方式相同（不能写成`him.income`，因为`him`不是结构名）。

这里要着重理解`him`是一个指针，但是`him->income`是该指针所指向结构的一个成员。所以在该例中，`him->income`是一个`float`类型的变量。

第2种方法是，以这样的顺序指定结构成员的值：如果`him == &fellow[0]`，那么`*him == fellow[0]`，因为`&`和`*`是一对互逆运算符。因此，可以做以下替代：

C

```
fellow[0].income == (*him).income
```

必须要使用圆括号，因为`.`运算符比`*`运算符的优先级高。

总之，如果`him`是指向`guy`类型结构`barney`的指针，下面的关系恒成立：

C

```
barney.income == (*him).income == him->income // 假设 him == &barney
```

## 14.7　向函数传递结构的信息

函数的参数把值传递给函数。每个值都是一个数字——可能是`int`类型、`float`类型，可能是ASCII字符码，或者是一个地址。然而，一个结构比一个单独的值复杂，所以难怪以前的C实现不允许把结构作为参数传递给函数。当前的实现已经移除了这个限制，ANSI C允许把结构作为参数使用。所以程序员可以选择是传递结构本身，还是传递指向结构的指针。如果你只关心结构中的某一部分，也可以把结构的成员作为参数。我们接下来将分析这3种传递方式，首先介绍以结构成员作为参数的情况。

## 14.7.1　传递结构成员

只要结构成员是一个具有单个值的数据类型（即，`int`及其相关类型、`char`、`float`、`double`或指针），便可把它作为参数传递给接受该特定类型的函数。程序清单14.5中的财务分析程序（初级版本）演示了这一点，该程序把客户的银行账户添加到他/她的储蓄和贷款账户中。

程序清单14.5　funds1.c 程序

C

```
/* funds1.c -- 把结构成员作为参数传递 */
#include <stdio.h>
#define FUNDLEN 50
struct funds {
char bank[FUNDLEN];
double bankfund;
char save[FUNDLEN];
double savefund;
};
double sum(double, double);
int main(void)
{
struct funds stan = {
"Garlic-Melon Bank",
4032.27,
"Lucky's Savings and Loan",
8543.94
};
printf("Stan has a total of $%.2f.\n",
sum(stan.bankfund, stan.savefund));
return 0;
}
/* 两个double类型的数相加 */
double sum(double x, double y)
{
return(x + y);
}
```

运行该程序后输出如下：

text

```
Stan has a total of $12576.21.
```

看来，这样传递参数没问题。注意，`sum()`函数既不知道也不关心实际的参数是否是结构的成员，它只要求传入的数据是`double`类型。

当然，如果需要在被调函数中修改主调函数中成员的值，就要传递成员的地址：

C

```
modify(&stan.bankfund);
```

这是一个更改银行账户的函数。

## 14.7.2　传递结构的地址

我们继续解决前面的问题，但是这次把结构的地址作为参数。由于函数要处理`funds`结构，所以必须声明`funds`结构。如程序清单14.6所示。

程序清单14.6　funds2.c 程序

C

```
/* funds2.c -- 传递指向结构的指针 */
#include <stdio.h>
#define FUNDLEN 50
struct funds {
char bank[FUNDLEN];
double bankfund;
char save[FUNDLEN];
double savefund;
};
double sum(const struct funds *); /* 参数是一个指针 */
int main(void)
{
struct funds stan = {
"Garlic-Melon Bank",
4032.27,
"Lucky's Savings and Loan",
8543.94
};
printf("Stan has a total of $%.2f.\n", sum(&stan));
return 0;
}
double sum(const struct funds * money)
{
return(money->bankfund + money->savefund);
}
```

运行该程序后输出如下：

text

```
Stan has a total of $12576.21.
```

`sum()`函数使用指向`funds`结构的指针（`money`）作为它的参数。把地址`&stan`传递给该函数，使得指针`money`指向结构变量`stan`。然后通过`->`运算符获取`stan.bankfund`和`stan.savefund`的值。由于该函数不能改变指针所指向值的内容，所以把`money`声明为一个指向`const`的指针。

## 14.7.3　传递结构

对于允许把结构作为参数的编译器，可以把程序清单14.6重写为程序清单14.7。

程序清单14.7　funds3.c 程序

C

```
/* funds3.c -- 传递一个结构 */
#include <stdio.h>
#define FUNDLEN 50
struct funds {
char bank[FUNDLEN];
double bankfund;
char save[FUNDLEN];
double savefund;
};
double sum(struct funds moolah); /* 参数是一个结构 */
int main(void)
{
struct funds stan = {
"Garlic-Melon Bank",
4032.27,
"Lucky's Savings and Loan",
8543.94
};
printf("Stan has a total of $%.2f.\n", sum(stan));
return 0;
}
double sum(struct funds moolah)
{
return(moolah.bankfund + moolah.savefund);
}
```

该程序把程序清单14.6中指向`struct funds`类型的结构指针`money`替换成`struct funds`类型的结构变量`moolah`。调用`sum()`时，编译器根据`funds`模板创建了一个名为`moolah`的自动结构变量。然后，该结构的各成员被初始化为`stan`结构变量相应成员的值的副本。因此，程序使用原来结构的副本进行计算，然而，传递指针的程序清单14.6使用的是原始的结构进行计算。由于`moolah`是一个结构，所以该程序使用`moolah.bankfund`，而不是`moolah->bankfund`。

## 14.7.4　其他结构特性

现在的C允许把一个结构赋值给另一个结构，但是数组不能这样做。也就是说，如果`n_data`和`o_data`都是相同类型的结构，可以这样做：

C

```
o_data = n_data; // 把一个结构赋值给另一个结构
```

这条语句把`n_data`的每个成员的值都赋给`o_data`的相应成员。即使成员是数组，也能完成赋值。另外，还可以把一个结构初始化为相同类型的另一个结构：

C

```
struct names right_field = {"Ruthie", "George"};
struct names captain = right_field; // 把一个结构初始化为另一个结构
```

现在的C（包括ANSI C），函数不仅能把结构本身作为参数传递，还能把结构作为返回值返回。把结构作为函数参数可以把结构的信息传送给函数；把结构作为返回值的函数能把结构的信息从被调函数传回主调函数。结构指针也允许这种双向通信，因此可以选择任意一种方法来解决编程问题。

程序清单14.8　names1.c 程序

C

```
/* names1.c -- 使用指向结构的指针 */
#include <stdio.h>
#include <string.h>
#define NLEN 30
struct namect {
char fname[NLEN];
char lname[NLEN];
int letters;
};
void getinfo(struct namect *);
void makeinfo(struct namect *);
void showinfo(const struct namect *);
char * s_gets(char * st, int n);
int main(void)
{
struct namect person;
getinfo(&person);
makeinfo(&person);
showinfo(&person);
return 0;
}
void getinfo(struct namect * pst)
{
printf("Please enter your first name.\n");
s_gets(pst->fname, NLEN);
printf("Please enter your last name.\n");
s_gets(pst->lname, NLEN);
}
void makeinfo(struct namect * pst)
{
pst->letters = strlen(pst->fname) + strlen(pst->lname);
}
void showinfo(const struct namect * pst)
{
printf("%s %s, your name contains %d letters.\n",
pst->fname, pst->lname, pst->letters);
}
char * s_gets(char * st, int n)
{
char * ret_val;
char * find;
ret_val = fgets(st, n, stdin);
if (ret_val)
{
find = strchr(st, '\n'); // 查找换行符
if (find) // 如果地址不是 NULL,
*find = '\0'; // 在此处放置一个空字符
else
while (getchar() != '\n')
continue; // 处理输入行的剩余字符
}
return ret_val;
}
```

下面是编译并运行该程序后的一个输出示例：

text

```
Please enter your first name.
Viola
Please enter your last name.
Plunderfest
Viola Plunderfest, your name contains 16 letters.
```

现在，我们来看如何使用结构参数和返回值来完成相同的任务。第一，为了传递结构本身，函数的参数必须是`person`，而不是`&person`。那么，相应的形式参数应声明为`struct namect`，而不是指向该类型的指针。第二，可以通过返回一个结构，把结构的信息返回给`main()`。程序清单14.9演示了不使用指针的版本。

程序清单14.9　names2.c 程序

C

```
/* names2.c -- 传递并返回结构 */
#include <stdio.h>
#include <string.h>
#define NLEN 30
struct namect {
char fname[NLEN];
char lname[NLEN];
int letters;
};
struct namect getinfo(void);
struct namect makeinfo(struct namect);
void showinfo(struct namect);
char * s_gets(char * st, int n);
int main(void)
{
struct namect person;
person = getinfo();
person = makeinfo(person);
showinfo(person);
return 0;
}
struct namect getinfo(void)
{
struct namect temp;
printf("Please enter your first name.\n");
s_gets(temp.fname, NLEN);
printf("Please enter your last name.\n");
s_gets(temp.lname, NLEN);
return temp;
}
struct namect makeinfo(struct namect info)
{
info.letters = strlen(info.fname) + strlen(info.lname);
return info;
}
void showinfo(struct namect info)
{
printf("%s %s, your name contains %d letters.\n",
info.fname, info.lname, info.letters);
}
```

## 14.7.5　结构和结构指针的选择

假设要编写一个与结构相关的函数，是用结构指针作为参数，还是用结构作为参数和返回值？两者各有优缺点。

**传递指针的优点**：

1. 无论是以前还是现在的C实现都能使用这种方法。
2. 执行起来很快，只需要传递一个地址。  
    **缺点**：无法保护数据，被调函数中的某些操作可能会意外影响原始结构。可以使用`const`限定符解决这个问题。

**传递结构的优点**：

1. 函数处理的是原始数据的副本，保护了原始数据。
2. 代码风格更自然、清晰。  
    **缺点**：
3. 较老版本的实现可能无法处理传递结构。
4. 传递结构浪费时间和存储空间，尤其是大型结构。

**总结**：

- 小型结构（如3个成员以内）通常按值传递。
- 大型结构使用指针传递，并用`const`保护数据不被修改。
- 需要修改原始结构时，只能传递指针。

例如，计算两个`vector`结构之和：

C

```
struct vector {double x; double y;};
struct vector ans, a, b;

// 按值传递（适合小结构）
struct vector sum_vect(struct vector, struct vector);
ans = sum_vect(a, b);

// 指针传递（适合大结构）
void sum_vect(const struct vector *, const struct vector *, struct vector *);
sum_vect(&a, &b, &ans);
```

总之，按效率优先使用指针，按代码可读性优先按值传递。小型结构（如坐标、复数）适合按值传递，大型结构（如数据库记录）适合指针传递。
### 14.7.6　结构中的字符数组和字符指针

到目前为止，我们在结构中都使用字符数组来储存字符串。是否可以使用指向`char`的指针来代替字符数组？例如，程序清单14.3中有如下声明：

C

```
#define LEN 20
struct names {
    char first[LEN];
    char last[LEN];
};
```

其中的结构声明是否可以这样写：

C

```
struct pnames {
    char * first;
    char * last;
};
```

当然可以，但是如果不理解这样做的含义，可能会有麻烦。考虑下面的代码：

C

```
struct names veep = {"Talia", "Summers"};
struct pnames treas = {"Brad", "Fallingjaw"};
printf("%s and %s\n", veep.first, treas.first);
```

以上代码都没问题，也能正常运行，但是思考一下字符串被储存在哪里。对于`struct names`类型的结构变量`veep`，以上字符串都储存在结构内部，结构总共要分配40字节储存姓名。然而，对于`struct pnames`类型的结构变量`treas`，以上字符串储存在编译器储存常量的地方。结构本身只储存了两个地址，在我们的系统中共占16字节。尤其是，`struct pnames`结构不用为字符串分配任何存储空间。它使用的是储存在别处的字符串（如，字符串常量或数组中的字符串）。简而言之，在`pnames`结构变量中的指针应该只用来在程序中管理那些已分配和在别处分配的字符串。

我们看看这种限制在什么情况下出问题。考虑下面的代码：

C

```
struct names accountant;
struct pnames attorney;
puts("Enter the last name of your accountant:");
scanf("%s", accountant.last);
puts("Enter the last name of your attorney:");
scanf("%s", attorney.last); /* 这里有一个潜在的危险 */
```

就语法而言，这段代码没问题。但是，用户输入储存到哪里去了？对于会计师（`accountant`），他的名储存在`accountant`结构变量的`last`成员中，该结构中有一个储存字符串的数组。对于律师（`attorney`），`scanf()`把字符串放到`attorney.last`表示的地址上。由于这是未经初始化的变量，地址可以是任何值，因此程序可以把名放在任何地方。如果走运的话，程序不会出问题，至少暂时不会出问题，否则这一操作会导致程序崩溃。实际上，如果程序能正常运行并不是好事，因为这意味着一个未被觉察的危险潜伏在程序中。

因此，如果要用结构储存字符串，用字符数组作为成员比较简单。用指向`char`的指针也行，但是误用会导致严重的问题。

### 14.7.7　结构、指针和`malloc()`

如果使用`malloc()`分配内存并使用指针储存该地址，那么在结构中使用指针处理字符串就比较合理。这种方法的优点是，可以请求`malloc()`为字符串分配合适的存储空间。可以要求用4字节储存`"Joe"`和用18字节储存`"Rasolofomasoandro"`。用这种方法改写程序清单14.9并不费劲。主要是更改结构声明（用指针代替数组）和提供一个新版本的`getinfo()`函数。新的结构声明如下：

C

```
struct namect {
    char * fname; // 用指针代替数组
    char * lname;
    int letters;
};
```

**新的`getinfo()`函数使用临时数组读取输入，然后为每个字符串动态分配精确大小的内存，并拷贝字符串：**

C

```
void getinfo (struct namect * pst)
{
    char temp[SLEN];
    printf("Please enter your first name.\n");
    s_gets(temp, SLEN);
    // 分配内存储存名
    pst->fname = (char *) malloc(strlen(temp) + 1);
    // 把名拷贝到已分配的内存
    strcpy(pst->fname, temp);
    printf("Please enter your last name.\n");
    s_gets(temp, SLEN);
    pst->lname = (char *) malloc(strlen(temp) + 1);
    strcpy(pst->lname, temp);
}
```

要理解这两个字符串都未储存在结构中，它们储存在`malloc()`分配的内存块中。然而，结构中储存着这两个字符串的地址，处理字符串的函数通常都要使用字符串的地址。因此，不用修改程序中的其他函数。

第12章建议，应该成对使用`malloc()`和`free()`。因此，还要在程序中添加一个新的函数`cleanup()`，用于释放程序动态分配的内存。如程序清单14.10所示。

**程序清单14.10　names3.c 程序完整代码，使用指针和`malloc()`动态分配字符串内存，并在结束时释放：**

C

```
// names3.c -- 使用指针和 malloc()
#include <stdio.h>
#include <string.h> // 提供 strcpy()、strlen() 的原型
#include <stdlib.h> // 提供 malloc()、free() 的原型
#define SLEN 81
struct namect {
    char * fname; // 使用指针
    char * lname;
    int letters;
};
void getinfo(struct namect *);
void makeinfo(struct namect *);
void showinfo(const struct namect *);
void cleanup(struct namect *); // 调用该函数时释放内存
char * s_gets(char * st, int n);
int main(void)
{
    struct namect person;
    getinfo(&person);
    makeinfo(&person);
    showinfo(&person);
    cleanup(&person);
    return 0;
}
void getinfo(struct namect * pst)
{
    char temp[SLEN];
    printf("Please enter your first name.\n");
    s_gets(temp, SLEN);
    // 分配内存以储存名
    pst->fname = (char *) malloc(strlen(temp) + 1);
    // 把名拷贝到动态分配的内存中
    strcpy(pst->fname, temp);
    printf("Please enter your last name.\n");
    s_gets(temp, SLEN);
    pst->lname = (char *) malloc(strlen(temp) + 1);
    strcpy(pst->lname, temp);
}
void makeinfo(struct namect * pst)
{
    pst->letters = strlen(pst->fname) +
                   strlen(pst->lname);
}
void showinfo(const struct namect * pst)
{
    printf("%s %s, your name contains %d letters.\n",
           pst->fname, pst->lname, pst->letters);
}
void cleanup(struct namect * pst)
{
    free(pst->fname);
    free(pst->lname);
}
char * s_gets(char * st, int n)
{
    char * ret_val;
    char * find;
    ret_val = fgets(st, n, stdin);
    if (ret_val)
    {
        find = strchr(st, '\n'); // 查找换行符
        if (find) // 如果地址不是 NULL，
            *find = '\0'; // 在此处放置一个空字符
        else
            while (getchar() != '\n')
                continue; // 处理输入行的剩余部分
    }
    return ret_val;
}
```

text

```
Please enter your first name.
Floresiensis
Please enter your last name.
Mann
Floresiensis Mann, your name contains 16 letters.
```

### 14.7.8　复合字面量和结构（C99）

C99的复合字面量特性可用于结构和数组。如果只需要一个临时结构值，复合字面量很好用。例如，可以使用复合字面量创建一个数组作为函数的参数或赋给另一个结构。语法是把类型名放在圆括号中，后面紧跟一个用花括号括起来的初始化列表。例如，下面是`struct book`类型的复合字面量：

C

```
(struct book) {"The Idiot", "Fyodor Dostoyevsky", 6.99}
```

**程序清单14.11　complit.c 程序完整代码，根据输入分数使用复合字面量初始化结构：**

C

```
/* complit.c -- 复合字面量 */
#include <stdio.h>
#define MAXTITL 41
#define MAXAUTL 31
struct book { // 结构模版：标记是 book
    char title[MAXTITL];
    char author[MAXAUTL];
    float value;
};
int main(void)
{
    struct book readfirst;
    int score;
    printf("Enter test score: ");
    scanf("%d", &score);
    if (score >= 84)
        readfirst = (struct book) {"Crime and Punishment",
                                   "Fyodor Dostoyevsky",
                                   11.25};
    else
        readfirst = (struct book) {"Mr. Bouncy's Nice Hat",
                                   "Fred Winsome",
                                   5.99};
    printf("Your assigned reading:\n");
    printf("%s by %s: $%.2f\n", readfirst.title,
           readfirst.author, readfirst.value);
    return 0;
}
```

还可以把复合字面量作为函数的参数。如果函数接受一个结构，可以把复合字面量作为实际参数传递：

**按值传递结构给函数，使用复合字面量作为参数：**

C

```
struct rect {double x; double y;};
double rect_area(struct rect r){return r.x * r.y;}
...
double area;
area = rect_area( (struct rect) {10.5, 20.0});
```

值210 被赋给`area`。

如果函数接受一个地址，可以传递复合字面量的地址：

**按地址传递，使用复合字面量的地址：**

C

```
struct rect {double x; double y;};
double rect_areap(struct rect * rp){return rp->x * rp->y;}
...
double area;
area = rect_areap( &(struct rect) {10.5, 20.0});
```

值210 被赋给`area`。

复合字面量在所有函数的外部，具有静态存储期；如果复合字面量在块中，则具有自动存储期。复合字面量和普通初始化列表的语法规则相同。这意味着，可以在复合字面量中使用指定初始化器。

### 14.7.9　伸缩型数组成员（C99）

C99新增了一个特性：伸缩型数组成员（flexible array member），利用这项特性声明的结构，其最后一个数组成员具有一些特性。第1个特性是，该数组不会立即存在。第2个特性是，使用这个伸缩型数组成员可以编写合适的代码，就好像它确实存在并具有所需数目的元素一样。这可能听起来很奇怪，所以我们来一步步地创建和使用一个带伸缩型数组成员的结构。

首先，声明一个伸缩型数组成员有如下规则：

伸缩型数组成员必须是结构的最后一个成员；

结构中必须至少有一个成员；

伸缩数组的声明类似于普通数组，只是它的方括号中是空的。

下面用一个示例来解释以上几点：

C

```
struct flex
{
    int count;
    double average;
    double scores[]; // 伸缩型数组成员
};
```

声明一个`struct flex`类型的结构变量时，不能用`scores`做任何事，因为没有给这个数组预留存储空间。实际上，C99的意图并不是让你声明`struct flex`类型的变量，而是希望你声明一个指向`struct flex`类型的指针，然后用`malloc()`来分配足够的空间，以储存`struct flex`类型结构的常规内容和伸缩型数组成员所需的额外空间。例如，假设用`scores`表示一个内含5个`double`类型值的数组，可以这样做：

C

```
struct flex * pf; // 声明一个指针
// 请求为一个结构和一个数组分配存储空间
pf = malloc(sizeof(struct flex) + 5 * sizeof(double));
```

现在有足够的存储空间储存`count`、`average`和一个内含5个`double`类型值的数组。可以用指针`pf`访问这些成员：

C

```
pf->count = 5; // 设置 count 成员
pf->scores[2] = 18.5; // 访问数组成员的一个元素
```

**程序清单14.12　flexmemb.c 程序完整代码，演示不同大小的伸缩型数组分配和使用：**

C

```
// flexmemb.c -- 伸缩型数组成员（C99新增特性）
#include <stdio.h>
#include <stdlib.h>
struct flex
{
    size_t count;
    double average;
    double scores []; // 伸缩型数组成员
};
void showFlex(const struct flex * p);
int main(void)
{
    struct flex * pf1, *pf2;
    int n = 5;
    int i;
    int tot = 0;
    // 为结构和数组分配存储空间
    pf1 = malloc(sizeof(struct flex) + n * sizeof(double));
    pf1->count = n;
    for (i = 0; i < n; i++)
    {
        pf1->scores[i] = 20.0 - i;
        tot += pf1->scores[i];
    }
    pf1->average = tot / n;
    showFlex(pf1);
    n = 9;
    tot = 0;
    pf2 = malloc(sizeof(struct flex) + n * sizeof(double));
    pf2->count = n;
    for (i = 0; i < n; i++)
    {
        pf2->scores[i] = 20.0 - i / 2.0;
        tot += pf2->scores[i];
    }
    pf2->average = tot / n;
    showFlex(pf2);
    free(pf1);
    free(pf2);
    return 0;
}
void showFlex(const struct flex * p)
{
    int i;
    printf("Scores : ");
    for (i = 0; i < p->count; i++)
        printf("%g ", p->scores[i]);
    printf("\nAverage: %g\n", p->average);
}
```

text

```
Scores : 20 19 18 17 16
Average: 18
Scores : 20 19.5 19 18.5 18 17.5 17 16.5 16
Average: 17
```

带伸缩型数组成员的结构确实有一些特殊的处理要求。第一，不能用结构进行赋值或拷贝：

C

```
struct flex * pf1, *pf2; // *pf1 和*pf2 都是结构
...
*pf2 = *pf1; // 不要这样做
```

这样做只能拷贝除伸缩型数组成员以外的其他成员。确实要进行拷贝，应使用`memcpy()`函数（第16章中介绍）。

第二，不要以按值方式把这种结构传递给结构。原因相同，按值传递一个参数与赋值类似。要把结构的地址传递给函数。

第三，不要使用带伸缩型数组成员的结构作为数组成员或另一个结构的成员。

这种类似于在结构中最后一个成员是伸缩型数组的情况，称为struct hack。除了伸缩型数组成员在声明时用空的方括号外，struct hack特指大小为0的数组。然而，struct hack是针对特殊编译器（GCC）的，不属于C标准。这种伸缩型数组成员方法是标准认可的编程技巧。

### 14.7.10　匿名结构（C11）

匿名结构是一个没有名称的结构成员。为了理解它的工作原理，我们先考虑如何创建嵌套结构：

C

```
struct names
{
    char first[20];
    char last[20];
};
struct person
{
    int id;
    struct names name; // 嵌套结构成员
};
struct person ted = {8483, {"Ted", "Grass"}};
```

这里，`name`成员是一个嵌套结构，可以通过类似`ted.name.first`的表达式访问`"ted"`：

C

```
puts(ted.name.first);
```

在C11中，可以用嵌套的匿名成员结构定义`person`：

C

```
struct person
{
    int id;
    struct {char first[20]; char last[20];}; // 匿名结构
};
```

初始化`ted`的方式相同：

C

```
struct person ted = {8483, {"Ted", "Grass"}};
```

但是，在访问`ted`时简化了步骤，只需把`first`看作是`person`的成员那样使用它：

C

```
puts(ted.first);
```

当然，也可以把`first`和`last`直接作为`person`的成员，删除嵌套循环。匿名特性在嵌套联合中更加有用，我们在本章后面介绍。

### 14.7.11　使用结构数组的函数

假设一个函数要处理一个结构数组。由于数组名就是该数组的地址，所以可以把它传递给函数。另外，该函数还需访问结构模板。为了理解该函数的工作原理，程序清单14.13把前面的金融程序扩展为两人，所以需要一个内含两个`funds`结构的数组。

**程序清单14.13　funds4.c 程序完整代码，将结构数组传递给函数计算总和：**

C

```
/* funds4.c -- 把结构数组传递给函数 */
#include <stdio.h>
#define FUNDLEN 50
#define N 2
struct funds {
    char bank[FUNDLEN];
    double bankfund;
    char save[FUNDLEN];
    double savefund;
};
double sum(const struct funds money [], int n);
int main(void)
{
    struct funds jones[N] = {
        {
            "Garlic-Melon Bank",
            4032.27,
            "Lucky's Savings and Loan",
            8543.94
        },
        {
            "Honest Jack's Bank",
            3620.88,
            "Party Time Savings",
            3802.91
        }
    };
    printf("The Joneses have a total of $%.2f.\n",sum(jones, N));
    return 0;
}
double sum(const struct funds money [], int n)
{
    double total;
    int i;
    for (i = 0, total = 0; i < n; i++)
        total += money[i].bankfund + money[i].savefund;
    return(total);
}
```

text

```
The Joneses have a total of $20000.00.
```

（读者也许认为这个总和有些巧合！）

数组名`jones`是该数组的地址，即该数组首元素（`jones[0]`）的地址。因此，指针`money`的初始值相当于通过下面的表达式获得：

C

```
money = &jones[0];
```

因为`money`指向`jones`数组的首元素，所以`money[0]`是该数组的另一个名称。与此类似，`money[1]`是第2个元素。每个元素都是一个`funds`类型的结构，所以都可以使用点运算符（`.`）来访问`funds`类型结构的成员。

下面是几个要点。

可以把数组名作为数组中第1个结构的地址传递给函数。

然后可以用数组表示法访问数组中的其他结构。注意下面的函数调用与使用数组名效果相同：

C

```
sum(&jones[0], N)
```

因为`jones`和`&jones[0]`的地址相同，使用数组名是传递结构地址的一种间接的方法。

由于`sum()`函数不能改变原始数据，所以该函数使用了ANSI C的限定符`const`。
# 14.8　把结构内容保存到文件中

由于结构可以储存不同类型的信息，所以它是构建数据库的重要工具。例如，可以用一个结构储存雇员或汽车零件的相关信息。最终，我们要把这些信息储存在文件中，并且能再次检索。数据库文件可以包含任意数量的此类数据对象。储存在一个结构中的整套信息被称为记录（record），单独的项被称为字段（field）。本节我们来探讨这个主题。

或许储存记录最没效率的方法是用`fprintf()`。例如，回忆程序清单14.1中的book结构：

text

```
#define MAXTITL 40
#define MAXAUTL 40
struct book {
    char title[MAXTITL];
    char author[MAXAUTL];
    float value;
};
```

如果`pbook`标识一个文件流，那么通过下面这条语句可以把信息储存在`struct book`类型的结构变量`primer`中：

text

```
fprintf(pbooks, "%s %s %.2f\n", primer.title, primer.author, primer.value);
```

对于一些结构（如，有30个成员的结构），这个方法用起来很不方便。另外，在检索时还存在问题，因为程序要知道一个字段结束和另一个字段开始的位置。虽然用固定字段宽度的格式可以解决这个问题（例如，`"%39s%39s%8.2f"`），但是这个方法仍然很笨拙。

更好的方案是使用`fread()`和`fwrite()`函数读写结构大小的单元。回忆一下，这两个函数使用与程序相同的二进制表示法。例如：

text

```
fwrite(&primer, sizeof(struct book), 1, pbooks);
```

定位到`primer`结构变量开始的位置，并把结构中所有的字节都拷贝到与`pbooks`相关的文件中。`sizeof(struct book)`告诉函数待拷贝的一块数据的大小，`1`表明一次拷贝一块数据。带相同参数的`fread()`函数从文件中拷贝一块结构大小的数据到`&primer`指向的位置。简而言之，这两个函数一次读写整个记录，而不是一个字段。

以二进制表示法储存数据的缺点是，不同的系统可能使用不同的二进制表示法，所以数据文件可能不具可移植性。甚至同一个系统，不同编译器设置也可能导致不同的二进制布局。

## 14.8.1　保存结构的程序示例

为了演示如何在程序中使用这些函数，我们把程序清单14.2修改为一个新的版本（即程序清单14.14），把书名保存在`book.dat`文件中。如果该文件已存在，程序将显示它当前的内容，然后允许在文件中添加内容（如果你使用的是早期的Borland编译器，请参阅程序清单14.2后面的"Borland C和浮点数"）。

booksave.c程序使用二进制文件操作来保存和读取书籍信息结构

text

```
/* booksave.c -- 在文件中保存结构中的内容 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAXTITL 40
#define MAXAUTL 40
#define MAXBKS 10 /* 最大书籍数量 */
char * s_gets(char * st, int n);
struct book { /* 建立 book 模板 */
    char title[MAXTITL];
    char author[MAXAUTL];
    float value;
};
int main(void)
{
    struct book library[MAXBKS]; /* 结构数组 */
    int count = 0;
    int index, filecount;
    FILE * pbooks;
    int size = sizeof(struct book);
    if ((pbooks = fopen("book.dat", "a+b")) == NULL)
    {
        fputs("Can't open book.dat file\n", stderr);
        exit(1);
    }
    rewind(pbooks); /* 定位到文件开始 */
    while (count < MAXBKS && fread(&library[count], size,
        1, pbooks) == 1)
    {
        if (count == 0)
            puts("Current contents of book.dat:");
        printf("%s by %s: $%.2f\n", library[count].title,
            library[count].author, library[count].value);
        count++;
    }
    filecount = count;
    if (count == MAXBKS)
    {
        fputs("The book.dat file is full.", stderr);
        exit(2);
    }
    puts("Please add new book titles.");
    puts("Press [enter] at the start of a line to stop.");
    while (count < MAXBKS && s_gets(library[count].title, MAXTITL)
        != NULL
        && library[count].title[0] != '\0')
    {
        puts("Now enter the author.");
        s_gets(library[count].author, MAXAUTL);
        puts("Now enter the value.");
        scanf("%f", &library[count++].value);
        while (getchar() != '\n')
            continue; /* 清理输入行 */
        if (count < MAXBKS)
            puts("Enter the next title.");
    }
    if (count > 0)
    {
        puts("Here is the list of your books:");
        for (index = 0; index < count; index++)
            printf("%s by %s: $%.2f\n", library[index].title,
                library[index].author, library[index].value);
        fwrite(&library[filecount], size, count - filecount,
            pbooks);
    }
    else
        puts("No books? Too bad.\n");
    puts("Bye.\n");
    fclose(pbooks);
    return 0;
}
char * s_gets(char * st, int n)
{
    char * ret_val;
    char * find;
    ret_val = fgets(st, n, stdin);
    if (ret_val)
    {
        find = strchr(st, '\n'); // 查找换行符
        if (find) // 如果地址不是 NULL，
            *find = '\0'; // 在此处放置一个空字符
        else
            while (getchar() != '\n')
                continue; // 清理输入行
    }
    return ret_val;
}
```

我们先看几个运行示例，然后再讨论程序中的要点。

text

```
$ ./booksave
Please add new book titles.
Press [enter] at the start of a line to stop.
Metric Merriment
Now enter the author.
Polly Poetica
Now enter the value.
18.99
Enter the next title.
Deadly Farce
Now enter the author.
Dudley Forse
Now enter the value.
15.99
Enter the next title.
[enter]
Here is the list of your books:
Metric Merriment by Polly Poetica: $18.99
Deadly Farce by Dudley Forse: $15.99
Bye.
$ ./booksave
Current contents of book.dat:
Metric Merriment by Polly Poetica: $18.99
Deadly Farce by Dudley Forse: $15.99
Please add new book titles.
The Third Jar
Now enter the author.
Nellie Nostrum
Now enter the value.
22.99
Enter the next title.
[enter]
Here is the list of your books:
Metric Merriment by Polly Poetica: $18.99
Deadly Farce by Dudley Forse: $15.99
The Third Jar by Nellie Nostrum: $22.99
Bye.
$
```

再次运行booksave.c程序把这3本书作为当前的文件记录打印出来。

## 14.8.2　程序要点

首先，以`"a+b"`模式打开文件。`a+`部分允许程序读取整个文件并在文件的末尾添加内容。`b`是ANSI的一种标识方法，表明程序将使用二进制文件格式。对于不接受`b`模式的UNIX系统，可以省略`b`，因为UNIX只有一种文件形式。对于早期的ANSI实现，要找出和`b`等价的表示法。

我们选择二进制模式是因为`fread()`和`fwrite()`函数要使用二进制文件。虽然结构中有些内容是文本，但是`value`成员不是文本。如果使用文本编辑器查看`book.dat`，该结构本文部分的内容显示正常，但是数值部分的内容不可读，甚至会导致文本编辑器出现乱码。

`rewind()`函数确保文件指针位于文件开始处，为读文件做好准备。

第1个`while`循环每次把一个结构读到结构数组中，当数组已满或读完文件时停止。变量`filecount`统计已读结构的数量。

第2个`while`按下循环提示用户进行输入，并接受用户的输入。和程序清单14.2一样，当数组已满或用户在一行的开始处按下Enter键时，循环结束。注意，该循环开始时`count`变量的值是第1个循环结束后的值。该循环把新输入项添加到数组的末尾。

然后`for`循环打印文件和用户输入的数据。因为该文件是以附加模式打开，所以新写入的内容添加到文件现有内容的末尾。

我们本可以用一个循环在文件末尾一次添加一个结构，但还是决定用`fwrite()`一次写入一块数据。对表达式`count - filecount`求值得新添加的书籍数量，然后调用`fwrite()`把结构大小的块写入文件。由于表达式`&library[filecount]`是数组中第1个新结构的地址，所以拷贝就从这里开始。

也许该例是把结构写入文件和检索它们的最简单的方法，但是这种方法浪费存储空间，因为这还保存了结构中未使用的部分。该结构的大小是2 × 40 × `sizeof(char)` + `sizeof(float)`，在我们的系统中共84字节。实际上不是每个输入项都需要这么多空间。但是，让每个输入块的大小相同在检索数据时很方便。

另一个方法是使用可变大小的记录。为了方便读取文件中的这种记录，每个记录以数值字段规定记录的大小。这比上一种方法复杂。通常，这种方法涉及接下来要介绍的"链式结构"和第12章的动态内存分配。
### 14.9　链式结构

在结束讨论结构之前，我们想简要介绍一下结构的多种用途之一：创建新的数据形式。计算机用户已经开发出的一些数据形式比我们提到过的数组和简单结构更有效地解决特定的问题。这些形式包括队列、二叉树、堆、哈希表和图表。许多这样的形式都由链式结构（linked structure）组成。通常，每个结构都包含一两个数据项和一两个指向其他同类型结构的指针。这些指针把一个结构和另一个结构链接起来，并提供一种路径能遍历整个彼此链接的结构。例如，图14.3演示了一个二叉树结构，每个单独的结构（或节点）都和它下面的两个结构（或节点）相连。

图14.3　一个二叉树结构

图14.3中显示的分级或树状的结构是否比数组高效？考虑一个有10级节点的树的情况。它有210 −1（或1023）个节点，可以储存1023个单词。如果这些单词以某种规则排列，那么可以从最顶层开始，逐级向下移动查找单词，最多只需移动9次便可找到任意单词。如果把这些单词都放在一个数组中，最多要查找1023个元素才能找出所需的单词。

如果你对这些高级概念感兴趣，可以阅读一些关于数据结构的书籍。使用C结构，可以创建和使用那些书中介绍的各种数据形式。另外，第17章中也介绍了一些高级数据形式。

本章对结构的概念介绍至此为止，第17章中会给出链式结构的例子。下面，我们介绍C语言中的联合、枚举和typedef。

### 14.10　联合简介

联合（union）是一种数据类型，它能在同一个内存空间中储存不同的数据类型（不是同时储存）。其典型的用法是，设计一种表以储存既无规律、事先也不知道顺序的混合类型。使用联合类型的数组，其中的联合都大小相等，每个联合可以储存各种数据类型。

创建联合和创建结构的方式相同，需要一个联合模板和联合变量。可以用一个步骤定义联合，也可以用联合标记分两步定义。下面是一个带标记的联合模板：

C

```
union hold {
    int digit;
    double bigfl;
    char letter;
};
```

根据以上形式声明的结构可以储存一个int类型、一个double类型和char类型的值。然而，声明的联合只能储存一个int类型的值或一个double类型的值或char类型的值。

下面定义了3个与hold类型相关的变量：

C

```
union hold fit; // hold类型的联合变量
union hold save[10]; // 内含10个联合变量的数组
union hold * pu; // 指向hold类型联合变量的指针
```

**以下是联合变量的初始化示例：**

C

```
union hold valA;
valA.letter = 'R';
union hold valB = valA; // 用另一个联合来初始化
union hold valC = {88}; // 初始化联合的digit 成员
union hold valD = {.bigfl = 118.2}; // 指定初始化器
```

### 14.10.1　使用联合

下面是联合的一些用法：

C

```
fit.digit = 23; //把 23 储存在 fit，占2字节
fit.bigfl = 2.0; // 清除23，储存 2.0，占8字节
fit.letter = 'h'; // 清除2.0，储存h，占1字节
```

点运算符表示正在使用哪种数据类型。在联合中，一次只储存一个值。即使有足够的空间，也不能同时储存一个char类型值和一个int类型值。编写代码时要注意当前储存在联合中的数据类型。

和用指针访问结构使用->运算符一样，用指针访问联合时也要使用->运算符：

C

```
pu = &fit;
x = pu->digit; // 相当于 x = fit.digit
```

不要像下面的语句序列这样：

C

```
fit.letter = 'A';
flnum = 3.02*fit.bigfl; // 错误
```

以上语句序列是错误的，因为储存在fit中的是char类型，但是下一行却假定fit中的内容是double类型。

不过，用一个成员把值储存在一个联合中，然后用另一个成员查看内容，这种做法有时很有用。下一章的程序清单15.4就给出了一个这样的例子。

联合的另一种用法是，在结构中储存与其成员有从属关系的信息。例如，假设用一个结构表示一辆汽车。如果汽车属于驾驶者，就要用一个结构成员来描述这个所有者。如果汽车被租赁，那么需要一个成员来描述其租赁公司。可以用下面的代码来完成：

**以下是使用联合的结构定义示例：**

C

```
struct owner {
    char socsecurity[12];
    ...
};
struct leasecompany {
    char name[40];
    char headquarters[40];
    ...
};
union data {
    struct owner owncar;
    struct leasecompany leasecar;
};
struct car_data {
    char make[15];
    int status; /* 私有为0，租赁为1 */
    union data ownerinfo;
    ...
};
```

假设flits是car_data类型的结构变量，如果flits.status为0，程序将使用flits.ownerinfo.owncar.socsecurity，如果flits.status为1，程序则使用flits.ownerinfo.leasecar.name。

### 14.10.2　匿名联合（C11）

匿名联合和匿名结构的工作原理相同，即匿名联合是一个结构或联合的无名联合成员。例如，我们重新定义car_data结构如下：

**以下是匿名联合的结构定义示例：**

C

```
struct owner {
    char socsecurity[12];
    ...
};
struct leasecompany {
    char name[40];
    char headquarters[40];
    ...
};
struct car_data {
    char make[15];
    int status; /* 私有为0，租赁为1 */
    union {
        struct owner owncar;
        struct leasecompany leasecar;
    };
    ...
};
```

现在，如果flits是car_data类型的结构变量，可以用flits.owncar.socsecurity代替flits.ownerinfo.owncar.socsecurity。

成员运算符：.

一般注释：

该运算符与结构变量或联合变量名一起使用，指定结构变量或联合变量的一个成员。如果name是一个结构变量的名称，member是该结构模版指定的一个成员名，下面标识了该结构变量的这个成员:

name.member

name.member的类型就是member的类型。联合使用成员运算符的方式与结构相同。

示例：

C

```
struct {
    int code;
    float cost;
} item;
item.code = 1265;
```

间接成员运算符： ->

一般注释：

该运算符和指向结构或联合的指针一起使用，标识结构变量或联合变量的一个成员。假设ptrstr是指向结构的指针，member是该结构模版指定的一个成员，那么：

ptrstr->member

标识了指向结构的成员。联合使用间接成员运算符的方式与结构相同。

示例：

C

```
struct {
    int code;
    float cost;
} item, * ptrst;
ptrst = &item;
ptrst->code = 3451;
```

最后一条语句把一个int类型的值赋给item的code成员。如下3个表达式是等价的：

ptrst->code item.code (*ptrst).code

### 14.11　枚举类型

可以用枚举类型（enumerated type）声明符号名称来表示整型常量。使用enum关键字，可以创建一个新“类型”并指定它可具有的值（实际上，enum常量是int类型，因此，只要能使用int类型的地方就可以使用枚举类型）。枚举类型的目的是提高程序的可读性。它的语法与结构的语法相同。例如，可以这样声明：

C

```
enum spectrum {red, orange, yellow, green, blue, violet};
enum spectrum color;
```

第1个声明创建了spetrum作为标记名，允许把enum spetrum作为一个类型名使用。第2个声明使color作为该类型的变量。第1个声明中花括号内的标识符枚举了spectrum变量可能有的值。因此，color可能的值是red、orange、yellow等。这些符号常量被称为枚举符（enumerator）。然后，便可这样用：

C

```
int c;
color = blue;
if (color == yellow)
...;
for (color = red; color <= violet; color++)
...;
```

虽然枚举符（如red和blue）是int类型，但是枚举变量可以是任意整数类型，前提是该整数类型可以储存枚举常量。例如，spectrum的枚举符范围是0～5，所以编译器可以用unsigned char来表示color变量。

顺带一提，C枚举的一些特性并不适用于C++。例如，C允许枚举变量使用++运算符，但是C++标准不允许。所以，如果编写的代码将来会并入C++程序，那么必须把上面例子中的color声明为int类型，才能C和C++都兼容。

### 14.11.1　enum 常量

blue和red到底是什么？从技术层面看，它们是int类型的常量。例如，假定有前面的枚举声明，可以这样写：

C

```
printf("red = %d, orange = %d\n", red, orange);
```

其输出如下：

red = 0, orange = 1

red成为一个有名称的常量，代表整数0。类似地，其他标识符都是有名称的常量，分别代表1～5。只要是能使用整型常量的地方就可以使用枚举常量。例如，在声明数组时，可以用枚举常量表示数组的大小；在switch语句中，可以把枚举常量作为标签。

### 14.11.2　默认值

默认情况下，枚举列表中的常量都被赋予0、1、2等。因此，下面的声明中nina的值是3：

C

```
enum kids {nippy, slats, skippy, nina, liz};
```

### 14.11.3　赋值

在枚举声明中，可以为枚举常量指定整数值：

C

```
enum levels {low = 100, medium = 500, high = 2000};
```

如果只给一个枚举常量赋值，没有对后面的枚举常量赋值，那么后面的常量会被赋予后续的值。例如，假设有如下的声明：

C

```
enum feline {cat, lynx = 10, puma, tiger};
```

那么，cat的值是0（默认），lynx、puma和tiger的值分别是10、11、12。

### 14.11.4　enum的用法

枚举类型的目的是为了提高程序的可读性和可维护性。如果要处理颜色，使用red和blue比使用0和1更直观。注意，枚举类型只能在内部使用。如果要输入color中orange的值，只能输入1，而不是单词orange。或者，让程序先读入字符串"orange"，再将其转换为orange代表的值。

因为枚举类型是整数类型，所以可以在表达式中以使用整数变量的方式使用enum变量。它们用在case语句中很方便。

**程序清单14.15　enum.c 程序完整代码，使用枚举类型处理颜色输入：**

C

```
/* enum.c -- 使用枚举类型的值 */
#include <stdio.h>
#include <string.h> // 提供 strcmp()、strchr()函数的原型
#include <stdbool.h> // C99 特性
char * s_gets(char * st, int n);
enum spectrum { red, orange, yellow, green, blue, violet };
const char * colors [] = { "red", "orange", "yellow",
                           "green", "blue", "violet" };
#define LEN 30
int main(void)
{
    char choice[LEN];
    enum spectrum color;
    bool color_is_found = false;
    puts("Enter a color (empty line to quit):");
    while (s_gets(choice, LEN) != NULL && choice[0] != '\0')
    {
        for (color = red; color <= violet; color++)
        {
            if (strcmp(choice, colors[color]) == 0)
            {
                color_is_found = true;
                break;
            }
        }
        if (color_is_found)
            switch (color)
            {
                case red: puts("Roses are red.");
                          break;
                case orange: puts("Poppies are orange.");
                             break;
                case yellow: puts("Sunflowers are yellow.");
                             break;
                case green: puts("Grass is green.");
                            break;
                case blue: puts("Bluebells are blue.");
                           break;
                case violet: puts("Violets are violet.");
                             break;
            }
        else
            printf("I don't know about the color %s.\n", choice);
        color_is_found = false;
        puts("Next color, please (empty line to quit):");
    }
    puts("Goodbye!");
    return 0;
}
char * s_gets(char * st, int n)
{
    char * ret_val;
    char * find;
    ret_val = fgets(st, n, stdin);
    if (ret_val)
    {
        find = strchr(st, '\n'); // 查找换行符
        if (find) // 如果地址不是 NULL，
            *find = '\0'; // 在此处放置一个空字符
        else
            while (getchar() != '\n')
                continue; // 清理输入行
    }
    return ret_val;
}
```

当输入的字符串与color数组的成员指向的字符串相匹配时，for循环结束。如果循环找到匹配的颜色，程序就用枚举变量的值与作为case标签的枚举常量匹配。下面是该程序的一个运行示例：

Enter a color (empty line to quit):

blue

Bluebells are blue.

Next color, please (empty line to quit):

orange

Poppies are orange.

Next color, please (empty line to quit):

purple

I don't know about the color purple.

Next color, please (empty line to quit):

Goodbye!

### 14.11.5　共享名称空间

C语言使用名称空间（namespace）标识程序中的各部分，即通过名称来识别。作用域是名称空间概念的一部分：两个不同作用域的同名变量不冲突；两个相同作用域的同名变量冲突。名称空间是分类别的。在特定作用域中的结构标记、联合标记和枚举标记都共享相同的名称空间，该名称空间与普通变量使用的空间不同。这意味着在相同作用域中变量和标记的名称可以相同，不会引起冲突，但是不能在相同作用域中声明两个同名标签或同名变量。例如，在C中，下面的代码不会产生冲突：

C

```
struct rect { double x; double y; };
int rect; // 在C中不会产生冲突
```

尽管如此，以两种不同的方式使用相同的标识符会造成混乱。另外，C++不允许这样做，因为它把标记名和变量名放在相同的名称空间中。

### 14.12　typedef 简介

typedef工具是一个高级数据特性，利用typedef可以为某一类型自定义名称。这方面与#define类似，但是两者有3处不同：

与#define不同，typedef创建的符号名只受限于类型，不能用于值。

typedef由编译器解释，不是预处理器。

在其受限范围内，typedef比#define更灵活。

下面介绍typedef的工作原理。假设要用BYTE表示1字节的数组。只需像定义个char类型变量一样定义BYTE，然后在定义前面加上关键字typedef即可：

C

```
typedef unsigned char BYTE;
```

随后，便可使用BYTE来定义变量：

C

```
BYTE x, y[10], * z;
```

该定义的作用域取决于typedef定义所在的位置。如果定义在函数中，就具有局部作用域，受限于定义所在的函数。如果定义在函数外面，就具有文件作用域。

通常，typedef定义中用大写字母表示被定义的名称，以提醒用户这个类型名实际上是一个符号缩写。当然，也可以用小写：

C

```
typedef unsigned char byte;
```

typedef中使用的名称遵循变量的命名规则。

为现有类型创建一个名称，看上去真是多此一举，但是它有时的确很有用。在前面的示例中，用BYTE代替unsigned char表明你打算用BYTE类型的变量表示数字，而不是字符码。使用typedef还能提高程序的可移植性。例如，我们之前提到的sizeof运算符的返回类型：size_t类型，以及time()函数的返回类型：time_t类型。C标准规定sizeof和time()返回整数类型，但是让实现来决定具体是什么整数类型。其原因是，C标准委员会认为没有哪个类型对于所有的计算机平台都是最优选择。所以，标准委员会决定建立一个新的类型名（如，time_t），并让实现使用typedef来设置它的具体类型。以这样的方式，C标准提供以下通用原型：

time_t time(time_t *);

time_t在一个系统中是unsigned long，在另一个系统中可以是unsigned long long。只要包含time.h头文件，程序就能访问合适的定义，你也可以在代码中声明time_t类型的变量。

typedef的一些特性与#define的功能重合。例如：

C

```
#define BYTE unsigned char
```

这使预处理器用BYTE替换unsigned char。但是也有#define没有的功能：

C

```
typedef char * STRING;
```

没有typedef关键字，编译器将把STRING识别为一个指向char的指针变量。有了typedef关键字，编译器则把STRING解释成一个类型的标识符，该类型是指向char的指针。因此：

C

```
STRING name, sign;
```

相当于：

C

```
char * name, * sign;
```

但是，如果这样假设：

C

```
#define STRING char *
```

然后，下面的声明：

C

```
STRING name, sign;
```

将被翻译成：

C

```
char * name, sign;
```

这导致只有name才是指针。

还可以把typedef用于结构：

C

```
typedef struct complex {
    float real;
    float imag;
} COMPLEX;
```

然后便可使用COMPLEX类型代替complex结构来表示复数。使用typedef的第1个原因是：为经常出现的类型创建一个方便、易识别的类型名。例如，前面的例子中，许多人更倾向于使用STRING或与其等价的标记。

用typedef来命名一个结构类型时，可以省略该结构的标签：

C

```
typedef struct {double x; double y;} rect;
```

假设这样使用typedef定义的类型名：

C

```
rect r1 = {3.0, 6.0};
rect r2;
```

以上代码将被翻译成：

C

```
struct {double x; double y;} r1= {3.0, 6.0};
struct {double x; double y;} r2;
r2 = r1;
```

这两个结构在声明时都没有标记，它们的成员完全相同（成员名及其类型都匹配），C认为这两个结构的类型相同，所以r1和r2间的赋值是有效操作。

使用typedef的第2个原因是：typedef常用于给复杂的类型命名。例如，下面的声明：

C

```
typedef char (* FRPTC ()) [5];
```

把FRPTC声明为一个函数类型，该函数返回一个指针，该指针指向内含5个char类型元素的数组（参见下一节的讨论）。

使用typedef时要记住，typedef并没有创建任何新类型，它只是为某个已存在的类型增加了一个方便使用的标签。以STRING为例，这意味着我们创建的STRING类型变量可以作为实参传递给以指向char指针作为形参的函数。

通过结构、联合和typedef，C提供了有效处理数据的工具和处理可移植数据的工具。

### 14.13　其他复杂的声明

C允许用户自定义数据形式。虽然我们常用的是一些简单的形式，但是根据需要有时还会用到一些复杂的形式。在一些复杂的声明中，常包含下面的符号，如表14.1所示：

表14.1　声明时可使用的符号

符号含义

- 表示一个指针

() 表示一个函数

[] 表示一个数组

下面是一些较复杂的声明示例：

**以下是各种复杂声明的示例：**

C

```
int board[8][8]; // 声明一个内含int数组的数组
int ** ptr; // 声明一个指向指针的指针，被指向的指针指向int
int * risks[10]; // 声明一个内含10个元素的数组，每个元素都是一个指向int的指针
int (* rusks)[10]; // 声明一个指向数组的指针，该数组内含10个int类型的值
int * oof[3][4]; // 声明一个3×4 的二维数组，每个元素都是指向int的指针
int (* uuf)[3][4]; // 声明一个指向3×4二维数组的指针，该数组中内含int类型值
int (* uof[3])[4]; // 声明一个内含3个指针元素的数组，其中每个指针都指向一个内含4个int类型元素的数组
char * fump(int); // 返回字符指针的函数
char (* frump)(int); // 指向函数的指针，该函数的返回类型为char
char (* flump[3])(int); // 内含3个指针的数组，每个指针都指向返回类型为char的函数
```

要看懂以上声明，关键要理解*、()和[]的优先级。记住下面几条规则。

1．数组名后面的[]和函数名后面的()具有相同的优先级。它比*（解引用运算符）的优先级高。因此下面声明的risk是一个指针数组，不是指向数组的指针：

C

```
int * risks[10];
```

2．[]和()的优先级相同，由于都是从左往右结合，所以下面的声明中，在应用方括号之前，*先与rusks结合。因此rusks是一个指向数组的指针，该数组内含10个int类型的值：

C

```
int (* rusks)[10];
```

3．[]和()都是从左往右结合。因此下面声明的goods是一个由12个内含50个int类型值的数组组成的二维数组，不是一个有50个内含12个int类型值的数组组成的二维数组：

C

```
int goods[12][50];
```

把以上规则应用于下面的声明：

C

```
int * oof[3][4];
```

[3]比*的优先级高，由于从左往右结合，所以[3]先与oof结合。因此，oof首先是一个内含3个元素的数组。然后再与[4]结合，所以oof的每个元素都是内含4个元素的数组。*说明这些元素都是指针。最后，int表明了这4个元素都是指向int的指针。因此，这条声明要表达的是：foo是一个内含3个元素的数组，其中每个元素是由4个指向int的指针组成的数组。简而言之，oof是一个3×4的二维数组，每个元素都是指向int的指针。编译器要为12个指针预留存储空间。

现在来看下面的声明：

C

```
int (* uuf)[3][4];
```

圆括号使得*先与uuf结合，说明uuf是一个指针，所以uuf是一个指向3×4的int类型二维数组的指针。编译器要为一个指针预留存储空间。

根据这些规则，还可以声明：

C

```
char * fump(int); // 返回字符指针的函数
char (* frump)(int); // 指向函数的指针，该函数的返回类型为char
char (* flump[3])(int); // 内含3个指针的数组，每个指针都指向返回类型为char的函数
```

这3个函数都接受int类型参数。

可以使用typedef建立一系列相关类型：

**以下是使用typedef定义复杂类型的示例：**

C

```
typedef int arr5[5];
typedef arr5 * p_arr5;
typedef p_arr5 arrp10[10];
arr5 togs; // togs 是一个内含5个int类型值的数组
p_arr5 p2; // p2 是一个指向数组的指针，该数组内含5个int类型的值
arrp10 ap; // ap 是一个内含10个指针的数组，每个指针都指向一个内含5个int类型值的数组
```

如果把这些放入结构中，声明会更复杂。至于应用，我们就不再进一步讨论了。
### 14.14　函数和指针

通过上一节的学习可知，可以声明一个指向函数的指针。这个复杂的玩意儿到底有何用处？通常，函数指针常用作另一个函数的参数，告诉该函数要使用哪一个函数。例如，排序数组涉及比较两个元素，以确定先后。如果元素是数字，可以使用`>`运算符；如果元素是字符串或结构，就要调用函数进行比较。C库中的`qsort()`函数可以处理任意类型的数组，但是要告诉`qsort()`使用哪个函数来比较元素。为此，`qsort()`函数的参数列表中，有一个参数接受指向函数的指针。然后，`qsort()`函数使用该函数提供的方案进行排序，无论这个数组中的元素是整数、字符串还是结构。

我们来进一步研究函数指针。首先，什么是函数指针？假设有一个指向`int`类型变量的指针，该指针储存着这个`int`类型变量储存在内存位置的地址。同样，函数也有地址，因为函数的机器语言实现由载入内存的代码组成。指向函数的指针中储存着函数代码的起始处的地址。

其次，声明一个数据指针时，必须声明指针所指向的数据类型。声明一个函数指针时，必须声明指针指向的函数类型。为了指明函数类型，要指明函数签名，即函数的返回类型和形参类型。例如，考虑下面的函数原型：

C

```
void ToUpper(char *); // 把字符串中的字符转换成大写字符
```

`ToUpper()`函数的类型是"带`char *`类型参数、返回类型是`void`的函数"。下面声明了一个指针`pf`指向该函数类型：

C

```
void (*pf)(char *); // pf 是一个指向函数的指针
```

**提示：**从该声明可以看出，第1对圆括号把`*`和`pf`括起来，表明`pf`是一个指向函数的指针。因此，`(*pf)`是一个参数列表为`(char *)`、返回类型为`void`的函数。注意，把函数名`ToUpper`替换为表达式`(*pf)`是创建指向函数指针最简单的方式。所以，如果想声明一个指向某类型函数的指针，可以写出该函数的原型后把函数名替换成`(*pf)`形式的表达式，创建函数指针声明。前面提到过，由于运算符优先级的规则，在声明函数指针时必须把`*`和指针名括起来。如果省略第1个圆括号会导致完全不同的情况：

C

```
void *pf(char *); // pf 是一个返回字符指针的函数
```

要声明一个指向特定类型函数的指针，可以先声明一个该类型的函数，然后把函数名替换成`(*pf)`形式的表达式。然后，`pf`就成为指向该类型函数的指针。

声明了函数指针后，可以把类型匹配的函数地址赋给它。在这种上下文中，函数名可以用于表示函数的地址：

C

```
void ToUpper(char *);
void ToLower(char *);
int round(double);
void (*pf)(char *);

pf = ToUpper; // 有效，ToUpper是该类型函数的地址
pf = ToLower; //有效，ToUpper是该类型函数的地址
pf = round; // 无效，round与指针类型不匹配
pf = ToLower(); // 无效，ToLower()不是地址
```

最后一条语句是无效的，不仅因为`ToLower()`不是地址，而且`ToLower()`的返回类型是`void`，它没有返回值，不能在赋值语句中进行赋值。注意，指针`pf`可以指向其他带`char *`类型参数、返回类型是`void`的函数，不能指向其他类型的函数。

既然可以用数据指针访问数据，也可以用函数指针访问函数。奇怪的是，有两种逻辑上不一致的语法可以这样做，下面解释：

C

```
void ToUpper(char *);
void ToLower(char *);
void (*pf)(char *);
char mis[] = "Nina Metier";

pf = ToUpper;
(*pf)(mis); // 把ToUpper 作用于（语法1）

pf = ToLower;
pf(mis); // 把ToLower 作用于（语法2）
```

这两种方法看上去都合情合理。先分析第1种方法：由于`pf`指向`ToUpper`函数，那么`*pf`就相当于`ToUpper`函数，所以表达式`(*pf)(mis)`和`ToUpper(mis)`相同。从`ToUpper`函数和`pf`的声明就能看出，`ToUpper`和`(*pf)`是等价的。第2种方法：由于函数名是指针，那么指针和函数名可以互换使用，所以`pf(mis)`和`ToUpper(mis)`相同。从`pf`的赋值表达式语句就能看出`ToUpper`和`pf`是等价的。由于历史的原因，贝尔实验室的C和UNIX的开发者采用第1种形式，而伯克利的UNIX推广者却采用第2种形式。K&R C不允许第2种形式。但是，为了与现有代码兼容，ANSI C认为这两种形式（本例中是`(*pf)(mis)`和`pf(mis)`）等价。后续的标准也延续了这种矛盾的和谐。

作为函数的参数是数据指针最常见的用法之一，函数指针亦如此。例如，考虑下面的函数原型：

C

```
void show(void (* fp)(char *), char * str);
```

这看上去让人头晕。它声明了两个形参：`fp`和`str`。`fp`形参是一个函数指针，`str`是一个数据指针。更具体地说，`fp`指向的函数接受`char *`类型的参数，其返回类型为`void`；`str`指向一个`char`类型的值。因此，假设有上面的声明，可以这样调用函数：

C

```
show(ToLower, mis); /* show()使用ToLower()函数：fp = ToLower */
show(pf, mis); /* show()使用pf指向的函数： fp = pf */
```

`show()`如何使用传入的函数指针？是用`fp()`语法还是`(*fp)()`语法调用函数：

C

```
void show(void (* fp)(char *), char * str)
{
    (*fp)(str); /* 把所选函数作用于str */
    puts(str); /* 显示结果 */
}
```

例如，这里的`show()`首先用`fp`指向的函数转换`str`，然后显示转换后的字符串。

顺带一提，把带返回值的函数作为参数传递给另一个函数有两种不同的方法。例如，考虑下面的语句：

C

```
function1(sqrt); /* 传递sqrt()函数的地址 */
function2(sqrt(4.0)); /* 传递sqrt()函数的返回值 */
```

第1条语句传递的是`sqrt()`函数的地址，假设`function1()`在其代码中会使用该函数。第2条语句先调用`sqrt()`函数，然后求值，并把返回值（该例中是`2.0`）传递给`function2()`。

**程序清单14.16　func_ptr.c 程序完整代码，使用函数指针实现字符串转换菜单：**

C

```
// func_ptr.c -- 使用函数指针
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#define LEN 81
char * s_gets(char * st, int n);
char showmenu(void);
void eatline(void); // 读取至行末尾
void show(void(*fp)(char *), char * str);
void ToUpper(char *); // 把字符串转换为大写
void ToLower(char *); // 把字符串转换为小写
void Transpose(char *); // 大小写转置
void Dummy(char *); // 不更改字符串

int main(void)
{
    char line[LEN];
    char copy[LEN];
    char choice;
    void(*pfun)(char *); // 声明一个函数指针，被指向的函数接受char *类型的参数，无返回值
    
    puts("Enter a string (empty line to quit):");
    while (s_gets(line, LEN) != NULL && line[0] != '\0')
    {
        while ((choice = showmenu()) != 'n')
        {
            switch (choice) // switch语句设置指针
            {
                case 'u': pfun = ToUpper; break;
                case 'l': pfun = ToLower; break;
                case 't': pfun = Transpose; break;
                case 'o': pfun = Dummy; break;
            }
            strcpy(copy, line); // 为show()函数拷贝一份
            show(pfun, copy); // 根据用户的选择，使用选定的函数
        }
        puts("Enter a string (empty line to quit):");
    }
    puts("Bye!");
    return 0;
}

char showmenu(void)
{
    char ans;
    puts("Enter menu choice:");
    puts("u) uppercase l) lowercase");
    puts("t) transposed case o) original case");
    puts("n) next string");
    ans = getchar(); // 获取用户的输入
    ans = tolower(ans); // 转换为小写
    eatline(); // 清理输入行
    while (strchr("ulton", ans) == NULL)
    {
        puts("Please enter a u, l, t, o, or n:");
        ans = tolower(getchar());
        eatline();
    }
    return ans;
}

void eatline(void)
{
    while (getchar() != '\n')
        continue;
}

void ToUpper(char * str)
{
    while (*str)
    {
        *str = toupper(*str);
        str++;
    }
}

void ToLower(char * str)
{
    while (*str)
    {
        *str = tolower(*str);
        str++;
    }
}

void Transpose(char * str)
{
    while (*str)
    {
        if (islower(*str))
            *str = toupper(*str);
        else if (isupper(*str))
            *str = tolower(*str);
        str++;
    }
}

void Dummy(char * str)
{
    // 不改变字符串
}

void show(void(*fp)(char *), char * str)
{
    (*fp)(str); // 把用户选定的函数作用于str
    puts(str); // 显示结果
}

char * s_gets(char * st, int n)
{
    char * ret_val;
    char * find;
    ret_val = fgets(st, n, stdin);
    if (ret_val)
    {
        find = strchr(st, '\n'); // 查找换行符
        if (find) // 如果地址不是NULL，
            *find = '\0'; // 在此处放置一个空字符
        else
            while (getchar() != '\n')
                continue; // 清理输入行中剩余的字符
    }
    return ret_val;
}
```

text

```
Enter a string (empty line to quit):
Does C make you feel loopy?
Enter menu choice:
u) uppercase l) lowercase
t) transposed case o) original case
n) next string
t
dOES c MAKE YOU FEEL LOOPY?
Enter menu choice:
u) uppercase l) lowercase
t) transposed case o) original case
n) next string
l
does c make you feel loopy?
Enter menu choice:
u) uppercase l) lowercase
t) transposed case o) original case
n) next string
n
Enter a string (empty line to quit):
Bye!
```

注意，`ToUpper()`、`ToLower()`、`Transpose()`和`Dummy()`函数的类型都相同，所以这4个函数都可以赋给`pfun`指针。该程序把`pfun`作为`show()`的参数，但是也可以直接把这4个函数中的任一个函数名作为参数，如`show(Transpose, copy)`。

这种情况下，可以使用`typedef`。例如，该程序中可以这样写：

C

```
typedef void (*V_FP_CHARP)(char *);
void show (V_FP_CHARP fp, char *);
V_FP_CHARP pfun;
```

如果还想更复杂一些，可以声明并初始化一个函数指针的数组：

C

```
V_FP_CHARP arpf[4] = {ToUpper, ToLower, Transpose, Dummy};
```

然后把`showmenu()`函数的返回类型改为`int`，如果用户输入`u`，则返回`0`；如果用户输入`l`，则返回`1`；如果用户输入`t`，则返回`2`，以此类推。可以把程序中的`switch`语句替换成下面的`while`循环：

C

```
index = showmenu();
while (index >= 0 && index <= 3)
{
    strcpy(copy, line); /* 为show()拷贝一份 */
    show(arpf[index], copy); /* 使用选定的函数 */
    index = showmenu();
}
```

虽然没有函数数组，但是可以有函数指针数组。

以上介绍了使用函数名的4种方法：定义函数、声明函数、调用函数和作为指针。图14.4进行了总结。

图14.4　函数名的用法

至于如何处理菜单，`showmenu()`函数给出了几种技巧。首先，下面的代码：

C

```
ans = getchar(); // 获取用户输入
ans = tolower(ans); // 转换成小写
```

和

C

```
ans = tolower(getchar());
```

演示了转换用户输入的两种方法。这两种方法都可以把用户输入的字符转换为一种大小写形式，这样就不用检测用户输入的是`'u'`还是`'U'`，等等。

`eatline()`函数丢弃输入行中的剩余字符，在处理这两种情况时很有用。第一，用户为了输入一个选择，输入一个字符，然后按下`Enter`键，将产生一个换行符。如果不处理这个换行符，它将成为下一次读取的第1个字符。第二，假设用户输入的是整个单词`uppercase`，而不是一个字母`u`。如果没有`eatline()`函数，程序会把`uppercase`中的字符作为用户的响应依次读取。有了`eatline()`，程序会读取`u`字符并丢弃输入行中剩余的字符。

其次，`showmenu()`函数的设计意图是，只给程序返回正确的选项。为完成这项任务，程序使用了`string.h`头文件中的标准库函数`strchr()`：

C

```
while (strchr("ulton", ans) == NULL)
```

该函数在字符串`"ulton"`中查找字符`ans`首次出现的位置，并返回一个指向该字符的指针。如果没有找到该字符，则返回空指针。因此，上面的`while`循环头可以用下面的`while`循环头代替，但是上面的用起来更方便：

C

```
while (ans != 'u' && ans != 'l' && ans != 't' && ans != 'o' && ans != 'n')
```

待检查的项越多，使用`strchr()`就越方便
### 14.15　关键概念

我们在编程中要表示的信息通常不只是一个数字或一些列数字。程序可能要处理具有多种属性的实体。例如，通过姓名、地址、电话号码和其他信息表示一名客户；或者，通过电影名、发行人、播放时长、售价等表示一部电影DVD。C结构可以把这些信息都放在一个单元内。在组织程序时这很重要，因为这样可以把相关的信息都储存在一处，而不是分散储存在多个变量中。

设计结构时，开发一个与之配套的函数包通常很有用。例如，写一个以结构（或结构的地址）为参数的函数打印结构内容，比用一堆`printf()`语句强得多。因为只需要一个参数就能打印结构中的所有信息。如果把信息放到零散的变量中，每个部分都需要一个参数。另外，如果要在结构中增加一个成员，只需重写函数，不必改写函数调用。这在修改结构时很方便。

联合声明与结构声明类似。但是，联合的成员共享相同的存储空间，而且在联合中同一时间内只能有一个成员。实质上，可以在联合变量中储存一个类型不唯一的值。

`enum`工具提供一种定义符号常量的方法，`typedef`工具提供一种为基本或派生类型创建新标识符的方法。

指向函数的指针提供一种告诉函数应使用哪一个函数的方法。

### 14.16　本章小结

C结构提供在相同的数据对象中储存多个不同类型数据项的方法。可以使用标记来标识一个具体的结构模板，并声明该类型的变量。通过成员点运算符（`.`）可以使用结构模版中的标签来访问结构的各个成员。

如果有一个指向结构的指针，可以用该指针和间接成员运算符（`->`）代替结构名和点运算符来访问结构的各成员。和数组不同，结构名不是结构的地址，要在结构名前使用`&`运算符才能获得结构的地址。

一贯以来，与结构相关的函数都使用指向结构的指针作为参数。现在的C允许把结构作为参数传递，作为返回值和同类型结构之间赋值。然而，传递结构的地址通常更有效。

联合使用与结构相同的语法。然而，联合的成员共享一个共同的存储空间。联合同一时间内只能储存一个单独的数据项，不像结构那样同时储存多种数据类型。也就是说，结构可以同时储存一个`int`类型数据、一个`double`类型数据和一个`char`类型数据，而相应的联合只能保存一个`int`类型数据，或者一个`double`类型数据，或者一个`char`类型数据。

通过枚举可以创建一系列代表整型常量（枚举常量）的符号和定义相关联的枚举类型。

`typedef`工具可用于建立C标准类型的别名或缩写。

函数名代表函数的地址，可以把函数的地址作为参数传递给其他函数，然后这些函数就可以使用被指向的函数。如果把特定函数的地址赋给一个名为`pf`的函数指针，可以通过以下两种方式调用该函数：

**以下是函数指针的两种调用方式示例：**

C

```
#include <math.h> /* 提供sin()函数的原型：double sin(double) */
...
double (*pdf)(double);
double x;
pdf = sin;
x = (*pdf)(1.2); // 调用sin(1.2)
x = pdf(1.2); // 同样调用 sin(1.2)
```