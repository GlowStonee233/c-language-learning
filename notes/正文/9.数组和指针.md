# 数组

数组由数据类型相同的一系列元素组成。需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型。编译器根据这些信息正确地创建数组。普通变量可以使用的类型，数组元素都可以用。要访问数组中的元素，通过使用数组下标数（也称为索引）表示数组中的各元素。数组元素的编号从 **0** 开始。

---

## 初始化数组

只储存单个值的变量有时也称为**标量变量**（scalar variable），我们已经很熟悉如何初始化这种变量。C使用新的语法来初始化数组，如下所示：

```c
int main(void)
{
    int powers[8] = {1, 2, 4, 6, 8, 16, 32, 64}; /* 从ANSI C开始支持这种初始化 */
    ...
}
```

如上所示，用以逗号分隔的值列表（用花括号括起来）来初始化数组，各值之间用逗号分隔。在逗号和值之间可以使用空格。根据上面的初始化，把 `1` 赋给数组的首元素（`powers[0]`），以此类推。

> **注意**：不支持 ANSI C 标准的编译器会把这种形式的初始化识别为语法错误。在数组声明前加上关键字 `static` 可解决此问题。

---

## 使用 const 声明数组
有时需要把数组设置为**只读**。这样，程序只能从数组中检索值，不能把新值写入数组。要创建只读数组，应该用 `const` 声明和初始化数组。例如：

```c
const int days[MONTHS] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
```

这样修改后，程序在运行过程中就不能修改该数组中的内容。和普通变量一样，应该使用声明来初始化 `const` 数据，因为一旦声明为 `const`，便不能再给它赋值。

---

## 重要注意事项

- **使用数组前必须先初始化它**
- 与普通变量类似，在使用数组元素之前，必须先给它们赋初值
- 未初始化的数组元素包含**不确定的值**（垃圾值），直接使用会导致不可预知的行为
## 数组的存储类别与初始化

### 存储类别

- **自动存储类别**：函数内部声明且未使用 `static` 关键字的数组
    - 未初始化时包含垃圾值
- **其他存储类别**：声明时未初始化会自动设为 0

### 初始化规则

#### 部分初始化

初始化列表项数**少于**数组元素时，剩余元素自动初始化为 0
```c
int arr[5] = {1, 2};  // arr[2]、arr[3]、arr[4] 均为 0
```

#### 过度初始化

初始化列表项数**多于**数组元素时，编译器报错

#### 自动计数

省略方括号中的数字，编译器根据初始化列表确定数组大小
```c
int days[] = {31, 28, 31, 30};  // 自动确定为 days[4]
```

**计算数组大小**：
```c
int size = sizeof(days) / sizeof(days[0]);
```

- `sizeof(days)`：整个数组的字节数
- `sizeof(days[0])`：单个元素的字节数

**注意**：自动计数虽然方便，但无法察觉初始化列表项数错误
## 指定初始化器（C99）

C99引入了**指定初始化器**（designated initializer）特性，允许直接初始化特定索引的数组元素，无需按顺序初始化所有前置元素。

---

### 基本用法对比

| 传统语法                                     | C99语法                                     |     |
| ---------------------------------------- | ----------------------------------------- | --- |
| `int arr[6] = {0, 0, 0, 0, 0, 212};`<br> | `int arr\[6] = { [5] = 212 }; // 仅初始化索引5` |     |
| 必须按顺序初始化所有前置元素                           | 可直接跳过中间元素指定特定位置                           |     |



> 💡 **重要特性**：未显式初始化的元素会自动置为 `0`

---

### 混合初始化示例

```c
#include <stdio.h>
#define MONTHS 12

int main(void) {
    int days[MONTHS] = { 31, 28, [4] = 31, 30, 31, [1] = 29 };
    for (int i = 0; i < MONTHS; i++)
        printf("%2d %d\n", i + 1, days[i]);
    return 0;
}
```

**输出结果**：

text

```
1 31
2 29
3 0
4 0
5 31
6 30
7 31
8 0
9 0
10 0
11 0
12 0
```

---

### 关键特性解析

#### 🔹 顺序继承规则

当指定初始化器后紧跟普通值时，这些值会**按顺序填充后续元素**。  
例如：`[4] = 31, 30, 31` 的执行顺序：

- `days[4] = 31`
- `days[5] = 30`
- `days[6] = 31`

#### 🔹 重复初始化覆盖

**后出现的初始化会覆盖先前的值**。  
示例中：

- 初始 `days[1] = 28`（来自普通初始化的第二个元素）
- 后续 `[1] = 29` 将其覆盖为 `29`

---

### 数组大小推断

当**未显式指定数组大小**时，编译器会自动根据初始化列表推断长度：
```c
int arr[] = { [5] = 212 }; // 自动推断为6元素数组（索引0~5）
```

> ✅ **规则**：数组长度 = 最大索引值 + 1  
> ✅ 未初始化的元素自动置为 `0`
## 给数组元素赋值

- 不能将整个数组作为单元赋值给另一个数组
- 除初始化外，**不能使用花括号列表形式赋值**
- 必须通过下标逐个赋值

```c
int arr[3];
arr[0] = 10; // 正确
arr[1] = 20;
// arr = {1, 2, 3}; // 错误：不能整体赋值
```

---

## 数组边界

- 编译器**不检查**数组下标是否越界
- 越界访问导致**未定义行为**（Undefined Behavior）：
    - 可能覆盖其他变量内存
    - 程序崩溃或产生不可预测结果
    - 不同编译器/平台表现可能完全不同
- 原因：C语言设计哲学是**信任程序员**，省去边界检查以提升性能
- 建议：
    - 使用符号常量定义数组大小
    - 循环中严格控制下标范围（`0` ~ `size-1`）
    - 使用静态分析工具辅助检测

> ⚠️ **关键提示**：数组元素从 **0** 开始编号  
> 例如 `int arr[5]` 的合法下标是 `0`~`4`，访问 `arr[5]` 即越界

---

## 指定数组的大小

### C99 之前

- 数组大小必须为**整型常量表达式**
- 合法示例：
 ```c
    int arr[10];               // 字面量常量
    #define SIZE 5
    int arr[SIZE];             // 宏替换后为常量
    int arr[sizeof(int)*10];   // sizeof 表达式
    ```

- **非法示例**：
 ```c
    const int n = 5;
    int arr[n]; // 错误：C99前 const 变量不是常量表达式
    ```
### C99 引入变长数组（VLA）

- 允许使用**运行时确定的非常量表达式**
- 示例：
    ```c
    int n;
    scanf("%d", &n);
    int arr[n]; // VLA：n 在运行时确定
    ```
- **重要限制**：
	- ❌ 不能初始化 VLA（如 `int arr[n] = {0};`）
	- C11 标准将 VLA 设为**可选特性**（编译器可不支持）
    - 仅适用于自动存储期的数组（局部变量）
---

## 多维数组
### 声明与访问

- 多维数组本质是**数组的数组**
- 示例：`float rain[5][12]` 表示 5 行 × 12 列的二维数组
- 访问规则：
    - `rain[0]`：第一个一维数组（12 个 float 元素）
    - `rain[0][0]`：第 0 行第 0 列的 float 值
    - `rain[1][2]`：第 1 行第 2 列的值（注意：行/列从 0 开始）

### 初始化二维数组

#### ✅ 推荐方式：嵌套花括号（清晰直观）

```c
const float rain[5][12] = {
    {4.3, 4.3, 4.3, 3.0, 2.0, 1.2, 0.2, 0.2, 0.4, 2.4, 3.5, 6.6},
    {8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9, 1.4, 7.3},
    {9.1, 8.5, 6.7, 4.3, 2.1, 0.8, 0.2, 0.2, 1.1, 2.3, 6.1, 8.4},
    {7.2, 9.9, 8.4, 3.3, 1.2, 0.8, 0.4, 0.0, 0.6, 1.7, 4.3, 6.2},
    {7.6, 5.6, 3.8, 2.8, 3.8, 0.2, 0.0, 0.0, 0.0, 1.3, 2.6, 5.2}
};
```

#### ⚠️ 省略内部花括号（需谨慎）

```c
const float rain[5][12] = {
    4.3, 4.3, 4.3, 3.0, 2.0, 1.2, 0.2, 0.2, 0.4, 2.4, 3.5, 6.6,
    8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9, 1.4, 7.3,
    // ... 其他数据
};
```
#### 初始化规则

|情况|结果|
|---|---|
|某行数据不足|剩余元素自动置 `0`|
|某行数据超限|编译错误|
|整体数据不足|按行顺序填充，剩余元素置 `0`|

 💡 **最佳实践**：使用符号常量定义维度
```c
#define YEARS 5
#define MONTHS 12
float rain[YEARS][MONTHS]; // 易维护，避免魔数
```
## 其他多维数组
前面讨论的二维数组的相关内容都适用于三维数组或更多维的数组。可以这样声明一个三维数组：
```c
int box[10][20][30];
```
通常，处理三维数组要使用3重嵌套循环，处理四维数组要使用4 重嵌套循环。对于其他多维数组，以此类推。在后面的程序示例中， 我们只使用二维数组。

# 指针和数组

指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。我们很快就会学到，数组表示法其实是在变相地使用指针。

我们举一个变相使用指针的例子：数组名是数组首元素的地址。也就是说，如果flizny是一个数组，下面的语句成立：
```c
// 数组名与首元素地址的关系
flizny == &flizny[0]; // 数组名是该数组首元素的地址
```

flizny和&flizny\[0]都表示数组首元素的内存地址（&是地址运算符）。两者都是常量，在程序的运行过程中，不会改变。但是，可以把它们赋值给指针变量，然后可以修改指针变量的值。

我们的系统中，地址按字节编址，short类型占用2字节，double类型占用8字节。在C中，指针加1指的是增加一个存储单元。对数组而言，这意味着加1后的地址是下一个元素的地址，而不是下一个字节的地址。只知道地址不够，因为计算机要知道储存对象需要多少字节（即使指针指向的是标量变量，也要知道变量的类型，否则*pt就无法正确地取回地址上的值。现在可以更清楚地定义指向int的指针、指向float的指针，以及指向其他数据对象的指针。

指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。许多计算机（包括PC和Macintosh）都是按字节编址，意思是内存中的每个字节都按顺序编号。这里，一个较大对象的地址（如double类型的变量）通常是该对象第一个字节的地址。

在指针前面使用*运算符可以得到该指针所指向对象的值。指针加1，指针的值递增它所指向类型的大小（以字节为单位）。下面的等式体现了C语言的灵活性：
```c
// 数组和指针的等价关系
dates + 2 == &dates[2]    // 相同的地址
*(dates + 2) == dates[2]  // 相同的值
```

以上关系表明了数组和指针的关系十分密切，可以使用指针标识数组的元素和获得元素的值。从本质上看，同一个对象有两种表示法。实际上，C语言标准在描述数组表示法时确实借助了指针。也就是说，定义ar\[n]的意思是*(ar + n)。可以认为*(ar + n)的意思是"到内存的ar位置，然后移动n个单元，检索储存在那里的值"。

顺带一提，不要混淆\*(dates+2)和\*dates+2。间接运算符\*的优先级高于+，所以\*dates+2相当于(\*dates)+2：

```c
// 运算符优先级示例
*(dates + 2)  // dates第3个元素的值
*dates + 2    // dates第1个元素的值加2
```

明白了数组和指针的关系，便可在编写程序时适时使用数组表示法或指针表示法。要注意的是，指针表示法和数组表示法是两种等效的方法。可以用指针表示数组，反过来，也可以用数组表示指针。在使用以数组为参数的函数时要注意这点。

**总结：** 数组名本质上是指向数组首元素的指针常量，数组表示法和指针表示法在C语言中是等价的，这种设计使得C语言在处理数组时更加灵活高效。
## 使用指针形参
函数要处理数组必须知道何时开始、何时结束。sum() 函数使用一个指针形参标识数组的开始，用一个整数形参表明待处理数组的元素个数（指针形参也表明了数组中的数据类型）。但是这并不是给函数传递必备信息的唯一方法。还有一种方法是传递两个指针，第1个指针指明数组的开始处（与前面用法相同），第2个指针指明数组的结束处。以下是演示：
```c
/* sum_arr2.c -- 数组元素之和 */
#include <stdio.h>
#define SIZE 10
int sump(int * start, int * end);
int main(void)
{
int marbles[SIZE] = { 20, 10, 5, 39, 4, 16, 19, 26, 31, 20 };
long answer;
answer = sump(marbles, marbles + SIZE);
printf("The total number of marbles is %ld.\n", answer);
return 0;
}
/* 使用指针算法 */
int sump(int * start, int * end)
{
int total = 0;
while (start < end)
{
total += *start; // 把数组元素的值加起来
start++; // 让指针指向下一个元素
}
return total;
}
```
注意，sump() 函数用另一种方法结束加法循环。sum() 函数把元素的个数作为第2 个参数，并把该参数作为循环测试的一部分：
```c
for( i = 0; i < n; i++)
```
而sump() 函数则使用第2 个指针来结束循环：
```c
while (start < end)
```
因为while 循环的测试条件是一个不相等的关系，所以循环最后处理的一个元素是end 所指向位置的前一个元素。这意味着end 指向的位置实际上在数组最后一个元素的后面。C保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。这使得while 循环的测试条件是有效的，因为start 在循环中最后的值是end。注意，使用这种“越界”指针的函数调用更为简洁：
```c
answer = sump(marbles, marbles + SIZE);
```
因为下标从0 开始，所以marbles + SIZE 指向数组末尾的下一个位置。如果end 指向数组的最后一个元素而不是数组末尾的下一个位置，则必须使用下面的代码：
```c
answer = sump(marbles, marbles + SIZE - 1);
```
这种写法既不简洁也不好记，很容易导致编程错误。顺带一提， 虽然C保证了marbles + SIZE 有效，但是对marbles\[SIZE] （即储存在该位置上的值）未作任何保证，所以程序不能访问该位置。
还可以把循环体压缩成一行代码：
```c
total += *start++;
```
一元运算符\*和++ 的优先级相同，但结合律是从右往左，所以 start++ 先求值，然后才是\*start 。也就是说，指针start 先递增后指向。使用后缀形式（即start++ 而不是++start ）意味着先把指针指向位置上的值加到total 上，然后再递增指针。如果使用 \*++start ，顺序则反过来，先递增指针，再使用指针指向位置上的值。如果使用(\*start)++ ，则先使用start 指向的值，再递增该值，而不是递增指针。这样，指针将一直指向同一个位置，但是该位置上的值发生了变化。虽然\*start++ 的写法比较常用，但是\* (start++) 这样写更清楚。
## 指针表示法和数组表示法
从以上分析可知，处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，可以选择是使用数组表示法还是指针表示法。使用数组表示法，让函数是处理数组的这一意图更加明显。另外，许多其他语言的程序员对数组表示法更熟悉，如 FORTRAN、Pascal、Modula-2或BASIC。其他程序员可能更习惯使用指针表示法，觉得使用指针更自然。

至于C语言，ar\[i] 和\*(ar+i) 这两个表达式都是等价的。无论 ar 是数组名还是指针变量，这两个表达式都没问题。但是，只有当 ar 是指针变量时，才能使用ar++ 这样的表达式。

指针表示法（尤其与递增运算符一起使用时）更接近机器语言， 因此一些编译器在编译时能生成效率更高的代码。然而，许多程序员认为他们的主要任务是确保代码正确、逻辑清晰，而代码优化应该留给编译器去做。

# 函数、数组和指针

假设要编写一个处理数组的函数，该函数返回数组中所有元素之和，待处理的是名为marbles的int类型数组。应该如何调用该函数？也许是下面这样：

```c
// 可能的函数调用
total = sum(marbles);
```

那么，该函数的原型是什么？记住，数组名是该数组首元素的地址，所以实际参数marbles是一个储存int类型值的地址，应把它赋给一个指针形式参数，即该形参是一个指向int的指针：

```c
// 对应的函数原型
int sum(int * ar);
```

sum()从该参数获得了什么信息？它获得了该数组首元素的地址，知道要在该位置上找出一个整数。注意，该参数并未包含数组元素个数的信息。我们有两种方法让函数获得这一信息。第一种方法是，在函数代码中写上固定的数组大小：

```c
// 相应的函数定义（固定大小版本）
int sum(int * ar)
{
    int i;
    int total = 0;
    for (i = 0; i < 10; i++)    // 假设数组有10个元素
        total += ar[i];         // ar[i] 与 *(ar + i) 相同
    return total;
}
```

该函数定义有限制，只能计算10个int类型的元素。另一个比较灵活的方法是把数组大小作为第2个参数：

```c
// 更通用的方法
int sum(int * ar, int n)
{
    int i;
    int total = 0;
    for (i = 0; i < n; i++)     // 使用 n 个元素
        total += ar[i];         // ar[i] 和 *(ar + i) 相同
    return total;
}
```

这里，第1个形参告诉函数该数组的地址和数据类型，第2个形参告诉函数该数组中元素的个数。

关于函数的形参，还有一点要注意。只有在函数原型或函数定义头中，才可以用int ar[]代替int \* ar：

```c
// 等价的函数原型声明
int sum (int ar[], int n);
```

int \*ar形式和int ar\[]形式都表示ar是一个指向int的指针。但是，int ar\[]只能用于声明形式参数。第2种形式（int ar\[]）提醒读者指针ar指向的不仅仅是一个int类型值，还是一个int类型数组的元素。

**总结：** 函数无法直接接收数组，只能接收指向数组首元素的指针，因此需要额外的参数来传递数组大小信息。

## 声明数组形参
因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。只有在这种情况下，C才会把int ar[]和int * ar解释成一样。也就是说，ar是指向int的指针。由于函数原型可以省略参数名，所以下面4种原型都是等价的：

```c
// 四种等价的函数原型
int sum(int *ar, int n);    // 指针形式，带参数名
int sum(int *, int);        // 指针形式，省略参数名
int sum(int ar[], int n);   // 数组形式，带参数名
int sum(int [], int);       // 数组形式，省略参数名
```

但是，在函数定义中不能省略参数名。下面两种形式的函数定义等价：

```c
// 两种等价的函数定义形式
int sum(int *ar, int n)
{
    // 其他代码已省略
}

int sum(int ar[], int n)
{
    // 其他代码已省略
}
```

可以使用以上提到的任意一种函数原型和函数定义。

**总结：** 在函数参数声明中，数组形式和指针形式是完全等价的，编译器会将数组参数转换为指针参数。

## 使用指针形参

函数要处理数组必须知道何时开始、何时结束。sum()函数使用一个指针形参标识数组的开始，用一个整数形参表明待处理数组的元素个数（指针形参也表明了数组中的数据类型）。但是这并不是给函数传递必备信息的唯一方法。还有一种方法是传递两个指针，第1个指针指明数组的开始处（与前面用法相同），第2个指针指明数组的结束处。以下是演示：

```c
/* sum_arr2.c -- 数组元素之和 */
#include <stdio.h>
#define SIZE 10

// 函数原型：使用两个指针参数
int sump(int * start, int * end);

int main(void)
{
    // 初始化数组
    int marbles[SIZE] = { 20, 10, 5, 39, 4, 16, 19, 26, 31, 20 };
    long answer;
    
    // 调用函数，传递数组开始和结束位置
    answer = sump(marbles, marbles + SIZE);
    printf("The total number of marbles is %ld.\n", answer);
    
    return 0;
}

/* 使用指针算法 */
int sump(int * start, int * end)
{
    int total = 0;
    
    // 循环直到start指针到达end位置
    while (start < end)
    {
        total += *start;    // 把数组元素的值加起来
        start++;            // 让指针指向下一个元素
    }
    
    return total;
}
```

注意，sump()函数用另一种方法结束加法循环。sum()函数把元素的个数作为第2个参数，并把该参数作为循环测试的一部分：

```c
// sum()函数的循环方式
for( i = 0; i < n; i++)
```

而sump()函数则使用第2个指针来结束循环：

```c
// sump()函数的循环方式
while (start < end)
```

因为while循环的测试条件是一个不相等的关系，所以循环最后处理的一个元素是end所指向位置的前一个元素。==这意味着end指向的位置实际上在数组最后一个元素的后面。C保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针(只能保证这一个)。==这使得while循环的测试条件是有效的，因为start在循环中最后的值是end。注意，使用这种"越界"指针的函数调用更为简洁：

```c
// 简洁的函数调用
answer = sump(marbles, marbles + SIZE);
```

因为下标从0开始，所以marbles + SIZE指向数组末尾的下一个位置。如果end指向数组的最后一个元素而不是数组末尾的下一个位置，则必须使用下面的代码：

```c
// 如果end指向最后一个元素（不推荐）
answer = sump(marbles, marbles + SIZE - 1);
```

这种写法既不简洁也不好记，很容易导致编程错误。顺带一提，虽然C保证了marbles + SIZE有效，但是对marbles\[SIZE]（即储存在该位置上的值）未作任何保证，所以程序不能访问该位置。

还可以把循环体压缩成一行代码：

```c
// 压缩的循环体
total += *start++;
```

一元运算符\*和++的优先级相同，但结合律是从右往左，所以start++先求值，然后才是\*start。也就是说，指针start先递增后指向。使用后缀形式（即start++而不是++start）意味着先把指针指向位置上的值加到total上，然后再递增指针。如果使用\*++start，顺序则反过来，先递增指针，再使用指针指向位置上的值。如果使用(\*start)++，则先使用start指向的值，再递增该值，而不是递增指针。这样，指针将一直指向同一个位置，但是该位置上的值发生了变化。虽然_start++的写法比较常用，但是*(start++)这样写更清楚。

**总结：** 使用两个指针参数的方法提供了另一种处理数组的方式，这种方法在C标准库中被广泛使用，特别是在字符串处理函数中。

## 指针表示法和数组表示法

从以上分析可知，处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，可以选择是使用数组表示法还是指针表示法。使用数组表示法，让函数是处理数组的这一意图更加明显。另外，许多其他语言的程序员对数组表示法更熟悉，如FORTRAN、Pascal、Modula-2或BASIC。其他程序员可能更习惯使用指针表示法，觉得使用指针更自然。

至于C语言，ar\[i]和*(ar+i)这两个表达式都是等价的。无论ar是数组名还是指针变量，这两个表达式都没问题。但是，只有当ar是指针变量时，才能使用ar++这样的表达式。

指针表示法（尤其与递增运算符一起使用时）更接近机器语言，因此一些编译器在编译时能生成效率更高的代码。然而，许多程序员认为他们的主要任务是确保代码。

# 指针操作
C提供了一些基本的指针操作，下面的程序示例中演示了8种不同的操作。为了显示每种操作的结果，该程序打印了指针的值（该指针指向的地址）、储存在指针指向地址上的值，以及指针自己的地址。除了这些操作， 还可以使用关系运算符来比较指针。
```c
// ptr_ops.c -- 指针操作
#include <stdio.h>
int main(void)
{
int urn[5] = { 100, 200, 300, 400, 500 };
int * ptr1, *ptr2, *ptr3;
ptr1 = urn; // 把一个地址赋给指针
ptr2 = &urn[2]; // 把一个地址赋给指针
// 解引用指针，以及获得指针的地址
printf("pointer value, dereferenced pointer, pointer
address:\n");
printf("ptr1 = %p, *ptr1 =%d, &ptr1 = %p\n", ptr1, *ptr1,
&ptr1);
// 指针加法
ptr3 = ptr1 + 4;
printf("\nadding an int to a pointer:\n");
printf("ptr1 + 4 = %p, *(ptr1 + 4) = %d\n", ptr1 + 4, *(ptr1 +
4));
ptr1++; // 递增指针
printf("\nvalues after ptr1++:\n");
printf("ptr1 = %p, *ptr1 =%d, &ptr1 = %p\n", ptr1, *ptr1,
&ptr1);
ptr2--; // 递减指针
printf("\nvalues after --ptr2:\n");
printf("ptr2 = %p, *ptr2 = %d, &ptr2 = %p\n", ptr2, *ptr2,
&ptr2);
--ptr1; // 恢复为初始值
++ptr2; // 恢复为初始值
printf("\nPointers reset to original values:\n");
printf("ptr1 = %p, ptr2 = %p\n", ptr1, ptr2);
// 一个指针减去另一个指针
printf("\nsubtracting one pointer from another:\n");
printf("ptr2 = %p, ptr1 = %p, ptr2 - ptr1 = %td\n", ptr2,
ptr1, ptr2 - ptr1);
// 一个指针减去一个整数
printf("\nsubtracting an int from a pointer:\n");
printf("ptr3 = %p, ptr3 - 2 = %p\n", ptr3, ptr3 - 2);
return 0;
}
```
下面是我们的系统运行该程序后的输出：
```c
pointer value, dereferenced pointer, pointer address:
ptr1 = 0x7fff5fbff8d0, *ptr1 =100, &ptr1 = 0x7fff5fbff8c8
adding an int to a pointer:
ptr1 + 4 = 0x7fff5fbff8e0, *(ptr1 + 4) = 500
values after ptr1++:
ptr1 = 0x7fff5fbff8d4, *ptr1 =200, &ptr1 = 0x7fff5fbff8c8
values after --ptr2:
ptr2 = 0x7fff5fbff8d4, *ptr2 = 200, &ptr2 = 0x7fff5fbff8c0
Pointers reset to original values:
ptr1 = 0x7fff5fbff8d0, ptr2 = 0x7fff5fbff8d8
subtracting one pointer from another:
ptr2 = 0x7fff5fbff8d8, ptr1 = 0x7fff5fbff8d0, ptr2 - ptr1 = 2
subtracting an int from a pointer:
ptr3 = 0x7fff5fbff8e0, ptr3 - 2 = 0x7fff5fbff8d8
```
下面分别描述了指针变量的基本操作。

**赋值**： 可以把地址赋给指针。例如，用数组名、带地址运算符 （& ）的变量名、另一个指针进行赋值。在该例中，把urn 数组的首地址赋给了ptr1 ，该地址的编号恰好是0x7fff5fbff8d0 。变量ptr2 获得数组urn 的第3个元素（urn\[2] ）的地址。注意，地址应该和指针类型兼容。也就是说，不能把double 类型的地址赋给指向int 的指针，至少要避免不明智的类型转换。 C99/C11已经强制不允许这样做。

**解引用**： \*运算符给出指针指向地址上储存的值。因此，\*ptr1 的初值是100 ，该值储存在编号为0x7fff5fbff8d0 的地址上。

**取址**： 和所有变量一样，指针变量也有自己的地址和值。对指针而言，& 运算符给出指针本身的地址。本例中，ptr1 储存在内存编号为0x7fff5fbff8c8 的地址上，该存储单元储存的内容是0x7fff5fbff8d0 ，即urn 的地址。因此&ptr1 是指向 ptr1 的指针，而ptr1 是指向utn\[0] 的指针。

**指针与整数相加**： 可以使用+ 运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小 （以字节为单位）相乘，然后把结果与初始地址相加。因此ptr1 + 4 与&urn\[4] 等价。如果相加的结果超出了初始指针指向的数组范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。

**递增指针**： 递增指向数组元素的指针可以让该指针移动至数组的下一个元素。因此，ptr1++ 相当于把ptr1 的值加上4 （我们的系统中int 为4 字节），ptr1 指向urn\[1] （见图10.4，该图中使用了简化的地址）。现在ptr1 的值是0x7fff5fbff8d4 （数组的下一个元素的地址），\*ptr 的值为200 （即urn\[1] 的值）。注意，ptr1 本身的地址仍是0x7fff5fbff8c8 。毕竟，变量不会因为值发生变化就移动位置。

**指针减去一个整数**： 可以使用- 运算符从一个指针中减去一个整数。指针必须是第1个运算对象，整数是第2个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。所以ptr3 - 2 与&urn\[2] 等价，因为ptr3 指向的是&urn\[4] 。如果相减的结果超出了初始指针所指向数组的范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。

**指针求差**： 可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。例如，程序清单10.13的输出中，ptr2 - ptr1 得2 ，意思是这两个指针所指向的两个元素相隔两个int ，而不是2 字节。只要两个指针都指向相同的数组（或者其中一个指针指向数组后面的第1个地址），C都能保证相减运算有效。如果指向两个不同数组的指针进行求差运算可能会得出一个值，或者导致运行时错误。

**比较**： 使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。
注意，这里的减法有两种。可以用一个指针减去另一个指针得到一个整数，或者用一个指针减去一个整数得到另一个指针。

在递增或递减指针时还要注意一些问题。编译器不会检查指针是否仍指向数组元素。C只能保证指向数组任意元素的指针和指向数组后面第1个位置的指针有效。但是，如果递增或递减一个指针后超出了这个范围，则是未定义的。另外，可以解引用指向数组任意元素的指针。但是，即使指针指向数组后面一个位置是有效的，也能解引用这样的越界指针。
## 解引用未初始化的指针
说到注意事项，一定要牢记一点：千万不要解引用未初始化的指针。例如，考虑下面的例子：
```c
int * pt; // 未初始化的指针
*pt = 5; // 严重的错误
```
为何不行？第2行的意思是把5储存在pt 指向的位置。但是pt 未被初始化，其值是一个随机值，所以不知道5将储存在何处。这可能不会出什么错，也可能会擦写数据或代码， 或者导致程序崩溃。切记：创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。因此，在使用指针之前，必须先用已分配的地址初始化它。例如，可以用一个现有变量的地址初始化该指针（使用带指针形参的函数时，就属于这种情况）。或者还可以使malloc() 函数先分配内存。无论如何，使用指针时一定要注意，不要解引用未初始化的指针！
```c
double * pd; // 未初始化的指针
*pd = 2.4; // 不要这样做
```
假设
```c
int urn[3];
int * ptr1, * ptr2;
```
下面是一些有效和无效的语句：
```
有效语句           无效语句
ptr1++;           urn++;
ptr2 = ptr1 + 2;  ptr2 = ptr2 + ptr1;
ptr2 = urn + 1;   ptr2 = urn * ptr1;
```
基于这些有效的操作，C程序员创建了指针数组、函数指针、指向指针的指针数组、指向函数的指针数组等。别紧张，接下来我们将根据已学的内容介绍指针的一些基本用法。指针的第1个基本用法是在函数间传递信息。前面学过，如果希望在被调函数中改变主调函数的变量，必须使用指针。指针的第2个基本用法是用在处理数组的函数中。下面我们再来看一个使用函数和数组的编程示例。
# 保护数组中的数据
编写一个处理基本类型（如，int ）的函数时，要选择是传递 int 类型的值还是传递指向int 的指针。通常都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针。对于数组别无选择，必须传递指针，因为这样做效率高。如果一个函数按值传递数组，则必须分配足够的空间来储存原数组的副本，然后把原数组所有的数据拷贝至新的数组中。如果把数组的地址传递给函数，让函数直接处理原数组则效率要高。

传递地址会导致一些问题。C通常都按值传递数据，因为这样做可以保证数据的完整性。如果函数使用的是原始数据的副本，就不会意外修改原始数据。但是，处理数组的函数通常都需要使用原始数据，因此这样的函数可以修改原数组。有时，这正是我们需要的。例如，下面的函数给数组的每个元素都加上一个相同的值;
```c
void add_to(double ar[], int n, double val)
{
int i;
for (i = 0; i < n; i++)
ar[i] += val;
}
```
因此，调用该函数后，prices 数组中的每个元素的值都增加了 2.5 ：
```c
add_to(prices, 100, 2.50);
```
该函数修改了数组中的数据。之所以可以这样做，是因为函数通过指针直接使用了原始数据。
然而，其他函数并不需要修改数据。例如，下面的函数计算数组中所有元素之和，它不用改变数组的数据。但是，由于ar 实际上是一个指针，所以编程错误可能会破坏原始数据。例如，下面示例中的 ar\[i]++ 会导致数组中每个元素的值都加1 ：
```c
int sum(int ar[], int n) // 错误的代码
{
int i;
int total = 0;
for( i = 0; i < n; i++)
total += ar[i]++; // 错误递增了每个元素的值
return total;
}
```
## 对形式参数使用const
在K&R C的年代，避免类似错误的唯一方法是提高警惕。ANSI C 提供了一种预防手段。如果函数的意图不是修改数组中的数据内容， 那么在函数原型和函数定义中声明形式参数时应使用关键字const 。例如，sum() 函数的原型和定义如下：
```c
int sum(const int ar[], int n); /* 函数原型 */
int sum(const int ar[], int n) /* 函数定义 */
{
int i;
int total = 0;
for( i = 0; i < n; i++)
total += ar[i];
return total;
}
```
以上代码中的const 告诉编译器，该函数不能修改ar 指向的数组中的内容。如果在函数中不小心使用类似ar\[i]++ 的表达式，编译器会捕获这个错误，并生成一条错误信息。

这里一定要理解，这样使用const 并不是要求原数组是常量，而是该函数在处理数组时将其视为常量，不可更改。这样使用const 可以保护数组的数据不被修改，就像按值传递可以保护基本数据类型的原始值不被改变一样。一般而言，如果编写的函数需要修改数组，在声明数组形参时则不使用const ；如果编写的函数不用修改数组，那么在声明数组形参时最好使用const 
## const 的其他内容
我们在前面使用const 创建过变量：
```c
const double PI = 3.14159;
```
虽然用#define 指令可以创建类似功能的符号常量，但是const 的用法更加灵活。可以创建const 数组、const 指针和指向const 的指针。
以下程序演示了如何使用const 关键字保护数组：
```c
#define MONTHS 12
...
const int days[MONTHS] = {31,28,31,30,31,30,31,31,30,31,30,31};
```
如果程序稍后尝试改变数组元素的值，编译器将生成一个编译期错误消息。
指向const 的指针不能用于改变值。考虑下面的代码：
```c
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double * pd = rates; // pd指向数组的首元素
```
第2行代码把pd 指向的double 类型的值声明为const ，这表明不能使用pd 来更改它所指向的值：
```c
*pd = 29.89; // 不允许
pd[2] = 222.22; // 不允许
rates[0] = 99.99; // 允许，因为rates未被const限定
```
无论是使用指针表示法还是数组表示法，都不允许使用pd 修改它所指向数据的值。但是要注意，因为rates 并未被声明为const ， 所以仍然可以通过rates 修改元素的值。另外，可以让pd 指向别处：
```c
pd++; /* 让pd指向rates[1] -- 没问题 */
```
指向const 的指针通常用于函数形参中，表明该函数不会使用指针改变数据。

关于指针赋值和const 需要注意一些规则。首先，把const 数据或非const 数据的地址初始化为指向const 的指针或为其赋值是合法的：
```c
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double locked[4] = {0.08, 0.075, 0.0725, 0.07};
const double * pc = rates; // 有效
pc = locked; // 有效
pc = &rates[3]; // 有效
```
然而，只能把非const 数据的地址赋给普通指针：
```c
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double locked[4] = {0.08, 0.075, 0.0725, 0.07};
double * pnc = rates; // 有效
pnc = locked; // 无效
pnc = &rates[3]; // 有效
```
这个规则非常合理。否则，通过指针就能改变const 数组中的数据。
应用以上规则的例子，如show_array() 函数可以接受普通数组名和const 数组名作为参数，因为这两种参数都可以用来初始化指向 const 的指针：
```c
show_array(rates, 5); // 有效
show_array(locked, 4); // 有效
```
因此，对函数的形参使用const 不仅能保护数据，还能让函数处理const 数组。另外，不应该把const 数组名作为实参传递给mult_array() 这样的函数：
```c
mult_array(rates, 5, 1.2); // 有效 
mult_array(locked, 4, 1.2); // 不要这样做
```
C标准规定，使用非const 标识符（如，mult_arry() 的形参 ar ）修改const 数据（如，locked ）导致的结果是未定义的。
const 还有其他的用法。例如，可以声明并初始化一个不能指向别处的指针，关键是const 的位置：
```c
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
double * const pc = rates; // pc指向数组的开始
pc = &rates[2]; // 不允许，因为该指针不能指向别处
*pc = 92.99; // 没问题 -- 更改rates[0]的值
```
可以用这种指针修改它所指向的值，但是它只能指向初始化时设置的地址。
最后，在创建指针时还可以使用const 两次，该指针既不能更改它所指向的地址，也不能修改指向地址上的值：
```c
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double * const pc = rates;
pc = &rates[2]; //不允许
*pc = 92.99; //不允许
```
# 指针和多维数组
假设有下面的声明：
```c
int zippo[4][2]; /* 内含int数组的数组 */
```
然后数组名zippo 是该数组首元素的地址。在本例中，zippo 的首元素是一个内含两个int 值的数组，所以zippo 是这个内含两个 int 值的数组的地址。下面，我们从指针的属性进一步分析。
因为zippo 是数组首元素的地址，所以zippo 的值和 &zippo\[0] 的值相同。而zippo\[0] 本身是一个内含两个整数的数组，所以zippo\[0] 的值和它首元素（一个整数）的地址 （即&zippo\[0]\[0] 的值）相同。简而言之，zippo\[0] 是一个占用一个int 大小对象的地址，而zippo 是一个占用两个int 大小对象的地址。==由于这个整数和内含两个整数的数组都开始于同一个地址，所以zippo 和zippo\[0] 的值相同。==（**核心思想：数组 = 首地址 + 类型信息**）

给指针或地址加1 ，其值会增加对应类型大小的数值。在这方面，zippo 和zippo\[0] 不同，因为zippo 指向的对象占用了两个int 大小，而zippo\[0] 指向的对象只占用一个int 大小。因此，zippo + 1 和zippo\[0] + 1 的值不同。

解引用一个指针（在指针前使用\*运算符）或在数组名后使用带下标的\[]运算符，得到引用对象代表的值。因为zippo\[0] 是该数组首元素（zippo\[0]\[0] ）的地址，所以\*(zippo\[0]) 表示储存在zippo\[0]\[0] 上的值（即一个int 类型的值）。与此类似，\*zippo 代表该数组首元素（zippo\[0] ）的值，但是 zippo\[0] 本身是一个int 类型值的地址。该值的地址是 &zippo\[0]\[0] ，所以\*zippo 就是&zippo\[0]\[0] 。对两个表达式应用解引用运算符表明，\*\*zippo 与*&zippo\[0]\[0] 等价，这相当于zippo\[0]\[0] ，即一个int 类型的值。简而言之，zippo 是地址的地址，必须解引用两次才能获得原始值。地址的地址或指针的指针是就是双重间接 （double indirection ）的例子。
显然，增加数组维数会增加指针的复杂度。现在，大部分初学者都开始意识到指针为什么是C 语言中最难的部分。
下面的程序使用了部分性质：
```c
/* zippo1.c -- zippo的相关信息 */
#include <stdio.h>
int main(void)
{
int zippo[4][2] = { { 2, 4 }, { 6, 8 }, { 1, 3 }, { 5, 7 } };
printf(" zippo = %p, zippo + 1 = %p\n",zippo, zippo + 1);
printf("zippo[0] = %p, zippo[0] + 1 = %p\n",zippo[0], zippo[0]
+ 1);
printf(" *zippo = %p, *zippo + 1 = %p\n",*zippo, *zippo +
1);
printf("zippo[0][0] = %d\n", zippo[0][0]);
printf(" *zippo[0] = %d\n", *zippo[0]);
printf(" **zippo = %d\n", **zippo);
printf(" zippo[2][1] = %d\n", zippo[2][1]);
printf("*(*(zippo+2) + 1) = %d\n", *(*(zippo + 2) + 1));
return 0;
}
```
下面是我们的系统运行该程序后的输出：
```c
zippo = 0x0064fd38, zippo + 1 = 0x0064fd40
zippo[0]= 0x0064fd38, zippo[0] + 1 = 0x0064fd3c
*zippo = 0x0064fd38, *zippo + 1 = 0x0064fd3c
zippo[0][0] = 2
*zippo[0] = 2
**zippo = 2
zippo[2][1] = 3
*(*(zippo+2) + 1) = 3
```
其他系统显示的地址值和地址形式可能不同，但是地址之间的关系与以上输出相同。该输出显示了二维数组zippo 的地址和一维数组 zippo\[0] 的地址相同。它们的地址都是各自数组首元素的地址，因而与&zippo\[0]\[0] 的值也相同。
尽管如此，它们也有差别。在我们的系统中，int 是4字节。前面讨论过，zippo\[0] 指向一个4字节的数据对象。zippo\[0] 加1 ，其值加4 （十六进制中，38+4 得3c ）。数组名zippo 是一个内含 2个int 类型值的数组的地址，所以zippo 指向一个8字节的数据对象。因此，zippo 加1 ，它所指向的地址加8字节（十六进制中， 38+8 得40 ）。
该程序演示了zippo\[0] 和\*zippo 完全相同，实际上确实如此。然后，对二维数组名解引用两次，得到储存在数组中的值。使用两个间接运算符（\*）或者使用两对方括号（\[] ）都能获得该值（还可以使用一个\*和一对\[] ，但是我们暂不讨论这么多情况）。
要特别注意，与zippo\[2]\[1] 等价的指针表示法是\* (\* (zippo+2) + 1) 。看上去比较复杂，应最好能理解。下面列出了理解该表达式的思路：
```c
zippo //二维数组首元素的地址（每个元素都是内含两个int类型元素的
一维数组）
zippo+2 //二维数组的第3个元素（即一维数组）的地址
*(zippo+2) //二维数组的第3个元素（即一维数组）的首元素（一个int类型的
值）地址
*(zippo+2) + 1 //二维数组的第3个元素（即一维数组）的第2个元素（也是一个
int类型的值）地址
*(*(zippo+2) + 1) /*二维数组的第3个一维数组元素的第2个int类型元素的值，即数组的第3行第2列的值（zippo[2][1]）*/
```
以上分析并不是为了说明用指针表示法（\* (\* (zippo+2) + 1) ）代替数组表示法（zippo\[2]\[1] ），而是提示读者，如果程序恰巧使用一个指向二维数组的指针，而且要通过该指针获取值时，最好用简单的数组表示法，而不是指针表示法。
## 总结：指针操作的黄金法则

1. **二维数组 = 一维数组的数组**：
    
    - `zippo` 是指向第一行的指针
    - `zippo[0]` 是第一行的数组名（也是指向第一个元素的指针）
2. **指针加法差异**：
    
    - `zippo + 1`：跳过整个行（增加 `2 * sizeof(int)`）
    - `zippo[0] + 1`：跳过一个元素（增加 `sizeof(int)`）
3. **解引用层级**：
    
    - 单次解引用 (`*`)：得到一行
    - 双重解引用 (`**`)：得到一个元素
4. **等价表达式**：
  ```c
    zippo[i][j] ≡ *(*(zippo + i) + j)
    ```
    
通过这个例子，你可以看到C语言指针的强大功能——能够灵活地操作多维数组，但这也正是其复杂性所在。理解这些指针操作是精通C语言的关键一步

## 多维数组的递归规律

多维数组遵循递归的"降维"规律：

### 三维数组示例

```c
int arr[2][3][4];  // 2个"平面"，每个平面3行4列
```

#### 类型递归关系

```c
arr          → int (*)[3][4]    // 指向"3×4数组"的指针
arr[0]       → int (*)[4]       // 指向"4元素数组"的指针
arr[0][0]    → int *            // 指向int的指针
arr[0][0][0] → int              // int值
```

#### 指针加法差异

```c
arr + 1        // 跳过 3×4 = 12 个int（跳过整个平面）
arr[0] + 1     // 跳过 4 个int（跳过一行）
arr[0][0] + 1  // 跳过 1 个int（跳过一个元素）
```

#### 解引用层级

```c
*arr           // 得到第一个"平面"（3×4数组）
**arr          // 得到第一"行"（4元素数组）
***arr         // 得到第一个元素（int值）
```
#### 等价表达式

```c
arr[i][j][k] ≡ *(*(*(arr + i) + j) + k)
```
### N维数组通用规律

#### 黄金法则

| 维度  | 数组声明           | 等价指针表达式                        | 解引用次数   |
| --- | -------------- | ------------------------------ | ------- |
| 1   | `a[i]`         | `*(a + i)`                     | 1次 → 元素 |
| 2   | `a[i][j]`      | `*(*(a + i) + j)`              | 2次 → 元素 |
| 3   | `a[i][j][k]`   | `*(*(*(a + i) + j) + k)`       | 3次 → 元素 |
| N   | `a[i₁]...[iₙ]` | `*(*(... *(a + i₁) ...) + iₙ)` | N次 → 元素 |

#### 递归降维规律

```c
// 四维数组示例
int matrix[2][3][4][5];

matrix           // int (*)[3][4][5]  - 4维指针
matrix[0]        // int (*)[4][5]     - 3维指针  
matrix[0][1]     // int (*)[5]        - 2维指针
matrix[0][1][2]  // int *             - 1维指针
matrix[0][1][2][3] // int             - 值
```

#### 内存跳跃公式

```c
// N维数组 a[d₁][d₂]...[dₙ]
a + 1              // 跳过 d₂ × d₃ × ... × dₙ 个元素
(a[i]) + 1         // 跳过 d₃ × d₄ × ... × dₙ 个元素
(a[i][j]) + 1      // 跳过 d₄ × d₅ × ... × dₙ 个元素
```
### 核心本质
```
N维数组 = (N-1)维数组的数组
```

**递归定义：**

- 三维数组 = 二维数组的数组
- 二维数组 = 一维数组的数组
- 一维数组 = 元素的数组

每增加一层下标 `[i]`，就进行一次：

1. **指针偏移** `+i`
2. **解引用** `*`
3. **降低一维**

这个规律在所有维度都成立。
## 指向多维数组的指针
如何声明一个指针变量pz 指向一个二维数组（如，zippo ）？ 在编写处理类似zippo 这样的二维数组时会用到这样的指针。把指针声明为指向int 的类型还不够。因为指向int 只能与zippo\[0] 的类型匹配，说明该指针指向一个int 类型的值。但是zippo 是它首元素的地址，该元素是一个内含两个int 类型值的一维数组。因此，pz 必须指向一个内含两个int 类型值的数组，而不是指向一个int 类型值，其声明如下：
```c
int (* pz)[2]; // pz指向一个内含两个int类型值的数组
```
以上代码把pz 声明为指向一个数组的指针，该数组内含两个int 类型值。为什么要在声明中使用圆括号？因为\[] 的优先级高于\*。考虑下面的声明：
```c
int * pax[2]; // pax是一个内含两个指针元素的数组，每个元素都指向int的指针
```
由于\[] 优先级高，先与pax 结合，所以pax 成为一个内含两个元素的数组。然后\*表示pax 数组内含两个指针。最后，int 表示 pax 数组中的指针都指向int 类型的值。因此，这行代码声明了两个指向int 的指针。而前面有圆括号的版本，\*先与pz 结合，因此声明的是一个指向数组（内含两个int 类型的值）的指针。以下程序演示了如何使用指向二维数组的指针。
```c
/* zippo2.c -- 通过指针获取zippo的信息 */
#include <stdio.h>
int main(void)
{
int zippo[4][2] = { { 2, 4 }, { 6, 8 }, { 1, 3 }, { 5, 7 } };
int(*pz)[2];
pz = zippo;
printf(" pz = %p, pz + 1 = %p\n", pz, pz + 1);
printf("pz[0] = %p, pz[0] + 1 = %p\n", pz[0], pz[0] + 1);
printf(" *pz = %p, *pz + 1 = %p\n", *pz, *pz + 1);
printf("pz[0][0] = %d\n", pz[0][0]);
printf(" *pz[0] = %d\n", *pz[0]);
printf(" **pz = %d\n", **pz);
printf(" pz[2][1] = %d\n", pz[2][1]);
printf("*(*(pz+2) + 1) = %d\n", *(*(pz + 2) + 1));
return 0;
}
```
下面是该程序的输出：
```
pz = 0x0064fd38,    pz + 1 = 0x0064fd40
pz[0] = 0x0064fd38, pz[0] + 1 = 0x0064fd3c
*pz = 0x0064fd38,  *pz + 1 = 0x0064fd3c
pz[0][0] = 2
*pz[0] = 2
**pz = 2
pz[2][1] = 3
*(*(pz+2) + 1) = 3
```
系统不同，输出的地址可能不同，但是地址之间的关系相同。如前所述，虽然pz 是一个指针，不是数组名，但是也可以使用pz\[2] \[1] 这样的写法。可以用数组表示法或指针表示法来表示一个数组元素，既可以使用数组名，也可以使用指针名：
```c
zippo[m][n] == *(*(zippo + m) + n) 
pz[m][n] == *(*(pz + m) + n)
```
## 指针的兼容性
指针之间的赋值比数值类型之间的赋值要严格。例如，不用类型转换就可以把int 类型的值赋给double 类型的变量，但是两个类型的指针不能这样做。
```c
int n = 5;
double x;
int * p1 = &n;
double * pd = &x;
x = n; // 隐式类型转换
pd = p1; // 编译时错误
```
更复杂的类型也是如此。假设有如下声明：
```c
int * pt;
int (*pa)[3];
int ar1[2][3];
int ar2[3][2];
int **p2; // 一个指向指针的指针
```
有如下的语句：
```c
pt = &ar1[0][0]; // 都是指向int的指针
pt = ar1[0]; // 都是指向int的指针
pt = ar1; // 无效
pa = ar1; // 都是指向内含3个int类型元素数组的指针
pa = ar2; // 无效
p2 = &pt; // both pointer-to-int *
*p2 = ar2[0]; // 都是指向int的指针
p2 = ar2; // 无效
```
注意，以上无效的赋值表达式语句中涉及的两个指针都是指向不同的类型。例如，pt 指向一个int 类型值，而ar1 指向一个内含3个 int 类型元素的数组。类似地，pa 指向一个内含3个int 类型元素的数组，所以它与ar1 的类型兼容，但是ar2 指向一个内含2个int 类型元素的数组，所以pa 与ar2 不兼容。

上面的最后两个例子有些棘手。变量p2 是指向指针的指针，它指向的指针指向int ，而ar2 是指向数组的指针，该数组内含2个int 类型的元素。所以，p2 和ar2 的类型不同，不能把ar2 赋给p2 。但是，\*p2 是指向int 的指针，与ar2\[0] 兼容。因为ar2\[0] 是指向该数组首元素（ar2\[0]\[0] ）的指针，所以ar2\[0] 也是指向int 的指针。

一般而言，多重解引用让人费解。例如，考虑下面的代码：
```c
int x = 20;
const int y = 23;
int * p1 = &x;
const int * p2 = &y;
const int ** pp2;
p1 = p2; // 不安全 -- 把const指针赋给非const指针
p2 = p1; // 有效 -- 把非const指针赋给const指针
pp2 = &p1; // 不安全 –- 嵌套指针类型赋值
```
前面提到过，把const 指针赋给非const 指针不安全，因为这样可以使用新的指针改变const 指针指向的数据。编译器在编译代码时，可能会给出警告，执行这样的代码是未定义的。但是把非const 指针赋给const 指针没问题，前提是只进行一级解引用：
```c
p2 = p1; // 有效 -- 把非const指针赋给const指针
```
但是进行两级解引用时，这样的赋值也不安全，例如，考虑下面的代码：
```c
const int **pp2;
int *p1;
const int n = 13;
pp2 = &p1; // 允许，但是这导致const限定符失效（根据第1行代码，不能通过
*pp2修改它所指向的内容）
*pp2 = &n; // 有效，两者都声明为const，但是这将导致p1指向n（*pp2已被修
改）
*p1 = 10; //有效，但是这将改变n的值（但是根据第3行代码，不能修改n的值）
```
发生了什么？如前所示，标准规定了通过非const 指针更改 const 数据是未定义的。例如，在Terminal中（OS X对底层UNIX系统的访问）使用gcc编译包含以上代码的小程序，导致n 最终的值是13 ，但是在相同系统下使用clang来编译，n 最终的值是10 。两个编译器都给出指针类型不兼容的警告。当然，可以忽略这些警告，但是最好不要相信该程序运行的结果，这些结果都是未定义的。
## C const和C++ const
C和C++中const 的用法很相似，但是并不完全相同。区别之一是，C++允许在声明数组大小时使用const 整数，而C却不允许。区别之二是，C++的指针赋值检查更严格：
```c
const int y;
const int * p2 = &y;
int * p1;
p1 = p2; // C++中不允许这样做，但是C可能只给出警告
```
C++不允许把const 指针赋给非const 指针。而C则允许这样做，但是如果通过p1 更改y ，其行为是未定义的。
## 函数和多维数组
如果要编写处理二维数组的函数，首先要能正确地理解指针才能写出声明函数的形参。在函数体中，通常使用数组表示法进行相关操作。
下面，我们编写一个处理二维数组的函数。一种方法是，利用 for 循环把处理一维数组的函数应用到二维数组的每一行。如下所示：
```c
int junk[3][4] = { {2,4,5,8}, {3,5,6,9}, {12,10,8,6} };
int i, j;
int total = 0;
for (i = 0; i < 3 ; i++)
total += sum(junk[i], 4); // junk[i]是一维数组
```
记住，如果junk 是二维数组，junk\[i] 就是一维数组，可将其视为二维数组的一行。这里，sum() 函数计算二维数组的每行的总和，然后for 循环再把每行的总和加起来。

然而，这种方法无法记录行和列的信息。用这种方法计算总和， 行和列的信息并不重要。但如果每行代表一年，每列代表一个月，就还需要一个函数计算某列的总和。该函数要知道行和列的信息，可以通过声明正确类型的形参变量来完成，以便函数能正确地传递数组。在这种情况下，数组junk 是一个内含3个数组元素的数组，每个元素是内含4个int 类型值的数组（即junk 是一个3行4列的二维数组）。通过前面的讨论可知，这表明junk 是一个指向数组（内含4 个int 类型值）的指针。可以这样声明函数的形参：
```c
void somefunction( int (* pt)[4] );
```
另外，如果当且仅当pt 是一个函数的形式参数时，可以这样声明：
```c
void somefunction( int pt[][4] );
```
注意，第1个方括号是空的。空的方括号表明pt 是一个指针。这样的变量稍后能以同样的方式用作junk 。下面的程序示例中就是这样做的。
```c
// array2d.c -- 处理二维数组的函数
#include <stdio.h>
#define ROWS 3
#define COLS 4
void sum_rows(int ar[][COLS], int rows);
void sum_cols(int [][COLS], int); // 省略形参名，没问题
int sum2d(int(*ar)[COLS], int rows); // 另一种语法
int main(void)
{
int junk[ROWS][COLS] = {
{ 2, 4, 6, 8 },
{ 3, 5, 7, 9 },
{ 12, 10, 8, 6 }
};
sum_rows(junk, ROWS);
sum_cols(junk, ROWS);
printf("Sum of all elements = %d\n", sum2d(junk, ROWS));
return 0;
}
void sum_rows(int ar[][COLS], int rows)
{
int r;
int c;
int tot;
for (r = 0; r < rows; r++)
{
tot = 0;
for (c = 0; c < COLS; c++)
tot += ar[r][c];
printf("row %d: sum = %d\n", r, tot);
}
}
void sum_cols(int ar[][COLS], int rows)
{
int r;
int c;
int tot;
for (c = 0; c < COLS; c++)
{
tot = 0;
for (r = 0; r < rows; r++)
tot += ar[r][c];
printf("col %d: sum = %d\n", c, tot);
}
}
int sum2d(int ar[][COLS], int rows)
{
int r;
int c;
int tot = 0;
for (r = 0; r < rows; r++)
for (c = 0; c < COLS; c++)
tot += ar[r][c];
return tot;
}
```
该程序的输出如下：
```
row 0: sum = 20
row 1: sum = 24
row 2: sum = 36
col 0: sum = 17
col 1: sum = 19
col 2: sum = 21
col 3: sum = 23
Sum of all elements = 80
```
程序把数组名junk （即，指向数组首元素的指针，首元素是子数组）和符号常量ROWS （代表行数3 ）作为参数传递给函数。每个函数都把ar 视为内含数组元素（每个元素是内含4 个int 类型值的数组）的数组。列数内置在函数体中，但是行数靠函数传递得到。如果传入函数的行数是12 ，那么函数要处理的是12 ×4 的数组。因为rows 是元素的个数，然而，因为每个元素都是数组， 或者视为一行，rows 也可以看成是行数。

注意，ar 和main() 中的junk 都使用数组表示法。因为ar 和 junk 的类型相同，它们都是指向内含4 个int 类型值的数组的指针。

注意，下面的声明不正确：
```c
int sum2(int ar[][], int rows); // 错误的声明
```
前面介绍过，编译器会把数组表示法转换成指针表示法。例如， 编译器会把ar\[1] 转换成ar+1 。编译器对ar+1 求值，要知道ar 所指向的对象大小。下面的声明：
```c
int sum2(int ar[][4], int rows); // 有效声明
```
表示ar 指向一个内含4个int 类型值的数组（在我们的系统中， ar 指向的对象占16字节），所以ar+1 的意思是“该地址加上16字节”。如果第2对方括号是空的，编译器就不知道该怎样处理。
也可以在第1对方括号中写上大小，如下所示，但是编译器会忽略该值：
```c
int sum2(int ar[3][4], int rows); // 有效声明，但是3将被忽略
```
与使用typedef相比，这种形式方便得多：
```c
typedef int arr4[4]; // arr4是一个内含 4 个int的数组
typedef arr4 arr3x4[3]; // arr3x4 是一个内含3个 arr4的数组
int sum2(arr3x4 ar, int rows); // 与下面的声明相同
int sum2(int ar[3][4], int rows); // 与下面的声明相同
int sum2(int ar[][4], int rows); // 标准形式
```
一般而言，声明一个指向N维数组的指针时，只能省略最左边方括号中的值：
```c
int sum4d(int ar[][12][20][30], int rows);
```
因为第1对方括号只用于表明这是一个指针，而其他的方括号则用于描述指针所指向数据对象的类型。下面的声明与该声明等价：
```c
int sum4d(int (*ar)[12][20][30], int rows); // ar是一个指针
```
这里，ar 指向一个12 ×20 ×30 的int 数组。
# 变长数组（VLA）

读者在学习处理二维数组的函数中可能不太理解，为何只把数组的行数作为函数的形参，而列数却内置在函数体内。例如，函数定义如下：

```c
#define COLS 4  // 列数固定为4

// 只能处理列数为4的二维数组
int sum2d(int ar[][COLS], int rows)
{
    int r;
    int c;
    int tot = 0;
    
    // 遍历所有行
    for (r = 0; r < rows; r++)
        // 遍历所有列（固定为COLS）
        for (c = 0; c < COLS; c++)
            tot += ar[r][c];  // 累加每个元素
    
    return tot;
}
```

假设声明了下列数组：

```c
int array1[5][4];    // 5行4列
int array2[100][4];  // 100行4列
int array3[2][4];    // 2行4列
```

可以用sum2d()函数分别计算这些数组的元素之和：

```c
tot = sum2d(array1, 5);    // 5×4 数组的元素之和
tot = sum2d(array2, 100);  // 100×4数组的元素之和
tot = sum2d(array3, 2);    // 2×4数组的元素之和
```

sum2d()函数之所以能处理这些数组，是因为这些数组的列数固定为4，而行数被传递给形参rows，rows是一个变量。但是如果要计算6×5的数组（即6行5列），就不能使用这个函数，必须重新创建一个COLS为5的函数。因为C规定，数组的维数必须是常量，不能用变量来代替COLS。

要创建一个能处理任意大小二维数组的函数，比较繁琐（必须把数组作为一维数组传递，然后让函数计算每行的开始处）。而且，这种方法不好处理FORTRAN的子例程，这些子例程都允许在函数调用中指定两个维度。虽然FORTRAN是比较老的编程语言，但是在过去的几十年里，数值计算领域的专家已经用FORTRAN开发出许多有用的计算库。C正逐渐替代FORTRAN，如果能直接转换现有的FORTRAN库就好了。

**总结：** 传统C数组在函数参数中的局限性促使了变长数组特性的引入，以提供更灵活的数组处理方式。

## VLA的基本概念

鉴于此，C99新增了变长数组（variable-length array，VLA），允许使用变量表示数组的维度。如下所示：

```c
int quarters = 4;     // 使用变量定义数组维度
int regions = 5;      // 使用变量定义数组维度
double sales[regions][quarters];  // 一个变长数组（VLA）
```

前面提到过，变长数组有一些限制。变长数组必须是自动存储类别，这意味着无论在函数中声明还是作为函数形参声明，都不能使用static或extern存储类别说明符。而且，不能在声明中初始化它们。最终，C11把变长数组作为一个可选特性，而不是必须强制实现的特性。

**注意：变长数组不能改变大小**

变长数组中的"变"不是指可以修改已创建数组的大小。一旦创建了变长数组，它的大小则保持不变。这里的"变"指的是：在创建数组时，可以使用变量指定数组的维度。

**总结：** VLA允许在运行时确定数组大小，但一旦创建，大小就固定了，这提供了比传统数组更大的灵活性。

## VLA函数参数的声明

由于变长数组是C语言的新特性，目前完全支持这一特性的编译器不多。下面我们来看一个简单的例子：如何编写一个函数，计算int的二维数组所有元素之和。

首先，要声明一个带二维变长数组参数的函数，如下所示：

```c
// ar是一个变长数组（VLA）
// 注意：rows和cols必须在ar之前声明
int sum2d(int rows, int cols, int ar[rows][cols]); 
```

注意前两个形参（rows和cols）用作第3个形参二维数组ar的两个维度。因为ar的声明要使用rows和cols，所以在形参列表中必须在声明ar之前先声明这两个形参。因此，下面的原型是错误的：

```c
// 无效的顺序：ar使用的rows和cols还未声明
int sum2d(int ar[rows][cols], int rows, int cols); 
```

C99/C11标准规定，可以省略原型中的形参名，但是在这种情况下，必须用星号来代替省略的维度：

```c
// ar是一个变长数组（VLA），省略了维度形参名
// 星号表示维度由其他参数决定
int sum2d(int, int, int ar[*][*]); 
```

**总结：** VLA参数的声明顺序很重要，维度参数必须在数组参数之前声明，这是VLA语法的基本要求。

## VLA函数的实现

其次，该函数的定义如下：

```c
// 带变长数组形参的函数定义
int sum2d(int rows, int cols, int ar[rows][cols])
{
    int r;
    int c;
    int tot = 0;
    
    // 使用变量rows和cols作为循环边界
    for (r = 0; r < rows; r++)
        for (c = 0; c < cols; c++)
            tot += ar[r][c];  // 正常的数组访问
    
    return tot;
}
```

该函数除函数头与传统的C函数不同外，还把符号常量COLS替换成变量cols。这是因为在函数头中使用了变长数组。由于用变量代表行数和列数，所以新的sum2d()现在可以处理任意大小的二维int数组。但是，该程序要求编译器支持变长数组特性。另外，该程序还演示了以变长数组作为形参的函数既可处理传统C数组，也可处理变长数组。

**总结：** VLA函数实现与传统数组函数类似，主要区别在于可以使用变量作为数组维度，提供了更大的通用性。

## 完整的VLA示例程序

```c
// vararr2d.c -- 使用变长数组的函数
#include <stdio.h>

#define ROWS 3
#define COLS 4

// 函数原型：接受变长数组参数
int sum2d(int rows, int cols, int ar[rows][cols]);

int main(void)
{
    int i, j;
    int rs = 3;   // 运行时确定的行数
    int cs = 10;  // 运行时确定的列数
    
    // 传统的固定大小数组
    int junk[ROWS][COLS] = {
        { 2, 4, 6, 8 },
        { 3, 5, 7, 9 },
        { 12, 10, 8, 6 }
    };
    
    // 编译时计算大小的数组
    int morejunk[ROWS - 1][COLS + 2] = {
        { 20, 30, 40, 50, 60, 70 },
        { 5, 6, 7, 8, 9, 10 }
    };
    
    // 真正的变长数组（VLA）
    int varr[rs][cs];  // 使用变量定义大小
    
    // 初始化变长数组
    for (i = 0; i < rs; i++)
        for (j = 0; j < cs; j++)
            varr[i][j] = i * j + j;  // 赋值公式：行号*列号+列号
    
    // 测试不同大小的数组
    printf("3x4 array\n");
    printf("Sum of all elements = %d\n", sum2d(ROWS, COLS, junk));
    
    printf("2x6 array\n");
    printf("Sum of all elements = %d\n", sum2d(ROWS - 1, COLS + 2, morejunk));
    
    printf("3x10 VLA\n");
    printf("Sum of all elements = %d\n", sum2d(rs, cs, varr));
    
    return 0;
}

// 带变长数组形参的函数
int sum2d(int rows, int cols, int ar[rows][cols])
{
    int r;
    int c;
    int tot = 0;
    
    // 遍历所有元素
    for (r = 0; r < rows; r++)
        for (c = 0; c < cols; c++)
            tot += ar[r][c];  // 累加数组元素
    
    return tot;
}
```

下面是该程序的输出：

```
3x4 array
Sum of all elements = 80
2x6 array
Sum of all elements = 315
3x10 VLA
Sum of all elements = 270
```

**总结：** 这个完整示例展示了VLA函数可以处理不同大小的数组，包括传统固定大小数组和真正的变长数组。

## VLA的内部机制

需要注意的是，在函数定义的形参列表中声明的变长数组并未实际创建数组。和传统的语法类似，变长数组名实际上是一个指针。这说明带变长数组形参的函数实际上是在原始数组中处理数组，因此可以修改传入的数组。下面的代码段指出指针和实际数组是何时声明的：

```c
// 主函数中
int thing[10][6];           // 实际的数组在这里创建
twoset(10, 6, thing);       // 传递数组到函数
// ...
}

// 函数定义
void twoset(int n, int m, int ar[n][m])  
// ar是一个指向数组的指针（内含m个int类型的值）
// 并未创建新数组，只是指向传入的数组
{
    int temp[n][m];     // temp是一个真正的n×m的int数组（在栈上创建）
    
    temp[0][0] = 2;     // 设置temp的一个元素为2（局部数组）
    ar[0][0] = 2;       // 设置thing[0][0]为2（修改原数组）
}
```

如上代码所示调用twoset()时，ar成为指向thing\[0]的指针，temp被创建为10×6的数组。因为ar和thing都是指向thing\[0]的指针，ar\[0]\[0]与thing\[0]\[0]访问的数据位置相同。

**总结：** VLA形参本质上是指针，不会创建新数组，但在函数内部声明的VLA会真正创建数组。

## const和数组大小

是否可以在声明数组时使用const变量？

```c
const int SZ = 80;
// ...
double ar[SZ];  // 是否允许？
```

C90标准不允许（也可能允许）。数组的大小必须是给定的整型常量表达式，可以是整型常量组合，如20、sizeof表达式或其他不是const的内容。由于C实现可以扩大整型常量表达式的范围，所以可能会允许使用const，但是这种代码可能无法移植。

C99/C11标准允许在声明变长数组时使用const变量。所以该数组的定义必须是声明在块中的自动存储类别数组。

变长数组还允许动态内存分配，这说明可以在程序运行时指定数组的大小。普通C数组都是静态内存分配，即在编译时确定数组的大小。由于数组大小是常量，所以编译器在编译时就知道了。

**总结：** VLA使得C语言能够在运行时确定数组大小，这是与传统数组的根本区别，提供了更大的灵活性但也带来了一些限制和兼容性问题。
# 复合字面量
假设给带int 类型形参的函数传递一个值，要传递int 类型的变量，但是也可以传递int 类型常量，如5 。在C99标准以前，对于带数组形参的函数，情况不同，可以传递数组，但是没有等价的数组常量。C99新增了复合字面量 （compound literal ）。字面量是除符号常量外的常量。例如，5 是int 类型字面量，81.3 是double 类型的字面量，'Y' 是char 类型的字面量，"elephant" 是字符串字面量。发布C99标准的委员会认为，如果有代表数组和结构内容的复合字面量，在编程时会更方便。

对于数组，复合字面量类似数组初始化列表，前面是用括号括起来的类型名。例如，下面是一个普通的数组声明：
```c
int diva[2] = {10, 20};
```
下面的复合字面量创建了一个和diva 数组相同的匿名数组，也有两个int 类型的值：
```c
(int [2]){10, 20} // 复合字面量
```
注意，去掉声明中的数组名，留下的int \[2] 即是复合字面量的类型名。
初始化有数组名的数组时可以省略数组大小，复合字面量也可以省略大小，编译器会自动计算数组当前的元素个数：
```c
(int []){50, 20, 90} // 内含3个元素的复合字面量
```
因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。使用指针记录地址就是一种用法。也就是说， 可以这样用：
```c
int * pt1;
pt1 = (int [2]) {10, 20};
```
注意，该复合字面量的字面常量与上面创建的diva 数组的字面常量完全相同。与有数组名的数组类似，复合字面量的类型名也代表首元素的地址，所以可以把它赋给指向int 的指针。然后便可使用这个指针。例如，本例中\*pt1 是10 ，pt1\[1] 是20 。

还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数：
```c
int sum(const int ar[], int n);
...
int total3;
total3 = sum((int []){4,4,4,5,5,5}, 6);
```
这里，第1 个实参是内含6 个int 类型值的数组，和数组名类似，这同时也是该数组首元素的地址。这种用法的好处是，把信息传入函数前不必先创建数组，这是复合字面量的典型用法。


