C语言能让程序员恰到好处地控制程序，这是它的优势之一。程序员通过C的内存管理系统指定变量的作用域和生命期，实现对程序的控制。合理使用内存储存数据是设计程序的一个要点。
# 存储类别

C提供了多种不同的模型或存储类别（storage class）在内存中储存数据。要理解这些存储类别，先要复习一些概念和术语。

本书目前所有编程示例中使用的数据都储存在内存中。从硬件方面来看，被储存的每个值都占用一定的物理内存，C语言把这样的一块内存称为对象（object）。对象可以储存一个或多个值。一个对象可能并未储存实际的值，但是它在储存适当的值时一定具有相应的大小（面向对象编程中的对象指的是类对象，其定义包括数据和允许对数据进行的操作，C不是面向对象编程语言）。

从软件方面来看，程序需要一种方法访问对象。这可以通过声明变量来完成：
```c
int entity = 3;
```
该声明创建了一个名为`entity`的标识符（identifier）。标识符是一个名称，在这种情况下，标识符可以用来指定（designate）特定对象的内容。标识符遵循变量的命名规则。在该例中，标识符`entity`即是软件（即C程序）指定硬件内存中的对象的方式。该声明还提供了储存在对象中的值。

变量名不是指定对象的唯一途径。考虑下面的声明：
```c
int * pt = &entity;
int ranks[10];
```
第1行声明中，`pt`是一个标识符，它指定了一个储存地址的对象。但是，表达式`*pt`不是标识符，因为它不是一个名称。然而，它确实指定了一个对象，在这种情况下，它与`entity`指定的对象相同。一般而言，那些指定对象的表达式被称为左值。所以，`entity`既是标识符也是左值；`*pt`既是表达式也是左值。按照这个思路，`ranks + 2 * entity`既不是标识符（不是名称），也不是左值（它不指定内存位置上的内容）。但是表达式`*(ranks + 2 * entity)`是一个左值，因为它的确指定了特定内存位置的值，即`ranks`数组的第7个元素。顺带一提，`ranks`的声明创建了一个可容纳10个`int`类型元素的对象，该数组的每个元素也是一个对象。

所有这些示例中，如果可以使用左值改变对象中的值，该左值就是一个可修改的左值（modifiable lvalue）。现在，考虑下面的声明：

```c
const char * pc = "Behold a string literal!";
```

程序根据该声明把相应的字符串字面量储存在内存中，内含这些字符值的字符串字面量就是一个对象。由于字符串字面量中的每个字符都能被单独访问，所以每个字符也是一个对象。该声明还创建了一个标识符为`pc`的对象，储存着字符串的地址。由于可以设置`pc`重新指向其他字符串，所以标识符`pc`是一个可修改的左值。`const`只能保证被`pc`指向的字符串内容不被修改，但是无法保证`pc`不指向别的字符串。由于`*pc`指定了储存`'B'`字符的数据对象，所以`*pc`是一个左值，但不是一个可修改的左值。与此类似，因为字符串字面量本身指定了储存字符串的对象，所以它也是一个左值，但不是可修改的左值。

可以用存储期（storage duration）描述对象，所谓存储期是指对象在内存中保留了多长时间。标识符用于访问对象，可以用作用域（scope）和链接（linkage）描述标识符，标识符的作用域和链接表明了程序的哪些部分可以使用它。不同的存储类别具有不同的存储期、作用域和链接。标识符可以在源代码的多文件中共享、可用于特定文件的任意函数中、可仅限于特定函数中使用，甚至只在函数中的某部分使用。对象可存在于程序的执行期，也可以仅存在于它所在函数的执行期。对于并发编程，对象可以在特定线程的执行期存在。可以通过函数调用的方式显式分配和释放内存。

我们先学习作用域、链接和存储期的含义，再介绍具体的存储类别。

## 作用域

作用域描述程序中可访问标识符的区域。一个C变量的作用域可以是块作用域、函数作用域、函数原型作用域或文件作用域。到目前为止，本书程序示例中使用的变量几乎都具有块作用域。块是用一对花括号括起来的代码区域。例如，整个函数体是一个块，函数中的任意复合语句也是一个块。定义在块中的变量具有块作用域（block scope），块作用域变量的可见范围是从定义处到包含该定义的块的末尾。另外，虽然函数的形式参数声明在函数的左花括号之前，但是它们也具有块作用域，属于函数体这个块。所以到目前为止，我们使用的局部变量（包括函数的形式参数）都具有块作用域。因此，下面代码中的变量`cleo`和`patrick`都具有块作用域：

这个函数定义展示了块作用域的基本示例，其中cleo是形参，patrick是局部变量，两者都具有块作用域。
```c
double blocky(double cleo)
{
    double patrick = 0.0;
    ...
    return patrick;
}
```
声明在内层块中的变量，其作用域仅局限于该声明所在的块：

这个函数演示了嵌套块作用域。变量q只在for循环内部可见，而patrick和i在整个函数内都可见。
```c
double blocky(double cleo)
{
    double patrick = 0.0;
    int i;
    for (i = 0; i < 10; i++)
    {
        double q = cleo * i;    // q的作用域开始
        ...
        patrick *= q;
    }                           // q的作用域结束
    ...
    return patrick;
}
```

在该例中，`q`的作用域仅限于内层块，只有内层块中的代码才能访问`q`。

以前，具有块作用域的变量都必须声明在块的开头。C99标准放宽了这一限制，允许在块中的任意位置声明变量。因此，对于`for`的循环头，现在可以这样写：
```c
for (int i = 0; i < 10; i++)
    printf("A C99 feature: i = %d", i);
```

为适应这个新特性，C99把块的概念扩展到包括`for`循环、`while`循环、`do while`循环和`if`语句所控制的代码，即使这些代码没有用花括号括起来，也算是块的一部分。所以，上面`for`循环中的变量`i`被视为`for`循环块的一部分，它的作用域仅限于`for`循环。一旦程序离开`for`循环，就不能再访问`i`。

函数作用域（function scope）仅用于`goto`语句的标签。这意味着即使一个标签首次出现在函数的内层块中，它的作用域也延伸至整个函数。如果在两个块中使用相同的标签会很混乱，标签的函数作用域防止了这样的事情发生。

函数原型作用域（function prototype scope）用于函数原型中的形参名（变量名），如下所示：
```c
int mighty(int mouse, double large);
```
函数原型作用域的范围是从形参定义处到原型声明结束。这意味着，编译器在处理函数原型中的形参时只关心它的类型，而形参名（如果有的话）通常无关紧要。而且，即使有形参名，也不必与函数定义中的形参名相匹配。只有在变长数组中，形参名才有用：
```c
void use_a_VLA(int n, int m, ar[n][m]);
```
方括号中必须使用在函数原型中已声明的名称。

变量的定义在函数的外面，具有文件作用域（file scope）。具有文件作用域的变量，从它的定义处到该定义所在文件的末尾均可见。考虑下面的例子：
这个程序展示了文件作用域变量的使用。units在所有函数外定义，因此main()和critic()函数都可以访问它。
```c
#include <stdio.h>
int units = 0;        /* 该变量具有文件作用域 */
void critic(void);
int main(void)
{
    ...
}
void critic(void)
{
    ...
}
```
这里，变量`units`具有文件作用域，`main()`和`critic()`函数都可以使用它（更准确地说，`units`具有外部链接文件作用域，稍后讲解）。由于这样的变量可用于多个函数，所以文件作用域变量也称为全局变量（global variable）。
# 翻译单元和文件

你认为的多个文件在编译器中可能以一个文件出现。例如，通常在源代码（.c扩展名）中包含一个或多个头文件（.h扩展名）。头文件会依次包含其他头文件，所以会包含多个单独的物理文件。但是，C预处理实际上是用包含的头文件内容替换`#include`指令。所以，编译器源代码文件和所有的头文件都看成是一个包含信息的单独文件。这个文件被称为翻译单元（translation unit）。描述一个具有文件作用域的变量时，它的实际可见范围是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件。
## 链接

接下来，我们介绍链接。C变量有3种链接属性：外部链接、内部链接或无链接。具有块作用域、函数作用域或函数原型作用域的变量都是无链接变量。这意味着这些变量属于定义它们的块、函数或原型私有。具有文件作用域的变量可以是外部链接或内部链接。外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用。
### 正式和非正式术语

C标准用"内部链接的文件作用域"描述仅限于一个翻译单元（即一个源代码文件和它所包含的头文件）的作用域，用"外部链接的文件作用域"描述可延伸至其他翻译单元的作用域。但是，对程序员而言这些术语太长了。一些程序员把"内部链接的文件作用域"简称为"文件作用域"，把"外部链接的文件作用域"简称为"全局作用域"或"程序作用域"。

如何知道文件作用域变量是内部链接还是外部链接？可以查看外部定义中是否使用了存储类别说明符`static`：

这个例子展示了外部链接和内部链接的区别。giants可以被其他文件访问，而dodgers只能在当前文件中使用。
```c
int giants = 5;           // 文件作用域，外部链接
static int dodgers = 3;   // 文件作用域，内部链接
int main()
{
    ...
}
...
```

该文件和同一程序的其他文件都可以使用变量`giants`。而变量`dodgers`属文件私有，该文件中的任意函数都可使用它。

## 存储期

作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期。C对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。

如果对象具有静态存储期，那么它在程序的执行期间一直存在。文件作用域变量具有静态存储期。注意，对于文件作用域变量，关键字`static`表明了其链接属性，而非存储期。以`static`声明的文件作用域变量具有内部链接。但是无论是内部链接还是外部链接，所有的文件作用域变量都具有静态存储期。

线程存储期用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，从被声明时到线程结束一直存在。以关键字`_Thread_local`声明一个对象时，每个线程都获得该变量的私有备份。

块作用域的变量通常都具有自动存储期。当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区。例如，一个函数调用结束后，其变量占用的内存可用于储存下一个被调用函数的变量。

变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的开始处到块的末尾。

我们到目前为止使用的局部变量都是自动类别。例如，在下面的代码中，变量`number`和`index`在每次调用`bore()`函数时被创建，在离开函数时被销毁：

这个函数演示了自动存储期。每次调用函数时创建变量，函数返回时销毁变量。
```c
void bore(int number)
{
    int index;
    for (index = 0; index < number; index++)
        puts("They don't make them the way they used to.\n");
    return 0;
}
```
然而，块作用域变量也能具有静态存储期。为了创建这样的变量，要把变量声明在块中，且在声明前面加上关键字`static`：

这个函数展示了块作用域的静态变量。ct在函数调用之间保持其值，但只能在more()函数内访问。
```c
void more(int number)
{
    int index;
    static int ct = 0;
    ...
    return 0;
}
```
这里，变量`ct`储存在静态内存中，它从程序被载入到程序结束期间都存在。但是，它的作用域定义在`more()`函数块中。只有在执行该函数时，程序才能使用`ct`访问它所指定的对象（但是，该函数可以给其他函数提供该存储区的地址以便间接访问该对象，例如通过指针形参或返回值）。

C使用作用域、链接和存储期为变量定义了多种存储方案。本书不涉及并发程序设计，所以不再赘述这方面的内容。已分配存储期在本章后面介绍。因此，剩下5种存储类别：自动、寄存器、静态块作用域、静态外部链接、静态内部链接。现在，我们已经介绍了作用域、链接和存储期，接下来将详细讨论这些存储类别。
**5种存储类别:**

| 存储类别   | 存储期 | 作用域 | 链接  | 声明方式                |
| ------ | --- | --- | --- | ------------------- |
| 自动     | 自动  | 块   | 无   | 块内                  |
| 寄存器    | 自动  | 块   | 无   | 块内，使用关键字`register`  |
| 静态外部链接 | 静态  | 文件  | 外部  | 所有函数外               |
| 静态内部链接 | 静态  | 文件  | 内部  | 所有函数外，使用关键字`static` |
| 静态无链接  | 静态  | 块   | 无   | 块内，使用关键字`static`    |
|        |     |     |     |                     |

## 自动变量
属于自动存储类别的变量具有自动存储期、块作用域且无链接。默认情况下，声明在块或函数头中的任何变量都属于自动存储类别。为了更清楚地表达你的意图（例如，为了表明有意覆盖一个外部变量定义，或者强调不要把该变量改为其他存储类别），可以显式使用关键字`auto`，如下所示：
```c
int main(void)
{
    auto int plox;
```
关键字`auto`是存储类别说明符（storage-class specifier）。`auto`关键字在C++中的用法完全不同，如果编写C/C++兼容的程序，最好不要使用`auto`作为存储类别说明符。

块作用域和无链接意味着只有在变量定义所在的块中才能通过变量名访问该变量（当然，参数用于传递变量的值和地址给另一个函数，但是这是间接的方法）。另一个函数可以使用同名变量，但是该变量是储存在不同内存位置上的另一个变量。

变量具有自动存储期意味着，程序在进入该变量声明所在的块时变量存在，程序在退出该块时变量消失。原来该变量占用的内存位置现在可做他用。

接下来分析一下嵌套块的情况。块中声明的变量仅限于该块及其包含的块使用。

这个函数展示了变量作用域在嵌套块中的规则。变量i只在内层块中可见，而m在整个函数中都可见。
```c
int loop(int n)
{
    int m;                      // m 的作用域
    scanf("%d", &m);
    {
        int i;                  // m 和 i 的作用域
        for (i = m; i < n; i++)
            puts("i is local to a sub-block\n");
    }
    return m;                   // m 的作用域，i 已经消失
}
```

在上面的代码中，`i`仅在内层块中可见。如果在内层块的前面或后面使用`i`，编译器会报错。通常，在设计程序时用不到这个特性。然而，如果这个变量仅供该块使用，那么在块中就近定义该变量也很方便。这样，可以在靠近使用变量的地方记录其含义。另外，这样的变量只有在使用时才占用内存。变量`n`和`m`分别定义在函数头和外层块中，它们的作用域是整个函数，而且在调用函数到函数结束期间都一直存在。
如果内层块中声明的变量与外层块中的变量同名会怎样？内层块会隐藏外层块的定义。但是离开内层块后，外层块变量的作用域又回到了原来的作用域。hiding.c 程序演示了这一过程。
这个程序演示了变量名隐藏机制。内层块中的同名变量会隐藏外层块的变量，但不会改变外层变量的值。
```c
// hiding.c -- 块中的变量
#include <stdio.h>
int main()
{
    int x = 30;      // 原始的 x
    
    printf("x in outer block: %d at %p\n", x, &x);
    {
        int x = 77;  // 新的 x，隐藏了原始的 x
        printf("x in inner block: %d at %p\n", x, &x);
    }
    printf("x in outer block: %d at %p\n", x, &x);
    while (x++ < 33) // 原始的 x
    {
        int x = 100; // 新的 x，隐藏了原始的 x
        x++;
        printf("x in while loop: %d at %p\n", x, &x);
    }
    printf("x in outer block: %d at %p\n", x, &x);
    
    return 0;
}
```
下面是该程序的输出：
```
x in outer block: 30 at 0x7fff5fbff8c8
x in inner block: 77 at 0x7fff5fbff8c4
x in outer block: 30 at 0x7fff5fbff8c8
x in while loop: 101 at 0x7fff5fbff8c0
x in while loop: 101 at 0x7fff5fbff8c0
x in while loop: 101 at 0x7fff5fbff8c0
x in outer block: 34 at 0x7fff5fbff8c8
```
首先，程序创建了变量`x`并初始化为30，如第1条`printf()`语句所示。然后，定义了一个新的变量`x`，并设置为77，如第2条`printf()`语句所示。根据显示的地址可知，新变量隐藏了原始的`x`。第3条`printf()`语句位于第1个内层块后面，显示的是原始的`x`的值，这说明原始的`x`既没有消失也不曾改变。

也许该程序最难懂的是`while`循环。`while`循环的测试条件中使用的是原始的`x`：
```c
while(x++ < 33)
```
在该循环中，程序创建了第3个`x`变量，该变量只定义在`while`循环中。所以，当执行到循环体中的`x++`时，递增为101的是新的`x`，然后`printf()`语句显示了该值。每轮迭代结束，新的`x`变量就消失。然后循环的测试条件使用并递增原始的`x`，再次进入循环体，再次创建新的`x`。在该例中，这个`x`被创建和销毁了3次。注意，该循环必须在测试条件中递增`x`，因为如果在循环体中递增`x`，那么递增的是循环体中创建的`x`，而非测试条件中使用的原始`x`。

我们使用的编译器在创建`while`循环体中的`x`时，并未复用内层块中`x`占用的内存，但是有些编译器会这样做。

该程序示例的用意不是鼓励读者要编写类似的代码（根据C的命名规则，要想出别的变量名并不难），而是为了解释在内层块中定义变量的具体情况。

### 1．没有花括号的块

前面提到一个C99特性：作为循环或`if`语句的一部分，即使不使用花括号（`{}`），也是一个块。更完整地说，整个循环是它所在块的子块（sub-block），循环体是整个循环块的子块。与此类似，`if`语句是一个块，与其相关联的子语句是`if`语句的子块。这些规则会影响到声明的变量和这些变量的作用域。forc99.c 程序演示了`for`循环中该特性的用法。

这个程序演示了C99的块规则。for循环控制部分声明的变量作用域仅限于循环，循环体内声明的同名变量会隐藏循环控制变量。

```c
// forc99.c -- 新的 C99 块规则
#include <stdio.h>
int main()
{
    int n = 8;
    
    printf(" Initially, n = %d at %p\n", n, &n);
    for (int n = 1; n < 3; n++)
        printf(" loop 1: n = %d at %p\n", n, &n);
    printf("After loop 1, n = %d at %p\n", n, &n);
    for (int n = 1; n < 3; n++)
    {
        printf(" loop 2 index n = %d at %p\n", n, &n);
        int n = 6;
        printf(" loop 2: n = %d at %p\n", n, &n);
        n++;
    }
    printf("After loop 2, n = %d at %p\n", n, &n);
    
    return 0;
}
```

假设编译器支持C语言的这个新特性，该程序的输出如下：

```c
 Initially, n = 8 at 0x7fff5fbff8c8
 loop 1: n = 1 at 0x7fff5fbff8c4
 loop 1: n = 2 at 0x7fff5fbff8c4
After loop 1, n = 8 at 0x7fff5fbff8c8
 loop 2 index n = 1 at 0x7fff5fbff8c0
 loop 2: n = 6 at 0x7fff5fbff8bc
 loop 2 index n = 2 at 0x7fff5fbff8c0
 loop 2: n = 6 at 0x7fff5fbff8bc
After loop 2, n = 8 at 0x7fff5fbff8c8
```

第1个`for`循环头中声明的`n`，其作用域作用至循环末尾，而且隐藏了原始的`n`。但是，离开循环后，原始的`n`又起作用了。

第2个`for`循环头中声明的`n`作为循环的索引，隐藏了原始的`n`。然后，在循环体中又声明了一个`n`，隐藏了索引`n`。结束一轮迭代后，声明在循环体中的`n`消失，循环头使用索引`n`进行测试。当整个循环结束时，原始的`n`又起作用了。再次提醒读者注意，没必要在程序中使用相同的变量名。如果用了，各变量的情况如上所述。

### 支持C99和C11
有些编译器并不支持C99/C11的这些作用域规则（Microsoft Visual Studio 2012就是其中之一）。有些编译会提供激活这些规则的选项。例如，撰写本书时，gcc默认支持了C99的许多特性，但是要用`–std=c99`选项激活：
```
gcc –std=c99 forc99.c
```
与此类似，gcc或clang都要使用`–std=c1x`或`-std=c11`选项，才支持C11特性。
### 2．自动变量的初始化
自动变量不会初始化，除非显式初始化它。考虑下面的声明：
```c
int main(void)
{
    int repid;
    int tents = 5;
```
`tents`变量被初始化为5，但是`repid`变量的值是之前占用分配给`repid`的空间中的任意值（如果有的话），别指望这个值是0。可以用非常量表达式（non-constant expression）初始化自动变量，前提是所用的变量已在前面定义过：
```c
int main(void)
{
    int ruth = 1;
    int rance = 5 * ruth;    // 使用之前定义的变量
```

## 寄存器变量

变量通常储存在计算机内存中。如果幸运的话，寄存器变量储存在CPU的寄存器中，或者概括地说，储存在最快的可用内存中。与普通变量相比，访问和处理这些变量的速度更快。由于寄存器变量储存在寄存器而非内存中，所以无法获取寄存器变量的地址。绝大多数方面，寄存器变量和自动变量都一样。也就是说，它们都是块作用域、无链接和自动存储期。使用存储类别说明符`register`便可声明寄存器变量：
```c
int main(void)
{
    register int quick;
```
我们刚才说"如果幸运的话"，是因为声明变量为`register`类别与直接命令相比更像是一种请求。编译器必须根据寄存器或最快可用内存的数量衡量你的请求，或者直接忽略你的请求，所以可能不会如你所愿。在这种情况下，寄存器变量就变成普通的自动变量。即使是这样，仍然不能对该变量使用地址运算符。

在函数头中使用关键字`register`，便可请求形参是寄存器变量：
```c
void macho(register int n)
```

可声明为`register`的数据类型有限。例如，处理器中的寄存器可能没有足够大的空间来储存`double`类型的值。
## 12.1.6　块作用域的静态变量
静态变量（static variable）听起来自相矛盾，像是一个不可变的变量。实际上，静态的意思是该变量在内存中原地不动，并不是说它的值不变。具有文件作用域的变量自动具有（也必须是）静态存储期。前面提到过，可以创建具有静态存储期、块作用域的局部变量。这些变量和自动变量一样，具有相同的作用域，但是程序离开它们所在的函数后，这些变量不会消失。也就是说，这种变量具有块作用域、无链接，但是具有静态存储期。计算机在多次函数调用之间会记录它们的值。在块中（提供块作用域和无链接）以存储类别说明符`static`（提供静态存储期）声明这种变量。loc_stat.c 程序演示了一个这样的例子。

这个程序演示了局部静态变量的特性。fade每次调用都重新初始化，而stay保持上次调用后的值。

```c
/* loc_stat.c -- 使用局部静态变量 */
#include <stdio.h>
void trystat(void);

int main(void)
{
    int count;
    
    for (count = 1; count <= 3; count++)
    {
        printf("Here comes iteration %d:\n", count);
        trystat();
    }
    
    return 0;
}

void trystat(void)
{
    int fade = 1;
    static int stay = 1;
    
    printf("fade = %d and stay = %d\n", fade++, stay++);
}
```
注意，`trystat()`函数先打印再递增变量的值。该程序的输出如下：
```
Here comes iteration 1:
fade = 1 and stay = 1
Here comes iteration 2:
fade = 1 and stay = 2
Here comes iteration 3:
fade = 1 and stay = 3
```
静态变量`stay`保存了它被递增1后的值，但是`fade`变量每次都是1。这表明了初始化的不同：每次调用`trystat()`都会初始化`fade`，但是`stay`只在编译`trystat()`时被初始化一次。如果未显式初始化静态变量，它们会被初始化为0。
下面两个声明很相似：
```c
int fade = 1;
static int stay = 1;
```
第1条声明确实是`trystat()`函数的一部分，每次调用该函数时都会执行这条声明。这是运行时行为。第2条声明实际上并不是`trystat()`函数的一部分。如果逐步调试该程序会发现，程序似乎跳过了这条声明。这是因为静态变量和外部变量在程序被载入内存时已执行完毕。把这条声明放在`trystat()`函数中是为了告诉编译器只有`trystat()`函数才能看到该变量。这条声明并未在运行时执行。

不能在函数的形参中使用`static`：
```c
int wontwork(static int flu);    // 不允许
```

"局部静态变量"是描述具有块作用域的静态变量的另一个术语。阅读一些老的C文献时会发现，这种存储类别被称为内部静态存储类别（internal static storage class）。这里的内部指的是函数内部，而非内部链接。

## 外部链接的静态变量

外部链接的静态变量具有文件作用域、外部链接和静态存储期。该类别有时称为外部存储类别（external storage class），属于该类别的变量称为外部变量（external variable）。把变量的定义性声明（defining declaration）放在所有函数的外面便创建了外部变量。当然，为了指出该函数使用了外部变量，可以在函数中用关键字`extern`再次声明。如果一个源代码文件使用的外部变量定义在另一个源代码文件中，则必须用`extern`在该文件中声明该变量。如下所示：

这个例子展示了外部变量的声明和使用。外部变量可以在多个函数和文件间共享。
```c
int Errupt;              /* 外部定义的变量 */
double Up[100];          /* 外部定义的数组 */
extern char Coal;        /* 如果Coal被定义在另一个文件， */
                        /* 则必须这样声明*/
void next(void);
int main(void)
{
    extern int Errupt;   /* 可选的声明*/
    extern double Up[];  /* 可选的声明*/
    ...
}
void next(void)
{
    ...
}
```

注意，在`main()`中声明`Up`数组时（这是可选的声明）不用指明数组大小，因为第1次声明已经提供了数组大小信息。`main()`中的两条`extern`声明完全可以省略，因为外部变量具有文件作用域，所以`Errupt`和`Up`从声明处到文件结尾都可见。它们出现在那里，仅为了说明`main()`函数要使用这两个变量。

如果省略掉函数中的`extern`关键字，相当于创建了一个自动变量。去掉下面声明中的`extern`：
```c
extern int Errupt;
```
便成为：
```c
int Errupt;
```

这使得编译器在`main()`中创建了一个名为`Errupt`的自动变量。它是一个独立的局部变量，与原来的外部变量`Errupt`不同。该局部变量仅`main()`中可见，但是外部变量`Errupt`对于该文件的其他函数（如`next()`）也可见。简而言之，在执行块中的语句时，块作用域中的变量将"隐藏"文件作用域中的同名变量。如果不得已要使用与外部变量同名的局部变量，可以在局部变量的声明中使用`auto`存储类别说明符明确表达这种意图。

外部变量具有静态存储期。因此，无论程序执行到`main()`、`next()`还是其他函数，数组`Up`及其值都一直存在。

下面3个示例演示了外部和自动变量的一些使用情况。示例1中有一个外部变量`Hocus`。该变量对`main()`和`magic()`均可见。

示例1展示了外部变量Hocus对两个函数都可见，需要在函数中用extern声明。
```c
/* 示例1 */
int Hocus;
int magic();
int main(void)
{
    extern int Hocus;    // Hocus 之前已声明为外部变量
    ...
}
int magic()
{
    extern int Hocus;    // 与上面的Hocus 是同一个变量
    ...
}
```
示例2中有一个外部变量`Hocus`，对两个函数均可见。这次，在默认情况下对`magic()`可见。

示例2展示了外部变量在声明后对所有函数都是默认可见的，无需再次声明。
```c
/*示例2 */
int Hocus;
int magic();
int main(void)
{
    extern int Hocus;    // Hocus之前已声明为外部变量
    ...
}
int magic()
{
    //并未在该函数中声明Hocus，但是仍可使用该变量
    ...
}
```
在示例3中，创建了4个独立的变量。`main()`中的`Hocus`变量默认是自动变量，属于`main()`私有。`magic()`中的`Hocus`变量被显式声明为自动，只有`magic()`可用。外部变量`Hocus`对`main()`和`magic()`均不可见，但是对该文件中未创建局部`Hocus`变量的其他函数可见。最后，`Pocus`是外部变量，`magic()`可见，但是`main()`不可见，因为`Pocus`被声明在`main()`后面。

示例3展示了局部变量会隐藏同名的外部变量，以及外部变量的作用域从声明处开始。
```c
/* 示例 3 */
int Hocus;
int magic();
int main(void)
{
    int Hocus;           // 声明Hocus，默认是自动变量
    ...
}
int Pocus;
int magic()
{
    auto int Hocus;      //把局部变量Hocus显式声明为自动变量
    ...
}
```
这3个示例演示了外部变量的作用域是：从声明处到文件结尾。除此之外，还说明了外部变量的生命期。外部变量`Hocus`和`Pocus`在程序运行中一直存在，因为它们不受限于任何函数，不会在某个函数返回后就消失。

### 1．初始化外部变量

外部变量和自动变量类似，也可以被显式初始化。与自动变量不同的是，如果未初始化外部变量，它们会被自动初始化为0。这一原则也适用于外部定义的数组元素。与自动变量的情况不同，只能使用常量表达式初始化文件作用域变量：
```c
int x = 10;                    // 没问题，10是常量
int y = 3 + 20;               // 没问题，用于初始化的是常量表达式
size_t z = sizeof(int);       //没问题，用于初始化的是常量表达式
int x2 = 2 * x;               // 不行，x是变量
```

（只要不是变长数组，`sizeof`表达式可被视为常量表达式。）

### 2．使用外部变量

下面来看一个使用外部变量的示例。假设有两个函数`main()`和`critic()`，它们都要访问变量`units`。可以把`units`声明在这两个函数的上面，如global.c 程序所示（注意：该例的目的是演示外部变量的工作原理，并非它的典型用法）。

这个程序演示了外部变量的使用。main()和critic()函数共享外部变量units。
```c
/* global.c -- 使用外部变量 */
#include <stdio.h>
int units = 0;           /* 外部变量 */
void critic(void);

int main(void)
{
    extern int units;    /* 可选的重复声明 */
    
    printf("How many pounds to a firkin of butter?\n");
    scanf("%d", &units);
    while (units != 56)
        critic();
    printf("You must have looked it up!\n");
    
    return 0;
}

void critic(void)
{
    /* 删除了可选的重复声明 */
    printf("No luck, my friend. Try again.\n");
    scanf("%d", &units);
}
```

下面是该程序的输出示例：
```
How many pounds to a firkin of butter?
14
No luck, my friend. Try again.
56
You must have looked it up!
```
注意，`critic()`是如何读取`units`的第2个值的。当`while`循环结束时，`main()`也知道`units`的新值。所以`main()`函数和`critic()`都可以通过标识符`units`访问相同的变量。用C的术语来描述是，`units`具有文件作用域、外部链接和静态存储期。

把`units`定义在所有函数定义外面（即外部），`units`便是一个外部变量，对`units`定义下面的所有函数均可见。因此，`critics()`可以直接使用`units`变量。

类似地，`main()`也可直接访问`units`。但是，`main()`中确实有如下声明：
```c
extern int units;
```
本例中，以上声明主要是为了指出该函数要使用这个外部变量。存储类别说明符`extern`告诉编译器，该函数中任何使用`units`的地方都引用同一个定义在函数外部的变量。再次强调，`main()`和`critic()`使用的都是外部定义的`units`。
### 3．外部名称

C99和C11标准都要求编译器识别局部标识符的前63个字符和外部标识符的前31个字符。这修订了以前的标准，即编译器识别局部标识符前31个字符和外部标识符前6个字符。你所用的编译器可能还执行以前的规则。外部变量名比局部变量名的规则严格，是因为外部变量名还要遵循局部环境规则，所受的限制更多。

### 4．定义和声明

下面进一步介绍定义变量和声明变量的区别。考虑下面的例子：
```c
int tern = 1;        /* tern被定义 */
main()
{
    extern int tern; /* 使用在别处定义的tern */
```
这里，`tern`被声明了两次。第1次声明为变量预留了存储空间，该声明构成了变量的定义。第2次声明只告诉编译器使用之前已创建的`tern`变量，所以这不是定义。第1次声明被称为定义式声明（defining declaration），第2次声明被称为引用式声明（referencing declaration）。关键字`extern`表明该声明不是定义，因为它指示编译器去别处查询其定义。

假设这样写：
```c
extern int tern;
int main(void)
{
```
编译器会假设`tern`实际的定义在该程序的别处，也许在别的文件中。该声明并不会引起分配存储空间。因此，不要用关键字`extern`创建外部定义，只用它来引用现有的外部定义。

外部变量只能初始化一次，且必须在定义该变量时进行。假设有下面的代码：
```c
// file_one.c
char permis = 'N';
...
// file_two.c
extern char permis = 'Y';    /* 错误 */
```

file_two中的声明是错误的，因为file_one.c中的定义式声明已经创建并初始化了`permis`。
## 内部链接的静态变量

该存储类别的变量具有静态存储期、文件作用域和内部链接。在所有函数外部（这点与外部变量相同），用存储类别说明符`static`定义的变量具有这种存储类别：
```c
static int svil = 1;    // 静态变量，内部链接
int main(void)
{
```

这种变量过去称为外部静态变量（external static variable），但是这个术语有点自相矛盾（这些变量具有内部链接）。但是，没有合适的新简称，所以只能用内部链接的静态变量（static variable with internal linkage）。普通的外部变量可用于同一程序中任意文件中的函数，但是内部链接的静态变量只能用于同一个文件中的函数。可以使用存储类别说明符`extern`，在函数中重复声明任何具有文件作用域的变量。这样的声明并不会改变其链接属性。考虑下面的代码：

这个例子展示了extern声明不会改变变量的链接属性。traveler保持外部链接，stayhome保持内部链接。
```c
int traveler = 1;           // 外部链接
static int stayhome = 1;    // 内部链接
int main()
{
    extern int traveler;    // 使用定义在别处的 traveler
    extern int stayhome;    // 使用定义在别处的 stayhome
    ...
```
对于该程序所在的翻译单元，`trveler`和`stayhome`都具有文件作用域，但是只有`traveler`可用于其他翻译单元（因为它具有外部链接）。这两个声明都使用了`extern`关键字，指明了`main()`中使用的这两个变量的定义都在别处，但是这并未改变`stayhome`的内部链接属性。
## 多文件

只有当程序由多个翻译单元组成时，才体现区别内部链接和外部链接的重要性。接下来简要介绍一下。

复杂的C程序通常由多个单独的源代码文件组成。有时，这些文件可能要共享一个外部变量。C通过在一个文件中进行定义式声明，然后在其他文件中进行引用式声明来实现共享。也就是说，除了一个定义式声明外，其他声明都要使用`extern`关键字。而且，只有定义式声明才能初始化变量。

注意，如果外部变量定义在一个文件中，那么其他文件在使用该变量之前必须先声明它（用`extern`关键字）。也就是说，在某文件中对外部变量进行定义式声明只是单方面允许其他文件使用该变量，其他文件在用`extern`声明之前不能直接使用它。

过去，不同的编译器遵循不同的规则。例如，许多UNIX系统允许在多个文件中不使用`extern`关键字声明变量，前提是只有一个带初始化的声明。编译器会把文件中一个带初始化的声明视为该变量的定义。

## 存储类别说明符

读者可能已经注意到了，关键字`static`和`extern`的含义取决于上下文。C语言有6个关键字作为存储类别说明符：`auto`、`register`、`static`、`extern`、`_Thread_local`和`typedef`。`typedef`关键字与任何内存存储无关，把它归于此类有一些语法上的原因。尤其是，在绝大多数情况下，不能在声明中使用多个存储类别说明符，所以这意味着不能使用多个存储类别说明符作为`typedef`的一部分。唯一例外的是`_Thread_local`，它可以和`static`或`extern`一起使用。

`auto`说明符表明变量是自动存储期，只能用于块作用域的变量声明中。由于在块中声明的变量本身就具有自动存储期，所以使用`auto`主要是为了明确表达要使用与外部变量同名的局部变量的意图。

`register`说明符也只用于块作用域的变量，它把变量归为寄存器存储类别，请求最快速度访问该变量。同时，还保护了该变量的地址不被获取。

用`static`说明符创建的对象具有静态存储期，载入程序时创建对象，当程序结束时对象消失。如果`static`用于文件作用域声明，作用域受限于该文件。如果`static`用于块作用域声明，作用域则受限于该块。因此，只要程序在运行对象就存在并保留其值，但是只有在执行块内的代码时，才能通过标识符访问。块作用域的静态变量无链接。文件作用域的静态变量具有内部链接。

`extern`说明符表明声明的变量定义在别处。如果包含`extern`的声明具有文件作用域，则引用的变量必须具有外部链接。如果包含`extern`的声明具有块作用域，则引用的变量可能具有外部链接或内部链接，这接取决于该变量的定义式声明。

## 小结：存储类别  
限于该块。因此，只要程序在运行对象就存在并保留其值，但是只有  
在执行块内的代码时，才能通过标识符访问。块作用域的静态变量无  
链接。文件作用域的静态变量具有内部链接。  
extern 说明符表明声明的变量定义在别处。如果包含extern  
的声明具有文件作用域，则引用的变量必须具有外部链接。如果包含  
extern 的声明具有块作用域，则引用的变量可能具有外部链接或内部链接，这接取决于该变量的定义式声明。  
自动变量具有块作用域、无链接、自动存储期。它们是局部变量，属于其定义所在块（通常指函数）私有。寄存器变量的属性和自动变量相同，但是编译器会使用更快的内存或寄存器储存它们。不能获取寄存器变量的地址。  
具有静态存储期的变量可以具有外部链接、内部链接或无链接。在同一个文件所有函数的外部声明的变量是外部变量，具有文件作用域、外部链接和静态存储期。如果在这种声明前面加上关键字static ，那么其声明的变量具有文件作用域、内部链接和静态存储期。如果在函数中用static 声明一个变量，则该变量具有块作用域、无链接、静态存储期。  
具有自动存储期的变量，程序在进入该变量的声明所在块时才为其分配内存，在退出该块时释放之前分配的内存。如果未初始化，自动变量中是垃圾值。程序在编译时为具有静态存储期的变量分配内存，并在程序的运行过程中一直保留这块内存。如果未初始化，这样的变量会被设置为0 。  
具有块作用域的变量是局部的，属于包含该声明的块私有。具有文件作用域的变量对文 件（或翻译单元）中位于其声明后面的所有函数可见。具有外部链接的文件作用域变量，可用于该程序的其他翻译单元。具有内部链接的文件作用域变量，只能用于其声明所在的文件内。  
下面用一个简短的程序使用了5种存储类别。该程序包含两个文 件　(parta.c 程序和partb.c 程序)，所以必须使用多文件编译（。该示例仅为了让读者熟悉5种存储类别的用法，并不是提供设计模型，好的设计可以不需要使用文件作用域变量。
```c
//parta.c
#include <stdio.h>          // 引入标准输入输出库
void report_count();        // 函数原型
void accumulate(int k);     // 函数原型
int count = 0;              // 文件作用域，外部链接
int main(void)               // 主函数
{
    int value;               // 自动变量
    register int i;          // 寄存器变量
    printf("Enter a positive integer (0 to quit): ");
    while (scanf("%d", &value) == 1 && value > 0)   // 输入循环
    {
        ++count;             // 使用文件作用域变量
        for (i = value; i >= 0; i--)   // 递减循环
            accumulate(i);   // 调用 accumulate
        printf("Enter a positive integer (0 to quit): ");
    }
    report_count();          // 报告计数
    return 0;
}
void report_count()          // 报告函数
{
    printf("Loop executed %d times\n", count);
}
```

```c
//partb.c
#include <stdio.h>          // 引入标准输入输出库
extern int count;           // 引用式声明，外部链接
static int total = 0;       // 静态定义，内部链接
void accumulate(int k);     // 函数原型
void accumulate(int k)      // k 具有块作用域，无链接
{
    static int subtotal = 0;   // 静态，无链接
    if (k <= 0)                // 终止条件
    {
        printf("loop cycle: %d\n", count);
        printf("subtotal: %d; total: %d\n", subtotal, total);
        subtotal = 0;          // 重置 subtotal
    }
    else
    {
        subtotal += k;         // 累加 subtotal
        total += k;            // 累加 total
    }
}
```
在该程序中，块作用域的静态变量 `subtotal` 统计每次 `while` 循环传入 `accumulate()` 函数的总数，具有文件作用域、内部链接的变量 `total` 统计所有传入 `accumulate()` 函数的总数。当传入负值时，`accumulate()` 函数报告 `total` 和 `subtotal` 的值，并在报告后重置 `subtotal` 为0 。由于 `parta.c` 调用了 `accumulate()` 函数，所以必须包含 `accumulate()` 函数的原型。而 `partb.c` 只包含了 `accumulate()` 函数的定义，并未在文件中调用该函数，所以其原型为可选（即省略原型也不影响使用）。该函数使用了外部变量 `count` 统计 `main()` 中的 `while` 循环迭代的次数（顺带一提，对于该程序，没必要使用外部变量把 `parta.c` 和 `partb.c` 的代码弄得这么复杂）。在 `parta.c` 中，`main()` 和 `report_count()` 共享 `count`。

下面是程序的运行示例：
```c
Enter a positive integer (0 to quit): 5
loop cycle: 1
subtotal:
```
# 随机数函数和静态变量

学习了不同存储类别的概念后，我们来看几个相关的程序。首  
先，来看一个使用内部链接的静态变量的函数：随机数函数。ANSI C  
库提供了`rand()` 函数生成随机数。生成随机数有多种算法，ANSI C  
允许C实现针对特定机器使用最佳算法。然而，ANSI C标准还提供了  
一个可移植的标准算法，在不同系统中生成相同的随机数。实际上，  
`rand()` 是“伪随机数生成器”，意思是可预测生成数字的实际序列。  
但是，数字在其取值范围内均匀分布。

为了看清楚程序内部的情况，我们使用可移植的ANSI版本，而不  
是编译器内置的`rand()` 函数。可移植版本的方案开始于一个“种子”  
数字。该函数使用该种子生成新的数，这个新数又成为新的种子。然  
后，新种子可用于生成更新的种子，以此类推。该方案要行之有效，  
随机数函数必须记录它上一次被调用时所使用的种子。这里需要一个  
静态变量。rand0.c演示了版本0（稍后给出版本1）。
```c
/* rand0.c --生成随机数*/  
/* 使用 ANSI C 可移植算法 */
static unsigned long int next = 1; /* 种子 */

unsigned int rand0(void)
{
    /* 生成伪随机数的魔术公式 */
    next = next * 1103515245 + 12345;
    return (unsigned int) (next / 65536) % 32768;
}
```

在rand0.c中，静态变量`next` 的初始值是1 ，其值在每次  
调用`rand0()` 函数时都会被修改（通过魔术公式）。该函数是用于返  
回一个0～32767之间的值。注意，`next` 是具有内部链接的静态变量  
（并非无链接）。这是为了方便稍后扩展本例，供同一个文件中的其  
他函数共享。

程序清单12.8是测试`rand0()` 函数的一个简单的驱动程序。

程序清单12.8　r_drive0.c 驱动程序  
```c
/* r_drive0.c -- 测试 rand0()函数 _/  
/_ 与 rand0.c 一起编译*/
#include <stdio.h>
extern unsigned int rand0(void);

int main(void)
{
    int count;
    for (count = 0; count < 5; count++)
        printf("%d\n", rand0());
    return 0;
}
```

该程序也需要多文件编译。程序清单12.7和程序清单12.8分别使  
用一个文件。程序清单12.8中的`extern` 关键字提醒读者`rand0()` 被  
定义在其他文件中，在这个文件中不要求写出该函数定义。输出如  
下：

text

```
16838
5758
10113
17515
31051
```

程序输出的数字看上去是随机的，再次运行程序后，输出如下：

text

```
16838
5758
10113
17515
31051
```

看来，这两次的输出完全相同，这体现了“伪随机”的一个方面。  
每次主程序运行，都开始于相同的种子1 。可以引入另一个函数  
`srand1()` 重置种子来解决这个问题。关键是要让`next` 成为只供  
`rand1()` 和`srand1()` 访问的内部链接静态变量（`srand1()` 相当  
于C库中的`srand()` 函数）。把`srand1()` 加入`rand1()` 所在的文  
件中。程序清单12.9给出了修改后的文件。

程序清单12.9　s_and_r.c 文件程序  


C

```
/* s_and_r.c -- 包含 rand1() 和 srand1() 的文件 _/  
/_ 使用 ANSI C 可移植算法 */
static unsigned long int next = 1; /* 种子 */

int rand1(void)
{
    /*生成伪随机数的魔术公式*/
    next = next * 1103515245 + 12345;
    return (unsigned int) (next / 65536) % 32768;
}

void srand1(unsigned int seed)
{
    next = seed;
}
```

注意，`next` 是具有内部链接的文件作用域静态变量。这意味着  
`rand1()` 和`srand1()` 都可以使用它，但是其他文件中的函数无法  
访问它。使用程序清单12.10的驱动程序测试这两个函数。

程序清单12.10　r_drive1.c 驱动程序  
/* r_drive1.c -- 测试 rand1() 和 srand1() _/  
/_ 与 s_and_r.c 一起编译 */

C

```
/* r_drive1.c -- 测试 rand1() 和 srand1() _/  
/_ 与 s_and_r.c 一起编译 */
#include <stdio.h>
#include <stdlib.h>
extern void srand1(unsigned int x);
extern int rand1(void);

int main(void)
{
    int count;
    unsigned seed;
    printf("Please enter your choice for seed.\n");
    while (scanf("%u", &seed) == 1)
    {
        srand1(seed); /* 重置种子 */
        for (count = 0; count < 5; count++)
            printf("%d\n", rand1());
        printf("Please enter next seed (q to quit):\n");
    }
    printf("Done\n");
    return 0;
}
```

编译两个文件，运行该程序后，其输出如下：

text

```
Please enter your choice for seed.
1
16838
5758
10113
17515
31051
Please enter next seed (q to quit):
513
20067
23475
8955
20841
15324
Please enter next seed (q to quit):
q
Done
```

设置`seed` 的值为1 ，输出的结果与前面程序相同。但是设置  
`seed` 的值为513 后就得到了新的结果。

**自动重置种子**

如果C实现允许访问一些可变的量（如，时钟系统），可以用这些值（可能会被截断）  
初始化种子值。例如，ANSI C有一个`time()` 函数返回系统时间。虽然时间单元因系统而  
异，但是重点是该返回值是一个可进行运算的类型，而且其值随着时间变化而变化。  
`time()` 返回值的类型名是`time_t` ，具体类型与系统有关。这没关系，我们可以使用强制  
类型转换：

C

```
#include <time.h> /* 提供time()的ANSI原型*/
srand1((unsigned int) time(0)); /* 初始化种子 */
```

一般而言，`time()` 接受的参数是一个`time_t` 类型对象的地址，而时间值就储存在传  
入的地址上。当然，也可以传入空指针（0）作为参数，这种情况下，只能通过返回值机制  
来提供值。

可以把这个技巧应用于标准的ANSI C函数`srand()` 和`rand()`  
中。如果使用这些函数，要在文件中包含`stdlib.h` 头文件。实际  
上，既然已经明白了`srand1()` 和`rand1()` 如何使用内部链接的静  
态变量，你也可以使用编译器提供的版本。我们将在下一个示例中这  
样做。

## 12.3　掷骰子

我们将要模拟一个非常流行的游戏——掷骰子。骰子的形式多种  
多样，最普遍的是使用两个6面骰子。在一些冒险游戏中，会使用5种  
骰子：4面、6面、8面、12面和20面。聪明的古希腊人证明了只有5种  
正多面体，它们的所有面都具有相同的形状和大小。各种不同类型的  
骰子就是根据这些正多面体发展而来。也可以做成其他面数的，但是  
其所有的面不会都相等，因此各个面朝上的几率就不同。

计算机计算不用考虑几何的限制，所以可以设计任意面数的电子  
骰子。我们先从6面开始。

我们想获得1～6的随机数。然而，`rand()` 生成的随机数在0 ～  
`RAND_MAX` 之间。`RAND_MAX` 被定义在`stdlib.h` 中，其值通常是  
`INT_MAX` 。因此，需要进行一些调整，方法如下。

1．把随机数求模6，获得的整数在0～5之间。  
2．结果加1，新值在1～6之间。  
3．为方便以后扩展，把第1步中的数字6替换成骰子面数。

下面的代码实现了这3个步骤：

C

```
#include <stdlib.h> /* 提供rand()的原型 */

int rollem(int sides)
{
    int roll;
    roll = rand() % sides + 1;
    return roll;
}
```

我们还想用一个函数提示用户选择任意面数的骰子，并返回点数  
总和。如程序清单12.11所示。

程序清单12.11　diceroll.c 程序  

C

```
/* diceroll.c -- 掷骰子模拟程序 _/  
/_ 与 mandydice.c 一起编译 */
#include "diceroll.h"
#include <stdio.h>
#include <stdlib.h> /* 提供库函数 rand()的原型 */

int roll_count = 0; /* 外部链接 */

static int rollem(int sides) /* 该函数属于该文件私有 */
{
    int roll;
    roll = rand() % sides + 1;
    ++roll_count; /* 计算函数调用次数 */
    return roll;
}

int roll_n_dice(int dice, int sides)
{
    int d;
    int total = 0;
    if (sides < 2)
    {
        printf("Need at least 2 sides.\n");
        return -2;
    }
    if (dice < 1)
    {
        printf("Need at least 1 die.\n");
        return -1;
    }
    for (d = 0; d < dice; d++)
        total += rollem(sides);
    return total;
}
```

该文件加入了新元素。第一，`rollem()` 函数属于该文件私有，  
它是`roll_n_dice()` 的辅助函数。第二，为了演示外部链接的特  
性，该文件声明了一个外部变量`roll_count` 。该变量统计调用  
`rollem()` 函数的次数。这样设计有点蹩脚，仅为了演示外部变量的  
特性。第三，该文件包含以下预处理指令：  
`#include "diceroll.h"`

如果使用标准库函数，如`rand()` ，要在当前文件中包含标准头  
文件（对`rand()` 而言要包含`stdlib.h` ），而不是声明该函数。因  
为头文件中已经包含了正确的函数原型。我们效仿这一做法，把  
`roll_n_dice()` 函数的原型放在`diceroll.h` 头文件中。把文件名  
放在双引号中而不是尖括号中，指示编译器在本地查找文件，而不是  
到编译器存放标准头文件的位置去查找文件。“本地查找”的含义取决  
于具体的实现。一些常见的实现把头文件与源代码文件或工程文件  
（如果编译器使用它们的话）放在相同的目录或文件夹中。程序清单  
12.12是头文件中的内容。

程序清单12.12　diceroll.h 文件  


C


```
//diceroll.h
extern int roll_count;
int roll_n_dice(int dice, int sides);
```

该头文件中包含一个函数原型和一个`extern` 声明。由于  
`diceroll.c` 文件包含了该文件，`diceroll.c` 实际上包含了  
`roll_count` 的两个声明：  
`extern int roll_count;` // 头文件中的声明（引用式声明）  
`int roll_count = 0;` // 源代码文件中的声明（定义式声明）

这样做没问题。一个变量只能有一个定义式声明，但是带  
`extern` 的声明是引用式声明，可以有多个引用式声明。

使用`roll_n_dice()` 函数的程序都要包含`diceroll.h` 头文  
件。包含该头文件后，程序便可使用`roll_n_dice()` 函数和  
`roll_count` 变量。如程序清单12.13所示。

程序清单12.13　manydice.c 文件  


C

```
/* manydice.c -- 多次掷骰子的模拟程序 _/  
/_ 与 diceroll.c 一起编译*/
#include <stdio.h>
#include <stdlib.h> /* 为库函数 srand() 提供原型 */
#include <time.h> /* 为 time() 提供原型 */
#include "diceroll.h" /* 为roll_n_dice()提供原型，为roll_count变
量提供声明 */

int main(void)
{
    int dice, roll;
    int sides;
    int status;
    srand((unsigned int) time(0)); /* 随机种子 */
    printf("Enter the number of sides per die, 0 to stop.\n");
    while (scanf("%d", &sides) == 1 && sides > 0)
    {
        printf("How many dice?\n");
        if ((status = scanf("%d", &dice)) != 1)
        {
            if (status == EOF)
                break; /* 退出循环 */
            else
            {
                printf("You should have entered an integer.");
                printf(" Let's begin again.\n");
                while (getchar() != '\n')
                    continue; /* 处理错误的输入 */
                printf("How many sides? Enter 0 to stop.\n");
                continue; /* 进入循环的下一轮迭代 */
            }
        }
        roll = roll_n_dice(dice, sides);
        printf("You have rolled a %d using %d %d-sided dice.\n",
               roll, dice, sides);
        printf("How many sides? Enter 0 to stop.\n");
    }
    printf("The rollem() function was called %d times.\n",
           roll_count); /* 使用外部变量 */
    printf("GOOD FORTUNE TO YOU!\n");
    return 0;
}
```

要与包含程序清单12.11的文件一起编译该文件。可以把程序清单  
12.11、12.12和12.13都放在同一文件夹或目录中。运行该程序，下面  
是一个输出示例：

text

```
Enter the number of sides per die, 0 to stop.
6
How many dice?
2
You have rolled a 12 using 2 6-sided dice.
How many sides? Enter 0 to stop.
6
How many dice?
2
You have rolled a 4 using 2 6-sided dice.
How many sides? Enter 0 to stop.
6
How many dice?
2
You have rolled a 5 using 2 6-sided dice.
How many sides? Enter 0 to stop.
0
The rollem() function was called 6 times.
GOOD FORTUNE TO YOU!
```

因为该程序使用了`srand()` 随机生成随机数种子，所以大多数情  
况下，即使输入相同也很难得到相同的输出。注意，`manydice.c` 中  
的`main()` 访问了定义在`diceroll.c` 中的`roll_count` 变量。

有3种情况可以导致外层`while` 循环结束：`side` 小于1 、输入类  
型不匹配（此时`scanf()` 返回0 ）、遇到文件结尾（返回值是`EOF`  
）。对于读取骰子的点数，该程序处理文件结尾的方式（退出`while`  
循环）与处理类型不匹配（进入循环的下一轮迭代）的情况不同。

可以通过多种方式使用`roll_n_dice()` 。`sides` 等于2 时，程  
序模仿掷硬币，“正面朝上”为2 ，“反面朝上”为1 （或者反过来表示也  
行）。很容易修改该程序单独显示点数的结果，或者构建一个骰子模  
拟器。如果要掷多次骰子（如在一些角色扮演类游戏中），可以很容  
易地修改程序以输出类似的结果：

text

```
Enter the number of sets; enter q to stop.
18
How many sides and how many dice?
6 3
Here are 18 sets of 3 6-sided throws.
12 10 6 9 8 14 8 15 9 14 12 17 11 7 10
13 8 14
How many sets? Enter q to stop.
q
```

`rand1()` 或`rand()` （不是`rollem()` ）还可以用来创建一个  
猜数字程序，让计算机选定一个数字，你来猜。读者感兴趣的话可以  
自己编写这个程序。
## 12.4　分配内存：malloc() 和 free()

我们前面讨论的存储类别有一个共同之处：在确定用哪种存储类别后，根据已制定好的内存管理规则，将自动选择其作用域和存储期。然而，还有更灵活地选择，即用库函数分配和管理内存。

首先，回顾一下内存分配。所有程序都必须预留足够的内存来储存程序使用的数据。这些内存中有些是自动分配的。例如，以下声明：

C

```
float x;  // 自动分配一个 float 类型的内存
char place[] = "Dancing Oxen Creek";  // 自动分配一个字符串数组
```

为一个 float 类型的值和一个字符串预留了足够的内存，或者可以显式指定分配一定数量的内存：

C

```
int plates[100];  // 分配100个int类型的内存空间
```

该声明预留了100个内存位置，每个位置都用于储存 int 类型的值。声明还为内存提供了一个标识符。因此，可以使用 x 或 place 识别数据。回忆一下，静态数据在程序载入内存时分配，而自动数据在程序执行块时分配，并在程序离开该块时销毁。

C 能做的不止这些。可以在程序运行时分配更多的内存。主要的工具是 `malloc()` 函数，该函数接受一个参数：所需的内存字节数。`malloc()` 函数会找到合适的空闲内存块，这样的内存是匿名的。也就是说，`malloc()` 分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。因此，可以把该地址赋给一个指针变量，并使用指针访问这块内存。

因为 char 表示1字节，`malloc()` 的返回类型通常被定义为指向 char 的指针。然而，从 ANSI C 标准开始，C 使用一个新的类型：指向 void 的指针。该类型相当于一个“通用指针”。`malloc()` 函数可用于返回指向数组的指针、指向结构的指针等，所以通常该函数的返回值会被强制转换为匹配的类型。在 ANSI C 中，应该坚持使用强制类型转换，提高代码的可读性。然而，把指向 void 的指针赋给任意类型的指针完全不用考虑类型匹配的问题。

如果 `malloc()` 分配内存失败，将返回空指针。

---

### 动态分配数组的示例

我们试着用 `malloc()` 创建一个数组。除了用 `malloc()` 在程序运行时请求一块内存，还需要一个指针记录这块内存的位置。例如，考虑下面的代码：

C

```
double * ptd;
ptd = (double *) malloc(30 * sizeof(double));  // 分配30个double类型的内存空间
```

> 注释：为30个 double 类型的值请求内存空间，并设置 ptd 指向该位置。

注意，指针 ptd 被声明为指向一个 double 类型，而不是指向内含30个 double 类型值的块。回忆一下，数组名是该数组首元素的地址。因此，如果让 ptd 指向这个块的首元素，便可像使用数组名一样使用它。也就是说，可以使用表达式 ptd[0] 访问该块的首元素，ptd[1] 访问第2个元素，以此类推。

---

### 创建数组的三种方法

1. **静态/自动数组**  
    声明数组时，用常量表达式表示数组的维度，用数组名访问数组的元素。可以用静态内存或自动内存创建这种数组。
    
2. **变长数组（C99）**  
    声明变长数组时，用变量表达式表示数组的维度，用数组名访问数组的元素。具有这种特性的数组只能在自动内存中创建。
    
3. **动态数组（malloc）**  
    声明一个指针，调用 `malloc()`，将其返回值赋给指针，使用指针访问数组的元素。该指针可以是静态的或自动的。
    

---

### 动态数组的灵活性

使用第2种和第3种方法可以创建动态数组。这种数组和普通数组不同，可以在程序运行时选择数组的大小和分配内存。例如，假设 n 是一个整型变量。在 C99 之前，不能这样做：

C

```
double item[n]; /* C99之前：n不允许是变量 */
```

但是，可以这样做：

C

```
ptd = (double *) malloc(n * sizeof(double)); /* 可以 */
```

---

### malloc() 和 free() 的配合使用

通常，`malloc()` 要与 `free()` 配套使用。`free()` 函数的参数是之前 `malloc()` 返回的地址，该函数释放之前 `malloc()` 分配的内存。因此，动态分配内存的存储期从调用 `malloc()` 分配内存到调用 `free()` 释放内存为止。

> 设想 `malloc()` 和 `free()` 管理着一个内存池。每次调用 `malloc()` 分配内存给程序使用，每次调用 `free()` 把内存归还内存池中，这样便可重复使用这些内存。`free()` 的参数应该是一个指针，指向由 `malloc()` 分配的一块内存。不能用 `free()` 释放通过其他方式（如，声明一个数组）分配的内存。`malloc()` 和 `free()` 的原型都在 `stdlib.h` 头文件中。

---

### 动态分配数组的完整示例

**程序清单12.14　dyn_arr.c 程序**

C

```
#include <stdio.h>
#include <stdlib.h> /* 为 malloc()、free() 提供原型 */

int main(void)
{
    double * ptd;  // 指向动态分配的数组
    int max;
    int number;
    int i = 0;

    puts("What is the maximum number of type double entries?");
    if (scanf("%d", &max) != 1)
    {
        puts("Number not correctly entered -- bye.");
        exit(EXIT_FAILURE);  // 输入错误，退出程序
    }

    ptd = (double *) malloc(max * sizeof(double));  // 动态分配内存
    if (ptd == NULL)
    {
        puts("Memory allocation failed. Goodbye.");
        exit(EXIT_FAILURE);  // 分配失败，退出程序
    }

    /* ptd 现在指向有max个元素的数组 */
    puts("Enter the values (q to quit):");
    while (i < max && scanf("%lf", &ptd[i]) == 1)
        ++i;

    printf("Here are your %d entries:\n", number = i);
    for (i = 0; i < number; i++)
    {
        printf("%7.2f ", ptd[i]);
        if (i % 7 == 6)
            putchar('\n');
    }
    if (i % 7 != 0)
        putchar('\n');
    puts("Done.");

    free(ptd);  // 释放动态分配的内存
    return 0;
}
```

**程序运行示例**

text

```
What is the maximum number of entries?
5
Enter the values (q to quit):
20 30 35 25 40 80
Here are your 5 entries:
  20.00   30.00   35.00   25.00   40.00
Done.
```

---

### free() 的重要性

静态内存的数量在编译时是固定的，在程序运行期间也不会改变。自动变量使用的内存数量在程序执行期间自动增加或减少。但是动态分配的内存数量只会增加，除非用 `free()` 进行释放。

**内存泄漏示例：**

C

```
void gobble(double ar[], int n)
{
    double * temp = (double *) malloc( n * sizeof(double));
    ... /* free(temp); // 假设忘记使用free() */
}
```

> 注释：如果忘记调用 free(temp)，每次调用 gobble() 都会分配新的内存，但无法释放，导致内存泄漏。

---

### calloc() 函数

分配内存还可以使用 `calloc()`，典型的用法如下：

C

```
long * newmem;
newmem = (long *)calloc(100, sizeof(long));  // 分配100个long类型的内存空间，并初始化为0
```

> 注释：calloc() 会把分配的内存全部置为0。

---

### 动态内存分配和变长数组

变长数组（VLA）和调用 `malloc()` 在功能上有些重合。例如，两者都可用于创建在运行时确定大小的数组：

C

```
int vlamal()
{
    int n;
    int * pi;
    scanf("%d", &n);
    pi = (int *) malloc (n * sizeof(int));  // 动态分配
    int ar[n];  // 变长数组
    pi[2] = ar[2] = -5;
    ...
}
```

> 注释：变长数组是自动存储类型，离开块时自动释放；malloc() 分配的内存需手动释放。

---

### 多维数组的动态分配

对于多维数组，可以这样分配：

C

```
int n = 5;
int m = 6;
int (* p2)[6];  // 指向含6个int的数组
int (* p3)[m];  // 指向含m个int的数组（要求支持VLA）

p2 = (int (*)[6]) malloc(n * 6 * sizeof(int));  // n×6 数组
p3 = (int (*)[m]) malloc(n * m * sizeof(int));  // n×m 数组
```

> 注释：p2[i][j] 访问二维数组元素。

---

### 存储类别和动态内存分配

可以认为程序把它可用的内存分为 3部分：

- 一部分供具有外部链接、内部链接和无链接的静态变量使用；
- 一部分供自动变量使用；
- 一部分供动态内存分配。

静态存储类别所用的内存数量在编译时确定，只要程序还在运行，就可访问储存在该部分的数据。自动存储类别的变量在程序进入变量定义所在块时存在，在程序离开块时消失。动态分配的内存在调用 `malloc()` 或相关函数时存在，在调用 `free()` 后释放。这部分的内存由程序员管理。

---

### 存储区域示例

**程序清单12.15　where.c 程序**

C

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int static_store = 30;
const char * pcg = "String Literal";

int main()
{
    int auto_store = 40;
    char auto_string [] = "Auto char Array";
    int * pi;
    char * pcl;

    pi = (int *) malloc(sizeof(int));
    *pi = 35;

    pcl = (char *) malloc(strlen("Dynamic String") + 1);
    strcpy(pcl, "Dynamic String");

    printf("static_store: %d at %p\n", static_store, &static_store);
    printf(" auto_store: %d at %p\n", auto_store, &auto_store);
    printf(" *pi: %d at %p\n", *pi, pi);
    printf(" %s at %p\n", pcg, pcg);
    printf(" %s at %p\n", auto_string, auto_string);
    printf(" %s at %p\n", pcl, pcl);
    printf(" %s at %p\n", "Quoted String", "Quoted String");

    free(pi);
    free(pcl);
    return 0;
}
```

**程序运行示例**

text

```
static_store: 30 at 00378000
auto_store: 40 at 0049FB8C
*pi: 35 at 008E9BA0
String Literal at 00375858
Auto char Array at 0049FB74
Dynamic String at 008E9BD0
Quoted String at 00375908
```

如上所示，静态数据（包括字符串字面量）占用一个区域，自动数据占用另一个区域，动态分配的数据占用第3个区域（通常被称为内存堆或自由内存）
## 12.5　ANSI C类型限定符

我们通常用类型和存储类别来描述一个变量。C90还新增了两个属性：恒常性（constancy）和易变性（volatility）。这两个属性可以分别用关键字`const`和`volatile`来声明，以这两个关键字创建的类型是**限定类型**（qualified type）。C99标准新增了第3个限定符：`restrict`，用于提高编译器优化。C11标准新增了第4个限定符：`_Atomic`。C11提供一个可选库，由`stdatomic.h`管理，以支持并发程序设计，而且`_Atomic`是可选支持项。

C99为类型限定符增加了一个新属性：它们现在是**幂等的**（idempotent）！这个属性的意思是可以在一条声明中多次使用同一个限定符，多余的限定符将被忽略：

C

```
const const const int n = 6; // 与 const int n = 6; 相同
```

有了这个新属性，就可以编写类似下面的代码：

C

```
typedef const int zip;
const zip q = 8;
```

---

### 12.5.1　const 类型限定符

以`const`关键字声明的对象，其值不能通过赋值或递增、递减来修改。例如：

C

```
const int nochange; /* 限定nochange的值不能被修改 */
nochange = 12;      /* 不允许，编译器会报错 */
```

但是，可以初始化`const`变量：

C

```
const int nochange = 12; /* 没问题 */
```

该声明让`nochange`成为只读变量。初始化后，就不能再改变它的值。

可以用`const`关键字创建不允许修改的数组：

C

```
const int days1[12] = {31,28,31,30,31,30,31,31,30,31,30,31};
```

#### 1. 在指针和形参声明中使用const

声明普通变量和数组时使用`const`关键字很简单。指针则复杂一些，因为要区分是限定指针本身为`const`还是限定指针指向的值为`const`。

C

```
const float * pf;   // pf 指向一个float类型的const值，pf本身可变
float * const pt;   // pt 是一个const指针，pt本身不可变，指向的值可变
const float * const ptr; // ptr本身和指向的值都不可变
float const * pfc;  // 与 const float * pfc; 相同
```

简而言之，`const`放在`*`左侧任意位置，限定了指针指向的数据不能改变；`const`放在`*`的右侧，限定了指针本身不能改变。

`const`关键字的常见用法是声明为函数形参的指针。例如：

C

```
void display(const int array[], int limit);
```

在函数原型和函数头，形参声明`const int array[]`与`const int * array`相同，表明不能更改array指向的数据。

ANSI C库遵循这种做法。如果一个指针仅用于给函数访问值，应将其声明为一个指向`const`限定类型的指针。如果要用指针更改主调函数中的数据，就不使用`const`关键字。例如，ANSI C中的`strcat()`原型如下：

C

```
char *strcat(char * restrict s1, const char * restrict s2);
```

#### 2. 对全局数据使用const

使用全局变量是一种冒险的方法，因为这样做暴露了数据，程序的任何部分都能更改数据。如果把数据设置为`const`，就可避免这样的危险，因此用`const`限定符声明全局数据很合理。

可以创建`const`变量、`const`数组和`const`结构。例如：

C

```
/* file1.c -- 定义了一些外部const变量 */
const double PI = 3.14159;
const char * MONTHS[12] = { "January", "February", "March", ... };
```

在其他文件中使用引用式声明：

C

```
extern const double PI;
extern const char * MONTHS[];
```

另一种方案是，把`const`变量放在一个头文件中，然后在其他文件中包含该头文件：

C

```
/* constant.h -- 定义了一些外部const变量 */
static const double PI = 3.14159;
static const char * MONTHS[12] = { "January", "February", ... };
```

这种方案必须在头文件中用关键字`static`声明全局`const`变量。这样每个文件有自己的副本，互不影响。

---

### 12.5.2　volatile 类型限定符

`volatile`限定符告知计算机，代理（而不是变量所在的程序）可以改变该变量的值。通常，它被用于硬件地址以及在其他程序或同时运行的线程中共享数据。例如：

C

```
volatile int loc1;      // loc1 是一个易变的位置
volatile int * ploc;    // ploc 是一个指向易变位置的指针
```

`volatile`的目的是警告编译器不要进行假定的优化。例如：

C

```
val1 = x;
/* 一些不使用 x 的代码*/
val2 = x;
```

如果x是`volatile`，编译器不会假定x的值不变，每次都从内存读取。

可以同时用`const`和`volatile`限定一个值：

C

```
volatile const int loc;
const volatile int * ploc;
```

---

### 12.5.3　restrict 类型限定符

`restrict`关键字允许编译器优化某部分代码以更好地支持计算。它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。

C

```
int ar[10];
int * restrict restar = (int *) malloc(10 * sizeof(int));
int * par = ar;
```

在循环中：

C

```
for (n = 0; n < 10; n++)
{
    par[n] += 5;
    restar[n] += 5;
    ar[n] *= 2;
    par[n] += 3;
    restar[n] += 3;
}
```

由于`restar`是唯一且初始的方式，编译器可以优化：

C

```
restar[n] += 8; // 可以优化
```

而`par`不能这样优化，因为`ar`也能访问同一数据。

`restrict`限定符还可用于函数形参中的指针。例如：

C

```
void * memcpy(void * restrict s1, const void * restrict s2, size_t n);
void * memmove(void * s1, const void * s2, size_t n);
```

---

### 12.5.4　_Atomic 类型限定符（C11）

并发程序设计把程序执行分成可以同时执行的多个线程。C11通过包含可选的头文件`stdatomic.h`和`threads.h`，提供了一些可选的管理方法。

C

```
_Atomic int hogs; // hogs 是一个原子类型的变量
atomic_store(&hogs, 12); // stdatomic.h中的宏
```

---

### 12.5.5　旧关键字的新位置

C99允许把类型限定符和存储类别说明符`static`放在函数原型和函数头的形式参数的初始方括号中。例如：

C

```
void ofmouth(int * const a1, int * restrict a2, int n); // 以前的风格
void ofmouth(int a1[const], int a2[restrict], int n);   // C99允许
```

`static`的新用法：

C

```
double stick(double ar[static 20]);
```

> 表明实际参数应该是一个指向数组首元素的指针，且该数组至少有20个元素。

---

## 12.6　关键概念

C提供多种管理内存的模型。除了熟悉这些模型外，还要学会如何选择不同的类别。大多数情况下，最好选择自动变量。如果要使用其他类别，应该有充分的理由。通常，使用自动变量、函数形参和返回值进行函数间的通信比使用全局变量安全。但是，保持不变的数据适合用全局变量。

应该尽量理解静态内存、自动内存和动态分配内存的属性。尤其要注意：静态内存的数量在编译时确定；静态数据在载入程序时被载入内存。在程序运行时，自动变量被分配或释放，所以自动变量占用的内存数量随着程序的运行会不断变化。可以把自动内存看作是可重复利用的工作区。动态分配的内存也会增加和减少，但是这个过程由函数调用控制，不是自动进行的。

---

## 12.7　本章小结

内存用于存储程序中的数据，由存储期、作用域和链接表征。

- **存储期**可以是静态的、自动的或动态分配的。
    
    - 静态存储期：在程序开始执行时分配内存，并在程序运行时都存在。
    - 自动存储期：在程序进入变量定义所在块时分配变量的内存，在程序离开块时释放内存。
    - 动态分配存储期：在调用`malloc()`（或相关函数）时分配内存，在调用`free()`函数时释放内存。
- **作用域**决定程序的哪些部分可以访问某数据。
    
    - 定义在所有函数之外的变量具有文件作用域，对位于该变量声明之后的所有函数可见。
    - 定义在块或作为函数形参内的变量具有块作用域，只对该块以及它包含的嵌套块可见。
- **链接**描述定义在程序某翻译单元中的变量可被链接的程度。
    
    - 具有块作用域的变量是局部变量，无链接。
    - 具有文件作用域的变量可以是内部链接或外部链接。
    - 内部链接：只有其定义所在的文件才能使用该变量。
    - 外部链接：其他文件也可以使用该变量。

**C的5种存储类别（不包括线程的概念）：**

- 自动 —— 在块中不带存储类别说明符或带`auto`存储类别说明符声明的变量（或作为函数头中的形参）属于自动存储类别，具有自动存储期、块作用域、无链接。如果未初始化自动变量，它的值是未定义的。
- 寄存器 —— 在块中带`register`存储类别说明符声明的变量（或作为函数头中的形参）属于寄存器存储类别，具有自动存储期、块作用域、无链接，且无法获取其地址。把一个变量声明为寄存器变量即请求编译器将其储存到访问速度最快的区域。如果未初始化寄存器变量，它的值是未定义的。
- 静态、无链接 —— 在块中带`static`存储类别说明符声明的变量属于“静态、无链接”存储类别，具有静态存储期、块作用域、无链接。只在编译时被初始化一次。如果未显式初始化，它的字节都被设置为0。
- 静态、外部链接 —— 在所有函数外部且没有使用`static`存储类别说明符声明的变量属于“静态、外部链接”存储类别，具有静态存储期、文件作用域、外部链接。只能在编译器被初始化一次。如果未显式初始化，它的字节都被设置为0。
- 静态、内部链接 —— 在所有函数外部且使用了`static`存储类别说明符声明的变量属于“静态、内部链接”存储类别，具有静态存储期、文件作用域、内部链接。只能在编译器被初始化一次。如果未显式初始化，它的字节都被设置为0。

动态分配的内存由`malloc()`（或相关）函数分配，该函数返回一个指向指定字节数内存块的指针。这块内存被`free()`函数释放后便可重复使用，`free()`函数以该内存块的地址作为参数。

**类型限定符**

- `const`：限定数据在程序运行时不能改变。对指针使用`const`时，可限定指针本身不能改变或指针指向的数据不能改变，这取决于`const`在指针声明中的位置。
- `volatile`：表明限定的数据除了被当前程序修改外还可以被其他进程修改。该限定符的目的是警告编译器不要进行假定的优化。
- `restrict`：也是为了方便编译器设置优化方案。`restrict`限定的指针是访问它所指向数据的唯一途径。
- `_Atomic`：用于并发程序设计，保证原子操作。
