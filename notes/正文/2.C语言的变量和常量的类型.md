变量与常量数据
有些数据类型在程序使用之前已经预先设定好了，在整个程序的运行过程中没有变化，这些称为常量 （constant ）。其他数据类型在程序运行期间可能会改变或被赋值，这些称为变量 （variable ）
# 基本类型关键字

| 最初K&R给出的关键字 | C90 标准添加的关键字 | C99 标准添加的关键字 |
| ----------- | ------------ | ------------ |
| int         | signed       | _Bool        |
| long        | void         | _Complex     |
| short       |              | _Imaginary   |
| unsigned    |              |              |
| char        |              |              |
| float       |              |              |
| double      |              |              |

在C语言中，用int 关键字来表示基本的整数类型。后3个关键字 （long 、short 和unsigned ）和C90新增的signed 用于提供基本整数类型的变式，例如unsigned short int 和long long int 。char 关键字用于指定字母和其他字符（如，# 、$ 、% 和 *）。另外，char 类型也可以表示较小的整数。float 、double 和 long double 表示带小数点的数。_Bool 类型表示布尔值（true 或false ），_Complex 和_Imaginary 分别表示复数和虚数。

# 整数与浮点数的区别
1.整数没有小数部分，浮点数有小数部分。
2.浮点数可以表示的范围比整数大。参见本章末的表3.3。
3.对于一些算术运算（如，两个很大的数相减），浮点数损失的精度更多。因为在任何区间内（如，1.0到2.0之间）都存在无穷多个实数， 所以计算机的浮点数不能表示区间内所有的值。浮点数通常只是实际值的近似值。例如，7.0可能被储存为浮点值6.99999。稍后会讨论更多精度方面的内容。
4.过去，浮点运算比整数运算慢。不过，现在许多CPU都包含浮点处理器，缩小了速度上的差距
# C语言基本类型
## 整数：int 类型
int 类型是有符号整型，即==int 类型的值必须是整数==，可以是正整数、负整数或零。其取值范围依计算机系统而异。一般而言，==储存一个int 要占用一个机器字长==。因此，早期的16位IBM PC兼容机使用 16位来储存一个int 值，其取值范围（即int 值的取值范围） 是-32768 ～32767 。目前的个人计算机一般是32位，因此用32位储存一个int 值。现在，个人计算机产业正逐步向着64位处理器发展， 自然能储存更大的整数。ISO C规定int 的取值范围最小为-32768 ～32767 。
### 1．声明int 变量
第2章中已经用int 声明过基本整型变量。==先写上int ，然后写变量名，最后加上一个分号==。要声明多个变量，可以单独声明每个变量，也可在int 后面列出多个变量名，变量名之间用逗号分隔。下面都是有效的声明：
```
int erns;
int hogs, cows, goats;
```
可以分别在4条声明中声明各变量，也可以在一条声明中声明4个变量。两种方法的效果相同，都为4个int 大小的变量赋予名称并分配内存空间。以上声明创建了变量，但是并没有给它们提供值。变量如何获得值？前面介绍过在程序中获取值的两种途径。第1种途径是赋值：第1种途径是==赋值==， 第2种途径是，==通过函数（如，scanf() ）获得值==。接下来，我们着重介绍第3种途径。
### 2．初始化变量
初始化 （initialize ）变量就是为变量赋一个初始值。==在C语言中，初始化可以直接在声明中完成。只需在变量名后面加上赋值运算符（=）和待赋给变量的值即可==。如下所示：
```c
int hogs = 21;
int cows = 32, goats = 14;
int dogs, cats = 94; /* 有效，但是这种格式很糟糕
*/
```
以上示例的最后一行，只初始化了cats ，并未初始化dogs 。这种写法很容易让人误认为dogs 也被初始化为94 ，所以最好不要把初始化的变量和未初始化的变量放在同一条声明中。
简而言之，声明为变量创建和标记存储空间（内存），并为其指定初始值 
### 3.int 类型常量
上面示例中出现的整数（21、32、14和94）都是整型常量或整型字面量。C语言把不含小数点和指数的数作为整数。C语言把大多数整型常量视为int 类型，但是非常大的整数除外。

### 4．打印int 值
可以使用printf() 函数打印int 类型的值。第2章中介绍过， %d 指明了在一行中打印整数的位置。%d 称为转换说明 ，它指定了 printf() 应使用什么格式来显示一个值。格式化字符串中的每个%d 都与待打印变量列表中相应的int 值匹配。%% 如果不匹配会随机输出一个值 %%
### 5．二进制和八进制和十六进制
通常，C语言都假定整型常量是十进制数。然而，许多程序员很喜欢使用八进制和十六进制数。因为8和16都是2的幂，另外，十六进制数的每一位的数恰好由4位二进制数表示，这种对应关系使得十六进制和二进制的转换非常方便。
**在C语言中，用特定的前缀表示使用哪种进制。**
0x或0X前缀表示十六进制值
0前缀表示八进制
0b或0B前缀表示二进制

**显示八进制和十六进制**
在C程序中，既可以使用也可以显示不同进制的数。不同的进制要使用不同的转换说明。以==十进制显示数字，使用%d== ；以==八进制显示数字，使用%o== ；以==十六进制显示数字，使用%x== ，。另外，==要显示各进制数的前缀0 、0x 和0X ，必须分别使用%#o 、%#x 、%#X== 。%% 以上是针对int类型的，其他类型有所不同，还要注意二进制无直接的转换说明%%
## 
其他整数类型
### 分类
short int 类型（或者简写为short ）占用的存储空间可能比 int 类型少，常用于较小数值的场合以节省空间。与int 类似， short 是有符号类型。

long int 或long 占用的存储空间可能比int 多，适用于较大数值的场合。与int 类似，long 是有符号类型。

long long int 或long long （C99标准加入）占用的储存空间可能比long 多，适用于更大数值的场合。该类型至少占64 位。与int 类似，long long 是有符号类型。

unsigned int 或unsigned 只用于非负值的场合。这种类型与有符号类型表示的范围不同。例如，16位unsigned int 允许的取值范围是0 ～65535 ，而不是-32768 ～32767 。用于表示正负号的位现在用于表示另一个二进制位，所以无符号整型可以表示更大的数。

在C90标准中，添加了unsigned long int 或unsigned long 和unsigned short int 或unsigned short 类型。 C99标准又添加了unsigned long long int 或unsigned long long 。

在任何有符号类型前面添加关键字signed ，可强调使用有符号类型的意图。例如，short 、short int 、signed short 、signed short int 都表示同一种类型。

### 声明其他整数类型
声明其他整数类型其他整数类型的声明方式与int 类型相同，下面列出了一些例子。不是所有的C编译器都能识别最后3条声明，最后一个例子所有的类型是C99标准新增的。
```c
long int estine;
long johns;
short int erns;
short ribs;
unsigned int s_count;
unsigned players;
unsigned long headcount;
unsigned short yesvotes;
long long ago;
```

### 使用多种整数类型的原因
为什么说short 类型“可能”比int 类型占用的空间少，long 类型“可能”比int 类型占用的空间多？因为C语言只规定了short 占用的存储空间不能多于int ，long 占用的存储空间不能少于int 。这样规定是为了适应不同的机器。现在，个人计算机上最常见的设置是，long long 占64位， long 占32位，short 占16位，int 占16位或32位
C标准对基本数据类型只规定了允许的最小大小。
int 类型那么多，应该如何选择？首先，考虑unsigned 类型。这种类型的数常用于计数，因为计数不用负数。而且，unsigned 类型可以表示更大的正数。
如果一个数超出了int 类型的取值范围，且在long 类型的取值范围内时，使用long 类型。然而，对于那些long 占用的空间比int 大的系统，使用long 类型会减慢运算速度。因此，如非必要，请不要使用long 类型。
另外要注意一点：如果在long 类型和int 类型占用空间相同的机器上编写代码，当确实需要32位的整数时，应使用 long 类型而不是int 类型，以便把程序移植到16位机后仍然可以正常工作。类似地，如果确实需要64位的整数，应使用long long 类型。
如果在int 设置为32位的系统中要使用16位的值，应使用short 类型以节省存储空间。通常，只有当程序使用相对于系统可用内存较大的整型数组时，才需要重点考虑节省空间的问题。使用short 类型的另一个原因是，计算机中某些组件使用的硬件寄存器是16位。
### long 常量和long long 常量
通常，程序代码中使用的数字（如，2345 ）都被储存为int 类型。如果超出了int 类型能表示的范围，编译器会将其视为long int 类型。如果数字超出long 可表示的最大值，编译器则将其视为 unsigned long 类型。如果还不够大，编译器则将其视为long long 或unsigned long long 类型。
八进制和十六进制常量被视为int 类型。如果值太大，编译器会尝试使用unsigned int 。如果还不够大，编译器会依次使用long 、unsigned long 、long long 和unsigned long long 类型。
有些情况下，需要编译器以long 类型储存一个小数字。例如， 编程时要显式使用IBM PC上的内存地址时。另外，一些C标准函数也整数溢出要求使用long 类型的值。要把一个较小的常量作为long 类型对待， 可以在值的末尾加上l （小写的L ）或L 后缀。使用L 后缀更好，因为l 看上去和数字1很像。l 或L 后缀也可用于八进制和十六进制整数，如020L 和0x10L 
类似地，在支持long long 类型的系统中，也可以使用ll 或LL 后缀来表示long long 类型的值，如3LL 。另外，u 或U 后缀表示 unsigned long long ，如5ull 、10LLU 、6LLU 或9Ull 
### 打印short 、long 、long long 和unsigned 类型
打印unsigned int 类型的值，使用%u 转换说明；打印long 类型的值，使用%ld 转换说明。在x 和o 前面可以使用l 前缀，%lx 表示以十六进制格式打印long 类型整数，%lo 表示以八进制格式打印long 类型整数。注意，虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能用小写。
语言有多种printf() 格式。对于short 类型，可以使用h 前缀。%hd 表示以十进制显示short 类型的整数，%ho 表示以八进制显示short 类型的整数。h 和l 前缀都可以和u 一起使用，用于表示无符号类型。例如，%lu 表示打印unsigned long 类型的值。对于支持long long 类型的系统，%lld 和%llu 分别表示有符号和无符号类型。
在给函数传递参数时，C编译器把short 类型的值自动转换成int 类型的值。
为什么要进行转换？答案是，int 类型被认为是计算机处理整数类型时最高效的类型。因此，在short 和int 类型的大小不同的计算机中，用int 类型的参数传递速度更快。
那h修饰符又有什么用？答案是，使用h 修饰符可以显示较大整数被截断成short 类型值的情况。例如把 65537 以二进制格式写成一个 32 位数00000000000000010000000000000001。如果使用%hd ， 提示 printf() 只会查看后16位，所以显示的值是1，使用%d则会显示65537，%ld和%lld也是一样的道理

## 字符:char 类型
char 类型用于储存字符（如，字母或标点符号），但是从技术层面看，char 是整数类型。因为char 类型实际上储存的是整数而不是字符。计算机使用数字编码来处理字符，即用特定的整数表示特定的字符。
标准ASCII码的范围是0～127，只需7位二进制数即可表示。通常，char 类型被定义为8位的存储单元，因此容纳标准ASCII码绰绰有余。
C语言把1字节定义为char 类型占用的位（bit ）数，因此无论是 16位还是32位系统，都可以使用char 类型。
### 声明char 类型变量
char 类型变量的声明方式与其他类型变量的声明方式相同。下面是一些例子：
```
char response;
char itable, latan;
```
### 字符常量和初始化
如果要把一个字符常量初始化为字母A ，不必背下ASCII码，用计算机语言很容易做到。通过以下初始化把字母A 赋给grade 即可：
```
char grade = 'A';
```
在C语言中，用单引号括起来的单个字符被称为字符常量 （character constant ）。编译器一发现'A '，就会将其转换成相应的代码值。单引号必不可少。
实际上，字符是以数值形式储存的，所以也可使用数字代码值来赋值：
```
char grade = 65; /* 对于ASCII，这样做没问题，但这是一种不好的编程风格 */
```
奇怪的是，C语言将字符常量视为int 类型而非char 类型。例如，在int 为32位、char 为8位的ASCII系统中，有下面的代码：
```
char grade = 'B';
```
本来'B '对应的数值66储存在32位的存储单元中，现在却可以储存在8位的存储单元中（grade ）。利用字符常量的这种特性，可以定义一个字符常量'FATE '，即把4个独立的8位ASCII码储存在一个32位存储单元中。如果把这样的字符常量赋给char 类型变量grade ，只有最后8位有效。因此，grade 的值是'E '。
### 非打印字符
单引号只适用于字符、数字和标点符号，浏览ASCII表会发现，有些ASCII字符打印不出来。例如，一些代表行为的字符（如，退格、换行、终端响铃或蜂鸣）。C语言提供了3种方法表示这些字符。
第1种方法前面介绍过——使用ASCII码。例如，蜂鸣字符的ASCII 值是7，因此可以这样写：
```
char beep = 7;
```
第2种方法是，使用特殊的符号序列表示一些特殊的字符。这些符号序列叫作转义序列 （escape sequence ）。
把转义序列赋给字符变量时，必须用单引号把转义序列括起来。例如，假设有下面一行代码：
```
char nerf = '\n';
```
稍后打印变量nerf 的效果是，在打印机或屏幕上另起一行。
转义序列如表所示

| 转义序列   | 含义                                       |
| ------ | ---------------------------------------- |
| `\a`   | 警报（ANSI C）                               |
| `\b`   | 退格                                       |
| `\f`   | 换页                                       |
| `\n`   | 换行                                       |
| `\r`   | 回车                                       |
| `\t`   | 水平制表符                                    |
| `\v`   | 垂直制表符                                    |
| `\\`   | 反斜杠（\）                                   |
| `\'`   | 单引号                                      |
| `\" `  | 双引号                                      |
| `\? `  | 问号                                       |
| `\0oo` | 八进制值（oo 必须是有效的八进制数，即每个o 可表示0 ～7 中的一个数）   |
| `\xhh` | 十六进制值（hh 必须是有效的十六进制数，即每个h 可表示0 ～f 中的一个数） |
使用C90新增的警报字符 （\a）是否能产生听到或看到的警报，取决于计算机的硬件，蜂鸣是最常见的警报（在一些系统中，警报字符不起作用）。C标准规定警报字符不得改变活跃位置。标准中的活跃位置 （active position ）指的是显示设备（屏幕、电传打字机、打印机等）中下一个字符将出现的位置。简而言之，平时常说的屏幕光标位置就是活跃位置。在程序中把警报字符输出在屏幕上的效果是，发出一声蜂鸣，但不会移动屏幕光标。
换页符（\f ）把活跃位置移至下一页的开始处；
换行符（\n ）把活跃位置移至下一行的开始处；
回车符（\r ）把活跃位置移动到当前行的开始处；
水平制表符（\t ）将活跃位置移至下一个水平制表点（通常是第1个、第9个、第17个、第25个等字符位置）；
垂直制表符（\v ）把活跃位置移至下一个垂直制表点。%% 这些字符是否有效取决于硬件支持  %%
接下来的3个转义序列（`\\` 、`\'` 、`\"` ）用于打印\ 、' 、" 字符（由于这些字符用于定义字符常量，是printf() 函数的一部分， 若直接使用它们会造成混乱）
表中的最后两个转义序列（\0oo 和\xhh ）是ASCII码的特殊表示。如果要用八进制ASCII码表示一个字符，可以在编码值前面加一个反斜杠（\）并用单引号括起来。例如，如果编译器不识别警报字符 （\a ），可以使用ASCII码来代替：
```
beep = '\007'
```
可以省略前面的0，'\07' 甚至'\7' 都可以。即使没有前缀0， 编译器在处理这种写法时，仍会解释为八进制。
从C90开始，不仅可以用十进制、八进制形式表示字符常量，C语言还提供了第3种选择——用十六进制形式表示字符常量，即反斜杠后面跟一个x或X，再加上1～3位十六进制数字。例如，Ctrl+P 字符的 ASCII十六进制码是10（相当于十进制的16），可表示为'\x10' 或'\x010'。
一些整数类型的不同进制形式。
![](附件/Pasted%20image%2020250928215401.png)
#### 注意事项
使用ASCII码时，注意数字和数字字符的区别。例如，字符4对应的ASCII码是52。'4' 表示字符4，而不是数值4。
无论是普通字符还是转义序列，只要是双引号括起来的字符集合，就无需用单引号括起来。双引号中的字符集合叫作字符串
何时使用 ASCII码？何时使用转义序列？ 如果要在转义序列（假设使用'\f' ）和ASCII码（'\014' ）之间选择，请选择前者 （即'\f' ） 。这样的写法不仅更好记，而且可移植性更高。'\f' 在不使用ASCII码的系统中，仍然有效。
如果要使用 ASCII码，为何要写成 '\032'而不是 032？ 首先，'\032'能更清晰地表达程序员使用字符编码的意图。其次，类似\032这样的转义序列可以嵌入C的字符串中，如 printf("Hello!\007\n");中就嵌入了\007。
### 打印字符
printf() 函数用%c 指明待打印的字符。前面介绍过，一个字符变量实际上被储存为1字节的整数值。因此，如果用%d 转换说明打印char 类型变量的值，打印的是一个整数。而%c 转换说明告诉 printf() 打印该整数值对应的字符。

### char的符号
有些C编译器把char 实现为有符号类型，这意味着char 可表示的范围是-128～127。而有些C编译器把char 实现为无符号类型，那么char 可表示的范围是0～255。
请查阅相应的编译器手册，确定正在使用的编译器如何实现char 类型。或者，可以查阅limits.h 头文件。
根据C90标准，C语言允许在关键字char 前面使用signed 或 unsigned 。这样，无论编译器默认char 是什么类型，signed char 表示有符号类型，而unsigned char 表示无符号类型。这在用char 类型处理小整数时很有用。如果只用char 处理字符，那么 char 前面无需使用任何修饰符。
## _Bool 类型
99标准添加了_Bool 类型，用于表示布尔值，即逻辑值true 和false 。因为C语言用值1 表示true ，值0 表示false ，所以 _Bool 类型实际上也是一种整数类型。但原则上它仅占用1位存储空间，因为对0 和1 而言，1 位的存储空间足够了。程序通过布尔值可选择执行哪部分代码。
## 可移植类型：stdint.h 和inttypes.h
C99新增了两个头文件stdint.h 和 inttypes.h ，以确保C语言的类型在各系统中的功能相同。C语言为现有类型创建了更多类型名。这些新的类型名定义在 stdint.h 头文件中。不同的系统也可以定义相同的类型名。例如，int 为16位、 long 为32位的系统会把int32_t 作为long 的别名。然后，使用 int32_t 类型编写程序，并包含stdint.h 头文件时，编译器会把 int 或long 替换成与当前系统匹配的类型。
如果系统不支持精确宽度整数类型怎么办？C99和C11提供了第2 类别名集合。一些类型名保证所表示的类型一定是至少有指定宽度的最小整数类型。这组类型集合被称为最小宽度类型 （minimum width type ）。例如，int_least8_t 是可容纳8位有符号整数值的类型中宽度最小的类型的一个别名。如果某系统的最小整数类型是16位，可能不会定义int8_t 类型。尽管如此，该系统仍可使用 int_least8_t 类型，但可能把该类型实现为16位的整数类型。
当然，一些程序员更关心速度而非空间。为此，C99和C11定义了一组可使计算达到最快的类型集合。这组类型集合被称为最快最小宽度类型 （fastst minimum width type ）。例如，int_fast8_t 被定义为系统中对8位有符号值而言运算最快的整数类型的别名。
另外，有些程序员需要系统的最大整数类型。为此，C99定义了最大的有符号整数类型intmax_t ，可储存任何有效的有符号整数值。类似地，uintmax_t 表示最大的无符号整数类型。顺带一提， 这些类型有可能比long long 和unsigned long 类型更大，因为C 编译器除了实现标准规定的类型以外，还可利用C语言实现其他类型。例如，一些编译器在标准引入long long 类型之前，已提前实现了该类型。
C99和C11不仅提供可移植的类型名，还提供相应的输入和输出。例如，printf() 打印特定类型时要求与相应的转换说明匹配。如果要打印int32_t 类型的值，有些定义使用%d ，而有些定义使用%ld ，怎么办？C标准针对这一情况，提供了一些字符串宏（第4章中详细介绍）来显示可移植类型。例如，inttypes.h 头文件中定义了 PRId32 字符串宏，代表打印32 位有符号值的合适转换说明（如d 或 l ）

**实例**
```c
/* altnames.c -- 可移植整数类型名 */
#include <stdio.h>
#include <inttypes.h> // 支持可移植类型
int main(void)
{
int32_t me32; // me32是一个32位有符号整型变量
me32 = 45933945;
printf("First, assume int32_t is int: ");
printf("me32 = %d\n", me32);
printf("Next, let's not make any assumptions.\n");
printf("Instead, use a \"macro\" from inttypes.h: ");
printf("me32 = %" "d" "\n", me32);
return 0;
}
```
该程序最后一个printf() 中，参数PRId32 被定义在 inttypes.h 中的"d" 替换，因而这条语句等价于：
```c
printf("me32 = %d\n", me32);
```
下面是该程序的输出，注意，程序中使用了\" 转义序列来显示双引号：
```
First, assume int32_t is int: me32 = 45933945
Next, let's not make any assumptions.
Instead, use a "macro" from inttypes.h: me32 = 45933945
```

## 浮点类型:float 、double 和long double
表示方式类似于科学计数法如
$$
123000=1.23 ×10^5=1.23e5,0.000056=5.6\times10^{-5}=5.6e-5

$$
C标准规定，float 类型必须至少能表示6位有效数字，且取值范围至少是10-37 ～10+37 
C语言提供的另一种浮点类型是double （意为双精度）。 double 类型和float 类型的最小取值范围相同，但至少必须能表示 10位有效数字。一般情况下，double 占用64位而不是32位。一些系统将多出的32位全部用来表示非指数部分，这不仅增加了有效数字的位数（即提高了精度），而且还减少了舍入误差。另一些系统把其中的一些位分配给指数部分，以容纳更大的指数，从而增加了可表示数的范围。无论哪种方法，double 类型的值至少有13位有效数字，超过了标准的最低位数规定。
### 声明浮点型变量
浮点型变量的声明和初始化方式与整型变量相同，下面是一些例子：
```c
float noah, jonah;
double trouble;
float planck = 6.63e-34;
long double gnp;
```
### 浮点型常量
在代码中，可以用多种形式书写浮点型常量。浮点型常量的基本形式是：有符号的数字（包括小数点），后面紧跟e或E，最后是一个有符号数表示10的指数。下面是两个有效的浮点型常量：
```
-1.56E+12
2.87e-3
```
正号可以省略。可以没有小数点（如，2E5）或指数部分（如， 19.28），但是不能同时省略两者。可以省略小数部分（如，3.E16） 或整数部分（如，.45E-6），但是不能同时省略两者。下面是更多的有效浮点型常量示例：
```
3.14159
.2
4e16
.8E-5
100．
```
不要在浮点型常量中间加空格：1.56 E+12 （错误！）
默认情况下，编译器假定浮点型常量是double 类型的精度。
在浮点数后面加上f 或F 后缀可覆盖默认设置，编译器会将浮点型常量看作float 类型，注意，建议使用L 后缀，因为字母l 和数字1 很容易混淆。
C99标准添加了一种新的浮点型常量格式——用十六进制表示浮点型常量，即在十六进制数前加上十六进制前缀（0x 或0X ），用p 和 P 分别代替e 和E ，用2的幂代替10的幂（即，p 计数法）。如下所示：
```
0xa.1fp10
```
### 打印浮点值
printf() 函数使用%f 转换说明打印十进制记数法的float 和 double 类型浮点数，用%e 打印指数记数法的浮点数。如果系统支持十六进制格式的浮点数，可用a 和A 分别代替e 和E 。打印long double 类型要使用%Lf 、%Le 或%La 转换说明。给那些未在函数原型中显式说明参数类型的函数（如，printf() ）传递参数时，C编译器会把float 类型的值自动转换成double 类型。
### 浮点值的上溢和下溢
当计算导致数字过大，超过当前类型能表达的范围时，就会发生上溢。这种行为在过去是未定义的，不过现在C语言规定，在这种情况下会给变量赋一个表示无穷大的特定值，而且printf() 显示该值为inf 或 infinity 
还有另一个特殊的浮点值NaN （not a number的缩写）。例如， 给asin() 函数传递一个值，该函数将返回一个角度，该角度的正弦就是传入函数的值。但是正弦值不能大于1 ，因此，如果传入的参数大于1 ，该函数的行为是未定义的。在这种情况下，该函数将返回 NaN 值，printf() 函数可将其显示为nan 、NaN 或其他类似的内容。
当对一个很小的数做除法时，情况更为复杂。回忆一下，float 类型的数以指数和尾数部分来储存。存在这样一个数，它的指数部分是最小值，即由全部可用位表示的最小尾数值。该数字是float 类型能用全部精度表示的最小数字。现在把它除以2 。通常，这个操作会减小指数部分，但是假设的情况中，指数已经是最小值了。所以计算机只好把尾数部分的位向右移，空出第1个二进制位，并丢弃最后一个二进制数。以十进制为例，把一个有4位有效数字的数（如， 0.1234E-10 ）除以10 ，得到的结果是0.0123E-10 。虽然得到了结果，但是在计算过程中却损失了原末尾有效位上的数字。这种情况叫作下溢 （underflow ）。C语言把损失了类型全精度的浮点值称为低于正常的 （subnormal ）浮点值。因此，把最小的正浮点数除以2 将得到一个低于正常的值。如果除以一个非常大的值，会导致所有的位都为0 。现在，C库已提供了用于检查计算是否会产生低于正常值的函数。
**浮点数舍入错误**
给定一个数，加上1，再减去原来给定的数，结果是多少？你一定认为是1。但是，下面的浮点运算给出了不同的答案：
```c
/* floaterr.c--演示舍入错误 */
#include <stdio.h>
浮点数表示法
int main(void)
{
float a,b;
b = 2.0e20 + 1.0;
a = b - 2.0e20;
printf("%f \n", a);
return 0;
}
```

该程序的输出如下：
```
0.000000 ←Linux系统下的老式gcc
-13584010575872.000000 ←Turbo C 1.5
4008175468544.000000 ←XCode 4.5、Visual Studio 2012、当前版本的gcc
```
得出这些奇怪答案的原因是，计算机缺少足够的小数位来完成正确的运算。2.0e20 是 2后面有20个0。如果把该数加1，那么发生变化的是第21位。要正确运算，程序至少要储存 21位数字。而float 类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字。在这种情况下，计算结果一定是错误的。另一方面，如果把2.0e20 改成2.0e4 ，计算结果就没问题。因为2.0e4 加1只需改变第5位上的数字，float 类型的精度足够进行这样的计算。
## 复数和虚数类型

C语言有3种复数类型：float _Complex 、double _Complex 和long double _Complex .例如，float _Complex 类型的变量应包含两个float 类型的值，分别表示复数的实部和虚部。类似地，C语言的3种虚数类型是float _Imaginary 、double _Imaginary 和long double _Imaginary 。
如果包含complex.h 头文件，便可用complex 代替_Complex ，用imaginary 代替_Imaginary ，还可以用I 代替-1 的平方根。
为何C标准不直接用complex 作为关键字来代替_Complex ，而要添加一个头文件（该头文件中把complex 定义为_Complex ）？ 因为标准委员会考虑到，如果使用新的关键字，会导致以该关键字作为标识符的现有代码全部失效。例如，之前的C99，许多程序员已经使用struct complex 定义一个结构来表示复数或者心理学程序中的心理状况（关键字struct 用于定义能储存多个值的结构，详见第 14章）。让complex 成为关键字会导致之前的这些代码出现语法错误。但是，使用struct _Complex 的人很少，特别是标准使用首字母是下划线的标识符作为预留字以后。因此，标准委员会选定 _Complex 作为关键字，在不用考虑名称冲突的情况下可选择使用 complex 。
## 类型的占用空间
sizeof 是C语言的内置运算符，以字节为单位给出指定类型的大小，C99和C11提供%zd 转换说明匹配sizeof 的返回类型注意，因为C语言定义了char 类型是1字节，所
以char 类型的大小一定是1字节。而在char 类型为16位、double
类型为64位的系统中，sizeof 给出的double 是4字节。
## 使用数据类型规范
C编译器把浮点数转换成整数时， 会直接丢弃（截断）小数部分，而不进行四舍五入
许多程序员和公司内部都有系统化的命名约定，在变量名中体现其类型。例如，用i_ 前缀表示int 类型，us_ 前缀表示unsigned short 类型。这样，一眼就能看出来i_smart 是int 类型的变量， us_versmart 是unsigned short 类型的变量。
## 刷新输出
printf() 语句把输出发送到一个叫作缓冲区 （buffer ）的中间存储区域，然后缓冲区中的内容再不断被发送到屏幕上,从而达成打印的目的。
C标准明确规定了何时把缓冲区中的内容发送到屏幕：当缓冲区满、遇到换行字符或需要输入的时候 （从缓冲区把数据发送到屏幕或文件被称为刷新缓冲区 ）。%% 程序结束会自动刷新缓冲区 %%
旧式编译器遇到scanf() 也不会强行刷新缓冲区，程序会停在那里不显示任何提示内容，等待用户输入数据。在这种情况下，可以使用换行字符刷新缓冲区。代码应改为：
```c
printf("Enter your desired monthly salary:\n");
scanf("%f", &salary);
```
无论接下来的输入是否能刷新缓冲区，代码都会正常运行。这将导致光标移至下一行起始处，用户无法在提示内容同一行输入数据。还有一种刷新缓冲区的方法是使用fflush() 函数
## 小结
C有多种的数据类型。基本数据类型分为两大类：整数类型和浮点数类型。
通过为类型分配的储存量以及是有符号还是无符号，区分不同的整数类型。
最小的整数类型是char ，因实现不同，可以是有符号的char 或无符号的char ，即unsigned char 或signed char 。但是，通常用char 类型表示小整数时才这样显示说明。
其他整数类型有short 、int 、long 和long long 类型。C规定，后面的类型不能小于前面的类型。上述都是有符号类型，但也可以使用 unsigned 关键字创建相应的无符号类型：unsigned short 、 unsigned int 、unsigned long 和unsigned long long 。或者，在类型名前加上signed 修饰符显式表明该类型是有符号类型。
_Bool 类型是一种无符号类型，可储存0 或1 ，分别代表 false 和true 。
浮点类型有3种：float 、double 和C90新增的long double 。后面的类型应大于或等于前面的类型。
有些实现可选择支持复数类型和虚数类型，通过关键字_Complex 和_Imaginary 与浮点类型的关键字组合（如，double _Complex 类型和float _Imaginary 类型）来表示这些类型。
整数可以表示为十进制、八进制或十六进制。0前缀表示八进制数，0x或0X前缀表示十六进制数。例如，32、040、0x20分别以十进制、八进制、十六进制表示同一个值。l 或L 后缀表明该值是long 类型，ll 或LL 后缀表明该值是long long 类型。
在C语言中，直接表示一个字符常量的方法是：把该字符用单引号括起来，如'Q' 、'8' 和'$' 。
C语言的转义序列（如，'\n' ） 表示某些非打印字符。另外，还可以在八进制或十六进制数前加上一个反斜杠（如，'\007' ），表示ASCII码中的一个字符。
浮点数可写成固定小数点的形式（如，9393.912 ）或指数形式 （如，7.38E10 ）。
C99和C11提供了第3种指数表示法，即用十六进制数和2的幂来表示（如，0xa.1fp10 ）。
printf() 函数根据转换说明打印各种类型的值。转换说明最简单的形式由一个百分号（% ）和一个转换字符组成，如%d 或%f 。









