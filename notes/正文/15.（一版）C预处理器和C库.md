C语言建立在适当的关键字、表达式、语句以及使用它们的规则上。然而，C标准不仅描述C语言，还描述如何执行C预处理器、C标准库有哪些函数，以及详述这些函数的工作原理。本章将介绍C预处理器和C库，我们先从C预处理器开始。

C预处理器在程序执行之前查看程序（故称之为预处理器 ）。根据程序中的预处理器指令，预处理器把符号缩写替换成其表示的内容。预处理器可以包含程序所需的其他文件，可以选择让编译器查看哪些代码。预处理器并不知道C。基本上它的工作是把一些文本转换成另外一些文本。这样描述预处理器无法体现它的真正效用和价值，我们将在本章举例说明。前面的程序示例中也有很多 `#define` 和 `#include` 的例子。下面，我们先总结一下已学过的预处理指令，再介绍一些新的知识点。

### 16.1　翻译程序的第一步

在预处理之前，编译器必须对该程序进行一些翻译处理。首先，编译器把源代码中出现的字符映射到源字符集。该过程处理多字节字符和三字符序列 ——字符扩展让C更加国际化（详见附录B“参考资料VII，扩展字符支持”）。

第二，编译器定位每个反斜杠后面跟着换行符的实例，并删除它们。也就是说，把下面两个物理行（physical line ）：

这是一个使用反斜杠将一个物理行延续到下一行的C语言代码示例。

C

```
printf("That's wond\
erful!\n");
```

转换成一个逻辑行 （logical line ）：

`printf("That's wonderful\n!");`

注意，在这种场合中，“换行符”的意思是通过按下Enter 键在源代码文件中换行所生成的字符，而不是指符号表征 `\n` 。

由于预处理表达式的长度必须是一个逻辑行，所以这一步为预处理器做好了准备工作。一个逻辑行可以是多个物理行。

第三，编译器把文本划分成预处理记号序列、空白序列和注释序列（记号是由空格、制表符或换行符分隔的项，详见16.2.1）。这里要注意的是，编译器将用一个空格字符替换每一条注释。因此，下面的代码：

`int/* 这看起来并不像一个空格*/fox;`

将变成：

`int fox;`

而且，实现可以用一个空格替换所有的空白字符序列（不包括换行符）。最后，程序已经准备好进入预处理阶段，预处理器查找一行中以 `#` 号开始的预处理指令。

### 16.2　明示常量：#define

`#define` 预处理器指令和其他预处理器指令一样，以 `#` 号作为一行的开始。ANSI和后来的标准都允许 `#` 号前面有空格或制表符，而且还允许在 `#` 和指令的其余部分之间有空格。但是旧版本的C要求指令从一行最左边开始，而且 `#` 和指令其余部分之间不能有空格。指令可以出现在源文件的任何地方，其定义从指令出现的地方到该文件末尾有效。我们大量使用 `#define` 指令来定义明示常量 （manifest constant ）（也叫做符号常量），但是该指令还有许多其他用途。程序清单16.1演示了 `#define` 指令的一些用法和属性。

预处理器指令从 `#` 开始运行，到后面的第1个换行符为止。也就是说，指令的长度仅限于一行。然而，前面提到过，在预处理开始前，编译器会把多行物理行处理为一行逻辑行。

这是一个简单的C语言程序（`preproc.c`），它演示了预处理器的基本用法，包括定义数值常量、使用反斜杠延续长字符串定义，以及定义包含其他宏和完整语句的宏。

C

```
/* preproc.c -- 简单的预处理示例 */
#include <stdio.h>
#define TWO 2 /* 可以使用注释 */
#define OW "Consistency is the last refuge of the unimagina\
tive. - Oscar Wilde" /* 反斜杠把该定义延续到下一行 */
#define FOUR TWO*TWO
#define PX printf("X is %d.\n", x)
#define FMT "X is %d.\n"
int main(void)
{
int x = TWO;
PX;
x = FOUR;
printf(FMT, x);
printf("%s\n", OW);
printf("TWO: OW\n");
return 0;
}
```

每行 `#define` （逻辑行）都由3部分组成。第1部分是 `#define` 指令本身。第2部分是选定的缩写，也称为宏 。有些宏代表值（如本例），这些宏被称为类对象宏 （object-like macro ）。C语言还有类函数宏 （function-like macro ），稍后讨论。宏的名称中不允许有空格，而且必须遵循C变量的命名规则：只能使用字符、数字和下划线（`_` ）字符，而且首字符不能是数字。第3部分（指令行的其余部分）称为替换列表 或替换体 （见图16.1）。一旦预处理器在程序中找到宏的示实例后，就会用替换体代替该宏（也有例外，稍后解释）。从宏变成最终替换文本的过程称为宏展开 （macro expansion ）。注意，可以在 `#define` 行使用标准C注释。如前所述，每条注释都会被一个空格代替。

**图16.1　类对象宏定义的组成**

运行该程序示例后，输出如下:

这是`preproc.c`程序的运行输出结果。

text

```
X is 2.
X is 4.
Consistency is the last refuge of the unimaginative. - Oscar Wilde
TWO: OW
```

下面分析具体的过程。下面的语句：

`int x = TWO;`

变成了：

`int x = 2;`

2 代替了 `TWO` 。而语句：

`PX;`

变成了：

`printf("X is %d.\n", x);`

这里同样进行了替换。这是一个新用法，到目前为止我们只是用宏来表示明示常量。从该例中可以看出，宏可以表示任何字符串，甚至可以表示整个C表达式。但是要注意，虽然 `PX` 是一个字符串常量，它只打印一个名为 `x` 的变量。

下一行也是一个新用法。读者可能认为 `FOUR` 被替换成4 ，但是实际的过程是：

`x = FOUR;`

变成了：

`x = TWO*TWO;`

即是：

`x = 2*2;`

宏展开到此处为止。由于编译器在编译期对所有的常量表达式（只包含常量的表达式）求值，所以预处理器不会进行实际的乘法运算，这一过程在编译时进行。预处理器不做计算，不对表达式求值，它只进行替换。

注意，宏定义还可以包含其他宏（一些编译器不支持这种嵌套功能）。

程序中的下一行：

`printf (FMT, x);`

变成了：

`printf("X is %d.\n",x);`

相应的字符串替换了 `FMT` 。如果要多次使用某个冗长的字符串，这种方法比较方便。另外，也可以用下面的方法：

`const char * fmt = "X is %d.\n";`

然后可以把 `fmt` 作为 `printf()` 的格式字符串。

下一行中，用相应的字符串替换 `OW` 。双引号使替换的字符串成为字符串常量。编译器把该字符串储存在以空字符结尾的数组中。因此，下面的指令定义了一个字符常量：

`#define HAL 'Z'`

而下面的指令则定义了一个字符串（Z\0 ）：

`#define HAP "Z"`

在程序示例16.1中，我们在一行的结尾加一个反斜杠字符使该行扩展至下一行：

这是一个使用反斜杠将宏定义延续到下一行的示例。

C

```
#define OW "Consistency is the last refuge of the unimagina\
tive. - Oscar Wilde"
```

注意，第2行要与第1行左对齐。如果这样做：

这个`#define`示例展示了如果延续行存在前导空格，这些空格也会成为替换文本的一部分。

C

```
#define OW "Consistency is the last refuge of the unimagina\
tive. - Oscar Wilde"
```

那么输出的内容是：

`Consistency is the last refuge of the unimagina tive. - Oscar Wilde`

第2行开始到 `tive` 之间的空格也算是字符串的一部分。

一般而言，预处理器发现程序中的宏后，会用宏等价的替换文本进行替换。如果替换的字符串中还包含宏，则继续替换这些宏。唯一例外的是双引号中的宏。因此，下面的语句：

`printf("TWO: OW");`

打印的是 `TWO: OW` ，而不是打印：

`2: Consistency is the last refuge of the unimaginative. - Oscar Wilde`

要打印这行，应该这样写：

`printf("%d: %s\n", TWO, OW);`

这行代码中，宏不在双引号内。

那么，何时使用字符常量？对于绝大部分数字常量，应该使用字符常量。如果在算式中用字符常量代替数字，常量名能更清楚地表达该数字的含义。如果是表示数组大小的数字，用符号常量后更容易改变数组的大小和循环次数。如果数字是系统代码（如，`EOF` ），用符号常量表示的代码更容易移植（只需改变 `EOF` 的定义）。助记、易更改、可移植，这些都是符号常量很有价值的特性。

C语言现在也支持 `const` 关键字，提供了更灵活的方法。用 `const` 可以创建在程序运行过程中不能改变的变量，可具有文件作用域或块作用域。另一方面，宏常量可用于指定标准数组的大小和 `const` 变量的初始值。

这段C代码片段展示了使用`#define`定义的宏常量和`const`限定的变量在声明静态数组时的一些区别，特别是在C标准中对常量表达式的要求。

C

```
#define LIMIT 20
const int LIM = 50;
static int data1[LIMIT]; // 有效
static int data2[LIM]; // 无效
const int LIM2 = 2 * LIMIT; // 有效
const int LIM3 = 2 * LIM; // 无效
```

这里解释一下上面代码中的“无效”注释。在C中，非自动数组的大小应该是整型常量表达式，这意味着表示数组大小的必须是整型常量的组合（如5 ）、枚举常量和 `sizeof` 表达式，不包括 `const` 声明的值（这也是C++和C的区别之一，在C++中可以把 `const` 值作为常量表达式的一部分）。但是，有的实现可能接受其他形式的常量表达式。例如，GCC 4.7.3不允许 `data2` 的声明，但是Clang 4.6允许。

#### 16.2.1　记号

从技术角度来看，可以把宏的替换体看作是记号 （token ）型字符串，而不是字符型字符串。C预处理器记号是宏定义的替换体中单独的“词”。用空白把这些词分开。例如：

`#define FOUR 2*2`

该宏定义有一个记号：`2*2` 序列。但是，下面的宏定义中：

`#define SIX 2 * 3`

有3个记号：`2` 、`*`、`3` 。

替换体中有多个空格时，字符型字符串和记号型字符串的处理方式不同。考虑下面的定义：

`#define EIGHT 4 * 8`

如果预处理器把该替换体解释为字符型字符串，将用 `4 * 8` 替换 `EIGHT` 。即，额外的空格是替换体的一部分。如果预处理器把该替换体解释为记号型字符串，则用3个的记号 `4 * 8` （分别由单个空格分隔）来替换 `EIGHT` 。换而言之，解释为字符型字符串，把空格视为替换体的一部分；解释为记号型字符串，把空格视为替换体中各记号的分隔符。在实际应用中，一些C编译器把宏替换体视为字符串而不是记号。在比这个例子更复杂的情况下，两者的区别才有实际意义。

顺带一提，C编译器处理记号的方式比预处理器复杂。由于编译器理解C语言的规则，所以不要求代码中用空格来分隔记号。例如，C编译器可以把 `2*2` 直接视为3 个记号，因为它可以识别 `2` 是常量，`*`是运算符。

#### 16.2.2　重定义常量

假设先把 `LIMIT` 定义为20 ，稍后在该文件中又把它定义为25 。这个过程称为重定义常量 。不同的实现采用不同的重定义方案。除非新定义与旧定义相同，否则有些实现会将其视为错误。另外一些实现允许重定义，但会给出警告。ANSI标准采用第1种方案，只有新定义和旧定义完全相同才允许重定义。

具有相同的定义意味着替换体中的记号必须相同，且顺序也相同。因此，下面两个定义相同：

`#define SIX 2 * 3`  
`#define SIX 2 * 3`

这两条定义都有3个相同的记号，额外的空格不算替换体的一部分。而下面的定义则与上面两条宏定义不同：

`#define SIX 2*3`

这条宏定义中只有一个记号，因此与前两条定义不同。如果需要重定义宏，使用 `#undef` 指令（稍后讨论）。

如果确实需要重定义常量，使用 `const` 关键字和作用域规则更容易些。

### 16.3　在#define 中使用参数

在 `#define` 中使用参数可以创建外形和作用与函数类似的类函数宏 。带有参数的宏看上去很像函数，因为这样的宏也使用圆括号。类函数宏定义的圆括号中可以有一个或多个参数，随后这些参数出现在替换体中，如图16.2所示。

**图16.2　函数宏定义的组成**

下面是一个类函数宏的示例：

`#define SQUARE(X) X*X`

在程序中可以这样用：

`z = SQUARE(2);`

这看上去像函数调用，但是它的行为和函数调用完全不同。程序清单16.2演示了类函数宏和另一个宏的用法。该示例中有一些陷阱，请读者仔细阅读。

这是一个C语言程序（`mac_arg.c`），它演示了如何定义和使用带参数的宏（类函数宏），并揭示了在使用时可能遇到的一些常见陷阱，例如由于运算符优先级和副作用（如自增运算符）导致的问题。

C

```
/* mac_arg.c -- 带参数的宏 */
#include <stdio.h>
#define SQUARE(X) X*X
#define PR(X) printf("The result is %d.\n", X)
int main(void)
{
int x = 5;
int z;
printf("x = %d\n", x);
z = SQUARE(x);
printf("Evaluating SQUARE(x): ");
PR(z);
z = SQUARE(2);
printf("Evaluating SQUARE(2): ");
PR(z);
printf("Evaluating SQUARE(x+2): ");
PR(SQUARE(x + 2));
printf("Evaluating 100/SQUARE(2): ");
PR(100 / SQUARE(2));
printf("x is %d.\n", x);
printf("Evaluating SQUARE(++x): ");
PR(SQUARE(++x));
printf("After incrementing, x is %x.\n", x);
return 0;
}
```

`SQUARE` 宏的定义如下：

`#define SQUARE(X) X*X`

这里，`SQUARE` 是宏标识符，`SQUARE(X)` 中的 `X` 是宏参数，`X*X` 是替换列表。程序清单16.2中出现 `SQUARE(X)` 的地方都会被 `X*X` 替换。这与前面的示例不同，使用该宏时，既可以用 `X` ，也可以用其他符号。宏定义中的 `X` 由宏调用中的符号代替。因此，`SQUARE(2)` 替换为 `2*2` ，`X` 实际上起到参数的作用。

然而，稍后你将看到，宏参数与函数参数不完全相同。下面是程序的输出。注意有些内容可能与我们的预期不符。实际上，你的编译器输出甚至与下面的结果完全不同。

这是`mac_arg.c`程序的运行输出结果，其中一些结果可能与直观预期不符，暴露了宏替换的陷阱。

text

```
x = 5
Evaluating SQUARE(x): The result is 25.
Evaluating SQUARE(2): The result is 4.
Evaluating SQUARE(x+2): The result is 17.
Evaluating 100/SQUARE(2): The result is 100.
x is 5.
Evaluating SQUARE(++x): The result is 42.
After incrementing, x is 7.
```

前两行与预期相符，但是接下来的结果有点奇怪。程序中设置 `x` 的值为5 ，你可能认为 `SQUARE(x+2)` 应该是 `7*7` ，即49 。但是，输出的结果是17 ，这不是一个平方值！导致这样结果的原因是，我们前面提到过，预处理器不做计算、不求值，只替换字符序列。预处理器把出现 `x` 的地方都替换成 `x+2` 。因此，`x*x` 变成了 `x+2*x+2` 。如果 `x` 为5 ，那么该表达式的值为：

`5+2*5+2 = 5 + 10 + 2 = 17`

该例演示了函数调用和宏调用的重要区别。函数调用在程序运行时把参数的值传递给函数。宏调用在编译之前把参数记号传递给程序。这两个不同的过程发生在不同时期。是否可以修改宏定义让 `SQUARE(x+2)` 得49 ？当然可以，要多加几个圆括号：

`#define SQUARE(x) (x)*(x)`

现在 `SQUARE(x+2)` 变成了 `(x+2)*(x+2)` ，在替换字符串中使 用圆括号就得到符合预期的乘法运算。

但是，这并未解决所有的问题。下面的输出行：

`100/SQUARE(2)`

将变成：

`100/2*2`

根据优先级规则，从左往右对表达式求值：`(100/2)*2` ，即 `50*2` ，得100 。把 `SQUARE(x)` 定义为下面的形式可以解决这种混乱：

`#define SQUARE(x) (x*x)`

这样修改定义后得 `100/(2*2)` ，即 `100/4` ，得25 。

要处理前面的两种情况，要这样定义：

`#define SQUARE(x) ((x)*(x))`

因此，必要时要使用足够多的圆括号来确保运算和结合的正确顺序。

尽管如此，这样做还是无法避免程序中最后一种情况的问题。`SQUARE(++x)` 变成了 `++x*++x` ，递增了两次 `x` ，一次在乘法运算之前，一次在乘法运算之后：

`++x*++x = 6*7 = 42`

由于标准并未对这类运算规定顺序，所以有些编译器得 `7*6` 。而有些编译器可能在乘法运算之前已经递增了 `x` ，所以 `7*7` 得49 。在C标准中，对该表达式求值的这种情况称为未定义行为。无论哪种情况，`x` 的开始值都是5 ，虽然从代码上看只递增了一次，但是 `x` 的最终值是7 。

解决这个问题最简单的方法是，避免用 `++x` 作为宏参数。一般而言，不要在宏中使用递增或递减运算符。但是，`++x` 可作为函数参数，因为编译器会对 `++x` 求值得6后，再把6传递给函数。

#### 16.3.1　用宏参数创建字符串：#运算符

下面是一个类函数宏：

`#define PSQR(X) printf("The square of X is %d.\n", ((X)*(X)));`

假设这样使用宏：

`PSQR(8);`

输出为：

这是上述宏调用产生的输出。

text

```
The square of X is 64.
```

注意双引号字符串中的X 被视为普通文本，而不是一个可被替换的记号。

C允许在字符串中包含宏参数。在类函数宏的替换体中，`#` 号作为一个预处理运算符，可以把记号转换成字符串。例如，如果 `x` 是一个宏形参，那么 `#x` 就是转换为字符串 `"x"` 的形参名。这个过程称为字符串化 （stringizing ）。程序清单16.3演示了该过程的用法。

这是一个C语言程序（`subst.c`），它演示了预处理器中的字符串化运算符（`#`）如何将宏的参数转换为字符串字面量。

C

```
/* subst.c -- 在字符串中替换 */
#include <stdio.h>
#define PSQR(x) printf("The square of " #x " is %d.\n",((x)*(x)))
int main(void)
{
int y = 5;
PSQR(y);
PSQR(2 + 4);
return 0;
}
```

该程序的输出如下：

这是`subst.c`程序的运行输出结果。

text

```
The square of y is 25.
The square of 2 + 4 is 36.
```

调用第1个宏时，用 `"y"` 替换 `#x` 。调用第2个宏时，用 `"2 + 4"` 替换 `#x` 。ANSI C字符串的串联特性将这些字符串与 `printf()` 语句的其他字符串组合，生成最终的字符串。例如，第1次调用变成：

`printf("The square of " "y" " is %d.\n",((y)*(y)));`

然后，字符串串联功能将这3个相邻的字符串组合成一个字符串：

`"The square of y is %d.\n"`

#### 16.3.2　预处理器黏合剂：##运算符

与 `#` 运算符类似，`##` 运算符可用于类函数宏的替换部分。而且，`##` 还可用于对象宏的替换部分。`##` 运算符把两个记号组合成一个记号。例如，可以这样做：

`#define XNAME(n) x ## n`

然后，宏 `XNAME(4)` 将展开为 `x4` 。程序清单16.4演示了 `##` 作为记号粘合剂的用法。

这是一个C语言程序（`glue.c`），它演示了预处理器中的记号粘贴运算符（`##`）如何将两个记号合并成一个记号，常用于动态生成变量名或函数名。

C

```
// glue.c -- 使用##运算符
#include <stdio.h>
#define XNAME(n) x ## n
#define PRINT_XN(n) printf("x" #n " = %d\n", x ## n);
int main(void)
{
int XNAME(1) = 14; // 变成 int x1 = 14;
int XNAME(2) = 20; // 变成 int x2 = 20;
int x3 = 30;
PRINT_XN(1); // 变成 printf("x1 = %d\n", x1);
PRINT_XN(2); // 变成 printf("x2 = %d\n", x2);
PRINT_XN(3); // 变成 printf("x3 = %d\n", x3);
return 0;
}
```

该程序的输出如下：

这是`glue.c`程序的运行输出结果。

text

```
x1 = 14
x2 = 20
x3 = 30
```

注意，`PRINT_XN()` 宏用 `#` 运算符组合字符串，`##` 运算符把记号组合为一个新的标识符。

#### 16.3.3　变参宏：... 和 _ _VA_ARGS_ _

一些函数（如 `printf()` ）接受数量可变的参数。`stdvar.h` 头文件（本章后面介绍）提供了工具，让用户自定义带可变参数的函数。C99/C11也对宏提供了这样的工具。虽然标准中未使用“可变 ”（variadic ）这个词，但是它已成为描述这种工具的通用词（虽然，C标准的索引添加了字符串化(stringizing )词条，但是，标准并未把固定参数的函数或宏称为固定函数和不变宏）。

通过把宏参数列表中最后的参数写成省略号（即，3个点`...` ）来实现这一功能。这样，预定义宏 `_ _VA_ARGS_ _` 可用在替换部分中，表明省略号代表什么。例如，下面的定义：

`#define PR(...) printf(_ _VA_ARGS_ _)`

假设稍后调用该宏：

`PR("Howdy");`  
`PR("weight = %d, shipping = $%.2f\n", wt, sp);`

对于第1次调用，`_ _VA_ARGS_ _` 展开为1个参数：`"Howdy"` 。  
对于第2次调用，`_ _VA_ARGS_ _` 展开为3个参数：`"weight = %d, shipping = $%.2f\n"` 、`wt` 、`sp` 。  
因此，展开后的代码是：

`printf("Howdy");`  
`printf("weight = %d, shipping = $%.2f\n", wt, sp);`

程序清单16.5演示了一个示例，该程序使用了字符串的串联功能和 `#` 运算符。

这是一个C语言程序（`variadic.c`），它演示了如何定义和使用变参宏，这种宏可以接受可变数量的参数。

C

```
// variadic.c -- 变参宏
#include <stdio.h>
#include <math.h>
#define PR(X, ...) printf("Message " #X ": " _ _VA_ARGS_ _)
int main(void)
{
double x = 48;
double y;
y = sqrt(x);
PR(1, "x = %g\n", x);
PR(2, "x = %.2f, y = %.4f\n", x, y);
return 0;
}
```

第1个宏调用，`X` 的值是1 ，所以 `#X` 变成 `"1"` 。展开后成为：

`printf("Message " "1" ": " "x = %g\n", x);`

然后，串联4个字符，把调用简化为：

`printf("Message 1: x = %g\n", x);`

下面是该程序的输出：

这是`variadic.c`程序的运行输出结果。

text

```
Message 1: x = 48
Message 2: x = 48.00, y = 6.9282
```

记住，省略号只能代替最后的宏参数：

`#define WRONG(X, ..., Y) #X #_ _VA_ARGS_ _ #y //不能这样做`

### 16.4　宏和函数的选择

有些编程任务既可以用带参数的宏完成，也可以用函数完成。应该使用宏还是函数？这没有硬性规定，但是可以参考下面的情况。

使用宏比使用普通函数复杂一些，稍有不慎会产生奇怪的副作用。一些编译器规定宏只能定义成一行。不过，即使编译器没有这个限制，也应该这样做。

宏和函数的选择实际上是时间和空间的权衡。宏生成内联代码，即在程序中生成语句。如果调用20次宏，即在程序中插入20行代码。如果调用函数20次，程序中只有一份函数语句的副本，所以节省了空间。然而另一方面，程序的控制必须跳转至函数内，随后再返回主调程序，这显然比内联代码花费更多的时间。

宏的一个优点是，不用担心变量类型（这是因为宏处理的是字符串，而不是实际的值）。因此，只要能用 `int` 或 `float` 类型都可以使用 `SQUARE(x)` 宏。

C99提供了第3种可替换的方法——内联函数。本章后面将介绍。

对于简单的函数，程序员通常使用宏，如下所示：

这里展示了三个常用的类函数宏，分别用于计算最大值、绝对值以及判断一个字符是否为正负号。

C

```
#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))
#define ABS(X) ((X) < 0 ? -(X) : (X))
#define ISSIGN(X) ((X) == '+' || (X) == '-' ? 1 : 0)
```

（如果 `x` 是一个代数符号字符，最后一个宏的值为1 ，即为真。）

要注意以下几点。

- 记住宏名中不允许有空格，但是在替换字符串中可以有空格。ANSI C允许在参数列表中使用空格。
- 用圆括号把宏的参数和整个替换体括起来。这样能确保被括起来的部分在下面这样的表达式中正确地展开：  
    `forks = 2 * MAX(guests + 3, last);`
- 用大写字母表示宏函数的名称。该惯例不如用大写字母表示宏常量应用广泛。但是，大写字母可以提醒程序员注意，宏可能产生的副作用。
- 如果打算使用宏来加快程序的运行速度，那么首先要确定使用宏和使用函数是否会导致较大差异。在程序中只使用一次的宏无法明显减少程序的运行时间。在嵌套循环中使用宏更有助于提高效率。许多系统提供程序分析器以帮助程序员压缩程序中最耗时的部分。

假设你开发了一些方便的宏函数，是否每写一个新程序都要重写这些宏？如果使用 `#include` 指令，就不用这样做了。
### 16.5　文件包含：#include

当预处理器发现 `#include` 指令时，会查看后面的文件名并把文件的内容包含到当前文件中，即替换源文件中的 `#include` 指令。这相当于把被包含文件的全部内容输入到源文件 `#include` 指令所在的位置。`#include` 指令有两种形式：

`#include <stdio.h>` ←文件名在尖括号中  
`#include "mystuff.h"` ←文件名在双引号中

在UNIX系统中，尖括号告诉预处理器在标准系统目录中查找该文件。双引号告诉预处理器首先在当前目录中（或文件名中指定的其他目录）查找该文件，如果未找到再查找标准系统目录：

`#include <stdio.h>` ←查找系统目录  
`#include "hot.h"` ←查找当前工作目录  
`#include "/usr/biff/p.h"` ←查找/usr/biff目录

集成开发环境（IDE）也有标准路径或系统头文件的路径。许多集成开发环境提供菜单选项，指定用尖括号时的查找路径。在UNIX中，使用双引号意味着先查找本地目录，但是具体查找哪个目录取决于编译器的设定。有些编译器会搜索源代码文件所在的目录，有些编译器则搜索当前的工作目录，还有些搜索项目文件所在的目录。

ANSI C不为文件提供统一的目录模型，因为不同的计算机所用的系统不同。一般而言，命名文件的方法因系统而异，但是尖括号和双引号的规则与系统无关。

为什么要包含文件？因为编译器需要这些文件中的信息。例如，`stdio.h` 文件中通常包含 `EOF` 、`NULL` 、`getchar()` 和 `putchar()` 的定义。`getchar()` 和 `putchar()` 被定义为宏函数。此外，该文件中还包含C的其他I/O函数。

C语言习惯用 `.h` 后缀表示头文件 ，这些文件包含需要放在程序顶部的信息。头文件经常包含一些预处理器指令。有些头文件（如 `stdio.h` ）由系统提供，当然你也可以创建自己的头文件。

包含一个大型头文件不一定显著增加程序的大小。在大部分情况下，头文件的内容是编译器生成最终代码时所需的信息，而不是添加到最终代码中的材料。

#### 16.5.1　头文件示例

假设你开发了一个存放人名的结构，还编写了一些使用该结构的函数。可以把不同的声明放在头文件中。程序清单16.6演示了一个这样的例子。

这是一个C语言头文件（`names_st.h`），它定义了一个用于存储姓名的结构体`names_st`、一个常量、一个类型别名以及操作该结构体的函数原型。

C

```
// names_st.h -- names_st 结构的头文件
// 常量
#include <string.h>
#define SLEN 32
// 结构声明
struct names_st
{
char first[SLEN];
char last[SLEN];
};
// 类型定义
typedef struct names_st names;
// 函数原型
void get_names(names *);
void show_names(const names *);
char * s_gets(char * st, int n);
```

该头文件包含了一些头文件中常见的内容：`#define` 指令、结构声明、`typedef` 和函数原型。注意，这些内容是编译器在创建可执行代码时所需的信息，而不是可执行代码。为简单起见，这个特殊的头文件过于简单。通常，应该用 `#ifndef` 和 `#define` 防止多重包含头文件。我们稍后介绍这些内容。

可执行代码通常在源代码文件中，而不是在头文件中。例如，程序清单16.7中有头文件中函数原型的定义。该程序包含了 `names_st.h` 头文件，所以编译器知道 `names` 类型。

这是源文件`name_st.c`，它实现了在`names_st.h`头文件中声明的函数，包括获取姓名、显示姓名和一个安全的字符串输入函数。

C

```
// names_st.c -- 定义 names_st.h中的函数
#include <stdio.h>
#include "names_st.h" // 包含头文件
// 函数定义
void get_names(names * pn)
{
printf("Please enter your first name: ");
s_gets(pn->first, SLEN);
printf("Please enter your last name: ");
s_gets(pn->last, SLEN);
}
void show_names(const names * pn)
{
printf("%s %s", pn->first, pn->last);
}
char * s_gets(char * st, int n)
{
char * ret_val;
char * find;
ret_val = fgets(st, n, stdin);
if (ret_val)
{
find = strchr(st, '\n'); // 查找换行符
if (find) // 如果地址不是NULL，
*find = '\0'; // 在此处放置一个空字符
else
while (getchar() != '\n')
continue; // 处理输入行中的剩余字符
}
return ret_val;
}
```

`get_names()` 函数通过 `s_gets()` 函数调用了 `fgets()` 函数，避免了目标数组溢出。程序清单16.8使用了程序清单16.6的头文件和程序清单16.7的源文件。

这是一个主程序文件（`useheader.c`），它演示了如何使用`names_st.h`头文件和`names_st.c`源文件中定义的结构与函数。

C

```
// useheader.c -- 使用 names_st 结构
#include <stdio.h>
#include "names_st.h"
// 记住要链接 names_st.c
int main(void)
{
names candidate;
get_names(&candidate);
printf("Let's welcome ");
show_names(&candidate);
printf(" to this program!\n");
return 0;
}
```

下面是该程序的输出：

这是`useheader.c`程序的运行输出结果。

text

```
Please enter your first name: Ian
Please enter your last name: Smersh
Let's welcome Ian Smersh to this program!
```

该程序要注意下面几点。

- 两个源代码文件都使用 `names_st` 类型结构，所以它们都必须包含 `names_st.h` 头文件。
- 必须编译和链接 `names_st.c` 和 `useheader.c` 源代码文件。
- 声明和指令放在 `nems_st.h` 头文件中，函数定义放在 `names_st.c` 源代码文件中。

#### 16.5.2　使用头文件

浏览任何一个标准头文件都可以了解头文件的基本信息。头文件中最常用的形式如下。

- **明示常量** ——例如，`stdio.h` 中定义的 `EOF` 、`NULL` 和 `BUFSIZE` （标准I/O缓冲区大小）。
- **宏函数** ——例如，`getchar()` 通常用 `getc(stdin)` 定义，而 `getc()` 经常用于定义较复杂的宏，头文件 `ctype.h` 通常包含 `ctype` 系列函数的宏定义。
- **函数声明** ——例如，`string.h` 头文件（一些旧的系统中是 `strings.h` ）包含字符串函数系列的函数声明。在ANSI C和后面的标准中，函数声明都是函数原型形式。
- **结构模版定义** ——标准I/O函数使用 `FILE` 结构，该结构中包含了文件和与文件缓冲区相关的信息。`FILE` 结构在头文件 `stdio.h` 中。
- **类型定义** ——标准I/O函数使用指向 `FILE` 的指针作为参数。通常，`stdio.h` 用 `#define` 或 `typedef` 把 `FILE` 定义为指向结构的指针。类似地，`size_t` 和 `time_t` 类型也定义在头文件中。

许多程序员都在程序中使用自己开发的标准头文件。如果开发一系列相关的函数或结构，那么这种方法特别有价值。

另外，还可以使用头文件声明外部变量供其他文件共享。例如，如果已经开发了共享某个变量的一系列函数，该变量报告某种状况（如，错误情况），这种方法就很有效。这种情况下，可以在包含这些函数声明的源代码文件定义一个文件作用域的外部链接变量：

`int status = 0; // 该变量具有文件作用域，在源代码文件`

然后，可以在与源代码文件相关联的头文件中进行引用式声明：

`extern int status; // 在头文件中`

这行代码会出现在包含了该头文件的文件中，这样使用该系列函数的文件都能使用这个变量。虽然源代码文件中包含该头文件后也包含了该声明，但是只要声明的类型一致，在一个文件中同时使用定义式声明和引用式声明没问题。

需要包含头文件的另一种情况是，使用具有文件作用域、内部链接和 `const` 限定符的变量或数组。`const` 防止值被意外修改，`static` 意味着每个包含该头文件的文件都获得一份副本。因此，不需要在一个文件中进行定义式声明，在其他文件中进行引用式声明。

`#include` 和 `#define` 指令是最常用的两个C预处理器特性。接下来，我们介绍一些其他指令。

### 16.6　其他指令

程序员可能要为不同的工作环境准备C程序和C库包。不同的环境可能使用不同的代码类型。预处理器提供一些指令，程序员通过修改 `#define` 的值即可生成可移植的代码。`#undef` 指令取消之前的 `#define` 定义。`#if` 、`#ifdef` 、`#ifndef` 、`#else` 、`#elif` 和 `#endif` 指令用于指定什么情况下编写哪些代码。`#line` 指令用于重置行和文件信息，`#error` 指令用于给出错误消息，`#pragma` 指令用于向编译器发出指令。

#### 16.6.1　\#undef 指令

`#undef` 指令用于“取消”已定义的 `#define` 指令。也就是说，假设有如下定义：

`#define LIMIT 400`

然后，下面的指令:

`#undef LIMIT`

将移除上面的定义。现在就可以把 `LIMIT` 重新定义为一个新值。即使原来没有定义 `LIMIT` ，取消 `LIMIT` 的定义仍然有效。如果想使用一个名称，又不确定之前是否已经用过，为安全起见，可以用 `#undef` 指令取消该名字的定义。

#### 16.6.2　从C预处理器角度看已定义

处理器在识别标识符时，遵循与C相同的规则：标识符可以由大写字母、小写字母、数字和下线字符组成，且首字符不能是数字。当预处理器在预处理器指令中发现一个标识符时，它会把该标识符当作已定义的 或未定义的 。这里的已定义 表示由预处理器定义。如果标识符是同一个文件中由前面的 `#define` 指令创建的宏名，而且没有用 `#undef` 指令关闭，那么该标识符是已定义的。如果标识符不是宏，假设是一个文件作用域的C变量，那么该标识符对预处理器而言就是未定义的。

已定义宏可以是对象宏，包括空宏或类函数宏：

`#define LIMIT 1000 // LIMIT是已定义的`  
`#define GOOD // GOOD 是已定义的`  
`#define A(X) ((-(X))*(X)) // A 是已定义的`  
`int q; // q 不是宏，因此是未定义的`  
`#undef GOOD // GOOD 取消定义，是未定义的`

注意，`#define` 宏的作用域从它在文件中的声明处开始，直到用 `#undef` 指令取消宏为止，或延伸至文件尾（以二者中先满足的条件作为宏作用域的结束）。另外还要注意，如果宏通过头文件引入，那么 `#define` 在文件中的位置取决于 `#include` 指令的位置。

稍后将介绍几个预定义宏，如 `__DATE__` 和 `__FILE__` 。这些宏一定是已定义的，而且不能取消定义。

#### 16.6.3　条件编译

可以使用其他指令创建条件编译 （conditinal compilation ）。也就是说，可以使用这些指令告诉编译器根据编译时的条件执行或忽略信息（或代码）块。

**1．#ifdef 、#else 和#endif 指令**

我们用一个简短的示例来演示条件编译的情况。考虑下面的代码：

这是一个使用条件编译指令`#ifdef`、`#else`和`#endif`的C预处理器代码片段。根据宏`MAVIS`是否被定义，它会包含不同的头文件并定义不同的常量。

C

```
#ifdef MAVIS
#include "horse.h" // 如果已经用#define定义了 MAVIS，则执行下面
的指令
#define STABLES 5
#else
#include "cow.h" //如果没有用#define定义 MAVIS，则执行下面的指
令
#define STABLES 15
#endif
```

这里使用的较新的编译器和ANSI标准支持的缩进格式。如果使用旧的编译器，必须左对齐所有的指令或至少左对齐 `#` 号，如下所示：

这是与前例功能相同的代码片段，但展示了旧式编译器所要求的对齐风格，即`#`指令必须位于行首。

C

```
#ifdef MAVIS
#include "horse.h" // 如果已经用#define定义了 MAVIS，则执行下面
的指令
#define STABLES 5
#else
#include "cow.h" //如果没有用#define定义 MAVIS，则执行下面的
指令
#define STABLES 15
#endif
```

`#ifdef` 指令说明，如果预处理器已定义了后面的标识符（`MAVIS` ），则执行 `#else` 或 `#endif` 指令之前的所有指令并编译所有C代码（先出现哪个指令就执行到哪里）。如果预处理器未定义 `MAVIS` ，且有 `#else` 指令，则执行 `#else` 和 `#endif` 指令之间的所有代码。

`#ifdef` 　`#else` 很像C的 `if` 　`else` 。两者的主要区别是，预处理器不识别用于标记块的花括号（`{}` ），因此它使用 `#else` （如果需要）和 `#endif` （必须存在）来标记指令块。这些指令结构可以嵌套。也可以用这些指令标记C语句块，如程序清单16.9所示。

这是一个C语言程序（`ifdef.c`），它利用`#ifdef`条件编译指令来包含或排除一段用于调试的`printf`语句。

C

```
/* ifdef.c -- 使用条件编译 */
#include <stdio.h>
#define JUST_CHECKING
#define LIMIT 4
int main(void)
{
int i;
int total = 0;
for (i = 1; i <= LIMIT; i++)
{
total += 2 * i*i + 1;
#ifdef JUST_CHECKING
printf("i=%d, running total = %d\n", i, total);
#endif
}
printf("Grand total = %d\n", total);
return 0;
}
```

编译并运行该程序后，输出如下：

这是`ifdef.c`程序的运行输出结果。

text

```
i=1, running total = 3
i=2, running total = 12
i=3, running total = 31
i=4, running total = 64
Grand total = 64
```

如果省略 `JUST_CHECKING` 定义（把它放在C注释中，或者使用 `#undef` 指令取消它的定义）并重新编译该程序，只会输出最后一行。可以用这种方法在调试程序。定义 `JUST_CHECKING` 并合理使用 `#ifdef` ，编译器将执行用于调试的程序代码，打印中间值。调试结束后，可移除 `JUST_CHECKING` 定义并重新编译。如果以后还需要使用这些信息，重新插入定义即可。这样做省去了再次输入额外打印语句的麻烦。`#ifdef` 还可用于根据不同的C实现选择合适的代码块。

**2．#ifndef 指令**

`#ifndef` 指令与 `#ifdef` 指令的用法类似，也可以和 `#else` 、`#endif` 一起使用，但是它们的逻辑相反。`#ifndef` 指令判断后面的标识符是否是未定义的，常用于定义之前未定义的常量。如下所示：

这个预处理器代码片段使用`#ifndef`来确保宏`SIZE`只被定义一次。如果`SIZE`尚未定义，则将其定义为100。

C

```
/* arrays.h */
#ifndef SIZE
#define SIZE 100
#endif
```

（旧的实现可能不允许使用缩进的 `#define` ）

通常，包含多个头文件时，其中的文件可能包含了相同宏定义。`#ifndef` 指令可以防止相同的宏被重复定义。在首次定义一个宏的头文件中用 `#ifndef` 指令激活定义，随后在其他头文件中的定义都被忽略。

`#ifndef` 指令还有另一种用法。假设有上面的 `arrays.h` 头文件，然后把下面一行代码放入一个头文件中：

`#include "arrays.h"`

`SIZE` 被定义为100 。但是，如果把下面的代码放入该头文件：

这段代码展示了如何通过在包含头文件之前定义一个宏来覆盖头文件中的默认定义。

C

```
#define SIZE 10
#include "arrays.h"
```

`SIZE` 则被设置为10 。这里，当执行到 `#include "arrays.h"` 这行，处理 `array.h` 中的代码时，由于 `SIZE` 是已定义的，所以跳过了 `#define SIZE 100` 这行代码。鉴于此，可以利用这种方法，用一个较小的数组测试程序。测试完毕后，移除 `#define SIZE 10` 并重新编译。这样，就不用修改头文件数组本身了。

`#ifndef` 指令通常用于防止多次包含一个文件。也就是说，应该像下面这样设置头文件：

这是一种标准的头文件保护机制（include guard），使用`#ifndef`、`#define`和`#endif`来防止同一个头文件被多次包含到同一个源文件中。

C

```
/* things.h */
#ifndef THINGS_H_
#define THINGS_H_
/* 省略了头文件中的其他内容*/
#endif
```

假设该文件被包含了多次。当预处理器首次发现该文件被包含时，`THINGS_H_` 是未定义的，所以定义了 `THINGS_H_` ，并接着处理该文件的其他部分。当预处理器第2次发现该文件被包含时，`THINGS_H_` 是已定义的，所以预处理器跳过了该文件的其他部分。

为何要多次包含一个文件？最常见的原因是，许多被包含的文件中都包含着其他文件，所以显式包含的文件中可能包含着已经包含的其他文件。这有什么问题？在被包含的文件中有某些项（如，一些结构类型的声明）只能在一个文件中出现一次。C标准头文件使用 `#ifndef` 技巧避免重复包含。但是，这存在一个问题：如何确保待测试的标识符没有在别处定义。通常，实现的供应商使用这些方法解决这个问题：用文件名作为标识符、使用大写字母、用下划线字符代替文件名中的点字符、用下划线字符做前缀或后缀（可能使用两条下划线）。例如，查看 `stdio.h` 头文件，可以发现许多类似的代码：

这是一个在标准库头文件中常见的头文件保护机制示例。

C

```
#ifndef _STDIO_H
#define _STDIO_H
// 省略了文件的内容
#endif
```

你也可以这样做。但是，由于标准保留使用下划线作为前缀，所以在自己的代码中不要这样写，避免与标准头文件中的宏发生冲突。程序清单16.10修改了程序清单16.6中的头文件，使用 `#ifndef` 避免文件被重复包含。

这是对`names_st.h`头文件的修订版本（`names.h`），增加了头文件保护机制以防止被重复包含。

C

```
// names.h --修订后的 names_st 头文件，避免重复包含
#ifndef NAMES_H_
#define NAMES_H_
// 明示常量
#define SLEN 32
// 结构声明
struct names_st
{
char first[SLEN];
char last[SLEN];
};
// 类型定义
typedef struct names_st names;
// 函数原型
void get_names(names *);
void show_names(const names *);
char * s_gets(char * st, int n);
#endif
```

用程序清单16.11的程序测试该头文件没问题，但是如果把清单16.10中的 `#ifndef` 保护删除后，程序就无法通过编译。

这是一个C语言程序（`doubincl.c`），它故意两次包含同一个头文件，以测试头文件保护机制是否有效。

C

```
// doubincl.c -- 包含头文件两次
#include <stdio.h>
#include "names.h"
#include "names.h" // 不小心第2次包含头文件
int main()
{
names winner = { "Less", "Ismoor" };
printf("The winner is %s %s.\n", winner.first,
winner.last);
return 0;
}
```

**3．#if 和#elif 指令**

`#if` 指令很像C语言中的 `if` 。`#if` 后面跟整型常量表达式，如果表达式为非零，则表达式为真。可以在指令中使用C的关系运算符和逻辑运算符：

这个代码片段演示了如何使用`#if`指令根据宏`SYS`的值来条件性地包含一个文件。

C

```
#if SYS == 1
#include "ibm.h"
#endif
```

可以按照 `if else` 的形式使用 `#elif` （早期的实现不支持 `#elif` ）。例如，可以这样写：

这个代码片段使用`#if`、`#elif`和`#else`指令链，根据宏`SYS`的不同值来包含适用于特定系统的头文件。

C

```
#if SYS == 1
#include "ibmpc.h"
#elif SYS == 2
#include "vax.h"
#elif SYS == 3
#include "mac.h"
#else
#include "general.h"
#endif
```

较新的编译器提供另一种方法测试名称是否已定义，即用 `#if defined (VAX)` 代替 `#ifdef VAX` 。

这里，`defined` 是一个预处理运算符，如果它的参数是用 `#defined` 定义过，则返回1 ；否则返回0 。这种新方法的优点是，它可以和 `#elif` 一起使用。下面用这种形式重写前面的示例：

这个代码片段展示了`defined`运算符的用法，它与`#if`和`#elif`结合，提供了一种比`#ifdef`更灵活的方式来根据不同宏的定义选择性地包含代码。

C

```
#if defined (IBMPC)
#include "ibmpc.h"
#elif defined (VAX)
#include "vax.h"
#elif defined (MAC)
#include "mac.h"
#else
#include "general.h"
#endif
```

如果在VAX机上运行这几行代码，那么应该在文件前面用下面的代码定义 `VAX` ：

`#define VAX`

条件编译还有一个用途是让程序更容易移植。改变文件开头部分的几个关键的定义，即可根据不同的系统设置不同的值和包含不同的文件。

#### 16.6.4　预定义宏

C标准规定了一些预定义宏，如表16.1所列。

**表16.1　预定义宏**

|宏|含义|
|---|---|
|`_ _DATE_ _`|预处理的日期（`"Mmm dd yyyy"` 形式的字符串字面量，如 `Nov 23 2013` ）|
|`_ _FILE_ _`|表示当前源代码文件名的字符串字面量|
|`_ _LINE_ _`|表示当前源代码文件中行号的整型常量|
|`_ _STDC_ _`|设置为1 时，表明实现遵循C 标准|
|`_ _STDC_HOSTED_ _`|本机环境设置为1 ；否则设置为0|
|`_ _STDC_VERSION_ _`|支持C99 标准，设置为 `199901L` ；支持C11 标准，设置为 `201112L`|
|`_ _TIME_ _`|翻译代码的时间，格式为“`hh:mm:ss`”|

C99标准提供一个名为 `_ _func_ _` 的预定义标识符，它展开为一个代表函数名的字符串（该函数包含该标识符）。那么，`_ _func_ _` 必须具有函数作用域，而从本质上看宏具有文件作用域。因此，`_ _func_ _` 是C语言的预定义标识符，而不是预定义宏。

程序清单16.12中使用了一些预定义宏和预定义标识符。注意，其中一些是C99新增的，所以不支持C99的编译器可能无法识别它们。如果使用GCC，必须设置 `-std=c99` 或 `-std=c11` 。

这是一个C语言程序（`predef.c`），它打印出C标准中预定义的宏和标识符的值，如文件名、日期、时间和行号等。

C

```
// predef.c -- 预定义宏和预定义标识符
#include <stdio.h>
void why_me();
int main()
{
printf("The file is %s.\n", _ _FILE_ _);
printf("The date is %s.\n", _ _DATE_ _);
printf("The time is %s.\n", _ _TIME_ _);
printf("The version is %ld.\n", _ _STDC_VERSION_ _);
printf("This is line %d.\n", _ _LINE_ _);
printf("This function is %s\n", _ _func_ _);
why_me();
return 0;
}
void why_me()
{
printf("This function is %s\n", _ _func_ _);
printf("This is line %d.\n", _ _LINE_ _);
}
```

下面是该程序的输出：

这是`predef.c`程序的运行输出结果。

text

```
The file is predef.c.
The date is Sep 23 2013.
The time is 22:01:09.
The version is 201112.
This is line 11.
This function is main
This function is why_me
This is line 21.
```

#### 16.6.5　#line 和#error

`#line` 指令重置 `_ _LINE_ _` 和 `_ _FILE_ _` 宏报告的行号和文件名。可以这样使用 `#line` ：

`#line 1000 // 把当前行号重置为1000`  
`#line 10 "cool.c" // 把行号重置为10，把文件名重置为cool.c`

`#error` 指令让预处理器发出一条错误消息，该消息包含指令中的文本。如果可能的话，编译过程应该中断。可以这样使用 `#error` 指令：

这个代码片段使用`#error`指令来检查编译器是否支持C11标准，如果不支持，则在编译时产生一条错误信息并中止编译。

C

```
#if _ _STDC_VERSION_ _ != 201112L
#error Not C11
#endif
```

编译以上代码生成后，输出如下：

这是在不同编译选项下，上述`#error`代码片段的编译输出。

text

```
$ gcc newish.c
newish.c:14:2: error: #error Not C11
$ gcc -std=c11 newish.c
$
```

如果编译器只支持旧标准，则会编译失败，如果支持C11标准，就能成功编译。

#### 16.6.6　#pragma

在现在的编译器中，可以通过命令行参数或IDE菜单修改编译器的一些设置。`#pragma` 把编译器指令放入源代码中。例如，在开发C99时，标准被称为C9X，可以使用下面的编译指示 （pragma ）让编译器支持C9X：

`#pragma c9x on`

一般而言，编译器都有自己的编译指示集。例如，编译指示可能用于控制分配给自动变量的内存量，或者设置错误检查的严格程度，或者启用非标准语言特性等。C99标准提供了3个标准编译指示，但是超出了本书讨论的范围。

C99还提供 `_Pragma` 预处理器运算符，该运算符把字符串转换成普通的编译指示。例如：

`_Pragma("nonstandardtreatmenttypeB on")`

等价于下面的指令：

`#pragma nonstandardtreatmenttypeB on`

由于该运算符不使用 `#` 符号，所以可以把它作为宏展开的一部分：

`#define PRAGMA(X) _Pragma(#X)`  
`#define LIMRG(X) PRAGMA(STDC CX_LIMITED_RANGE X)`

然后，可以使用类似下面的代码：

`LIMRG ( ON )`

顺带一提，下面的定义看上去没问题，但实际上无法正常运行：

`#define LIMRG(X) _Pragma(STDC CX_LIMITED_RANGE #X)`

问题在于这行代码依赖字符串的串联功能，而预处理过程完成之后才会串联字符串。

`_Pragma` 运算符完成“解字符串”（destringizing ）的工作，即把字符串中的转义序列转换成它所代表的字符。因此，`_Pragma("use_bool \"true \"false")` 变成了：

`#pragma use_bool "true "false`

#### 16.6.7　泛型选择（C11）

在程序设计中，泛型编程 （generic programming ）指那些没有特定类型，但是一旦指定一种类型，就可以转换成指定类型的代码。例如，C++在模板中可以创建泛型算法，然后编译器根据指定的类型自动使用实例化代码。C没有这种功能。然而，C11新增了一种表达式，叫作泛型选择表达式 （generic selection expression ），可根据表达式的类型（即表达式的类型是 `int` 、`double` 还是其他类型）选择一个值。泛型选择表达式不是预处理器指令，但是在一些泛型编程中它常用作 `#define` 宏定义的一部分。

下面是一个泛型选择表达式的示例：

`_Generic(x, int: 0, float: 1, double: 2, default: 3)`

`_Generic` 是C11的关键字。`_Generic` 后面的圆括号中包含多个用逗号分隔的项。第1个项是一个表达式，后面的每个项都由一个类型、一个冒号和一个值组成，如 `float: 1` 。第1个项的类型匹配哪个标签，整个表达式的值是该标签后面的值。例如，假设上面表达式中 `x` 是 `int` 类型的变量，`x` 的类型匹配 `int:` 标签，那么整个表达式的值就是0 。如果没有与类型匹配的标签，表达式的值就是 `default:` 标签后面的值。泛型选择语句与 `switch` 语句类似，只是前者用表达式的类型匹配标签，而后者用表达式的值匹配标签。

下面是一个把泛型选择语句和宏定义组合的例子：

这个`#define`宏使用了C11的`_Generic`特性，根据传入参数`X`的类型返回一个描述该类型的字符串。

C

```
#define MYTYPE(X) _Generic((X),\
int: "int",\
float : "float",\
double: "double",\
default: "other"\
)
```

宏必须定义为一条逻辑行，但是可以用 `\` 把一条逻辑行分隔成多条物理行。在这种情况下，对泛型选择表达式求值得字符串。例如，对 `MYTYPE(5)` 求值得 `"int"` ，因为值5 的类型与 `int:` 标签匹配。程序清单16.13演示了这种用法。

这是一个C11程序（`mytype.c`），它使用`_Generic`泛型选择表达式来确定不同变量和表达式的类型，并打印出相应的类型名称字符串。

C

```
// mytype.c
#include <stdio.h>
#define MYTYPE(X) _Generic((X),\
int: "int",\
float : "float",\
double: "double",\
default: "other"\
)
int main(void)
{
int d = 5;
printf("%s\n", MYTYPE(d)); // d 是int类型
printf("%s\n", MYTYPE(2.0*d)); // 2.0 * d 是double类型
printf("%s\n", MYTYPE(3L)); // 3L 是long类型
printf("%s\n", MYTYPE(&d)); // &d 的类型是 int *
return 0;
}
```

下面是该程序的输出：

这是`mytype.c`程序的运行输出结果。

text

```
int
double
other
other
```

`MYTYPE()` 最后两个示例所用的类型与标签不匹配，所以打印默认的字符串。可以使用更多类型标签来扩展宏的能力，但是该程序主要是为了演示 `_Generic` 的基本工作原理。

对一个泛型选择表达式求值时，程序不会先对第一个项求值，它只确定类型。只有匹配标签的类型后才会对表达式求值。

可以像使用独立类型（“泛型”）函数那样使用 `_Generic` 定义宏。本章后面介绍 `math` 库时会给出一个示例。
### 16.7　内联函数（C99）

通常，函数调用都有一定的开销，因为函数的调用过程包括建立调用、传递参数、跳转到函数代码并返回。使用宏使代码内联，可以避免这样的开销。C99还提供另一种方法：内联函数 （`inline function`）。读者可能顾名思义地认为内联函数会用内联代码替换函数调用。其实C99和C11标准中叙述的是：“把函数变成内联函数建议尽可能快地调用该函数，其具体效果由实现定义”。因此，把函数变成内联函数，编译器可能会用内联代码替换函数调用，并（或）执行一些其他的优化，但是也可能不起作用。

创建内联函数的定义有多种方法。标准规定具有内部链接的函数可以成为内联函数，还规定了内联函数的定义与调用该函数的代码必须在同一个文件中。因此，最简单的方法是使用函数说明符`inline`和存储类别说明符`static`。通常，内联函数应定义在首次使用它的文件中，所以内联函数也相当于函数原型。如下所示：

这是一个内联函数的简单示例。该函数使用 `inline` 和 `static` 关键字定义，并在 `main` 函数中被调用。

text

```
#include <stdio.h>
inline static void eatline() // 内联函数定义/原型
{
while (getchar() != '\n')
continue;
}
int main()
{
...
eatline(); // 函数调用
...
}
```

编译器查看内联函数的定义（也是原型），可能会用函数体中的代码替换`eatline()`函数调用。也就是说，效果相当于在函数调用的位置输入函数体中的代码：

编译器可能会将 `eatline()` 函数调用替换为其函数体内的代码，效果如下所示。

text

```
#include <stdio.h>
inline static void eatline() //内联函数定义/原型
{
while (getchar() != '\n')
continue;
}
int main()
{
...
while (getchar() != '\n') //替换函数调用
continue;
...
}
```

由于并未给内联函数预留单独的代码块，所以无法获得内联函数的地址（实际上可以获得地址，不过这样做之后，编译器会生成一个非内联函数）。另外，内联函数无法在调试器中显示。

内联函数应该比较短小。把较长的函数变成内联并未节约多少时间，因为执行函数体的时间比调用函数的时间长得多。

编译器优化内联函数必须知道该函数定义的内容。这意味着内联函数定义与函数调用必须在同一个文件中。鉴于此，一般情况下内联函数都具有内部链接。因此，如果程序有多个文件都要使用某个内联函数，那么这些文件中都必须包含该内联函数的定义。最简单的做法是，把内联函数定义放入头文件，并在使用该内联函数的文件中包含该头文件即可。

为了在多个文件中使用同一个内联函数，通常将其定义放在头文件中，并使用头文件保护符（`#ifndef`/`#define`/`#endif`）来防止重复包含。

text

```
// eatline.h
#ifndef EATLINE_H_
#define EATLINE_H_
inline static void eatline()
{
while (getchar() != '\n')
continue;
}
#endif
```

一般都不在头文件中放置可执行代码，内联函数是个特例。因为内联函数具有内部链接，所以在多个文件中定义同一个内联函数不会产生什么问题。

与C++不同的是，C还允许混合使用内联函数定义和外部函数定义（具有外部链接的函数定义）。例如，一个程序中使用下面3个文件：

以下示例展示了在一个程序中的三个不同文件中，如何混合使用 `inline static` 定义、普通的外部函数定义以及省略 `static` 的 `inline` 定义。

text

```
//file1.c
...
inline static double square(double);
double square(double x) { return x * x; }
int main()
{
double q = square(1.3);
...
//file2.c
...
double square(double x) { return (int) (x*x); }
void spam(double v)
{
double kv = square(v);
...
//file3.c
...
inline double square(double x) { return (int) (x * x + 0.5); }
void masp(double w)
{
double kw = square(w);
...
```

如上述代码所示，3个文件中都定义了`square()`函数。  
`file1.c`文件中是`inline static`定义；`file2.c`文件中是普通的函数定义（因此具有外部链接）；`file3.c`文件中是`inline`定义，省略了`static`。

3个文件中的函数都调用了`square()`函数，这会发生什么情况？。`file1.c`文件中的`main()`使用`square()`的局部`static`定义。由于该定义也是`inline`定义，所以编译器有可能优化代码，也许会内联该函数。`file2.c`文件中，`spam()`函数使用该文件中`square()`函数的定义，该定义具有外部链接，其他文件也可见。`file3.c`文件中，编译器既可以使用该文件中`square()`函数的内联定义，也可以使用`file2.c`文件中的外部链接定义。如果像`file3.c`那样，省略`file1.c`文件`inline`定义中的`static`，那么该`inline`定义被视为可替换的外部定义。

注意GCC在C99之前就使用一些不同的规则实现了内联函数，所以GCC可以根据当前编译器的标记来解释`inline`。

### 16.8　_Noreturn 函数（C11）

C99新增`inline`关键字时，它是唯一的函数说明符（关键字`extern`和`static`是存储类别说明符，可应用于数据对象和函数）。C11新增了第2个函数说明符`_Noreturn`，表明调用完成后函数不返回主调函数。`exit()`函数是`_Noreturn`函数的一个示例，一旦调用`exit()`，它不会再返回主调函数。注意，这与`void`返回类型不同。`void`类型的函数在执行完毕后返回主调函数，只是它不提供返回值。

`_Noreturn`的目的是告诉用户和编译器，这个特殊的函数不会把控制返回主调程序。告诉用户以免滥用该函数，通知编译器可优化一些代码。

### 16.9　C库

最初，并没有官方的C库。后来，基于UNIX的C实现成为了标准。ANSI C委员会主要以这个标准为基础，开发了一个官方的标准库。在意识到C语言的应用范围不断扩大后，该委员会重新定义了这个库，使之可以应用于其他系统。

我们讨论过一些标准库中的I/O函数、字符函数和字符串函数。本章将介绍更多函数。不过，首先要学习如何使用库。

#### 16.9.1　访问C库

如何访问C库取决于实现，因此你要了解当前系统的一般情况。首先，可以在多个不同的位置找到库函数。例如，`getchar()`函数通常作为宏定义在`stdio.h`头文件中，而`strlen()`通常在库文件中。其次，不同的系统搜索这些函数的方法不同。下面介绍3种可能的方法。

**1．自动访问**

在一些系统中，只需编译程序，就可使用一些常用的库函数。

记住，在使用函数之前必须先声明函数的类型，通过包含合适的头文件即可完成。在描述库函数的用户手册中，会指出使用某函数时应包含哪个头文件。但是在一些旧系统上，可能必须自己输入函数声明。再次提醒读者，用户手册中指明了函数类型。另外，附录B“参考资料”中根据头文件分组，总结了ANSI C库函数。

过去，不同的实现使用的头文件名不同。ANSI C标准把库函数分为多个系列，每个系列的函数原型都放在一个特定的头文件中。

**2．文件包含**

如果函数被定义为宏，那么可以通过`#include`指令包含定义宏函数的文件。通常，类似的宏都放在合适名称的头文件中。例如，许多系统（包括所有的ANSI C系统）都有`ctype.h`文件，该文件中包含了一些确定字符性质（如大写、数字等）的宏。

**3．库包含**

在编译或链接程序的某些阶段，可能需要指定库选项。即使在自动检查标准库的系统中，也会有不常用的函数库。必须通过编译时选项显式指定这些库。注意，这个过程与包含头文件不同。头文件提供函数声明或原型，而库选项告诉系统到哪里查找函数代码。虽然这里无法涉及所有系统的细节，但是可以提醒读者应该注意什么。

#### 16.9.2　使用库描述

篇幅有限，我们无法讨论完整的库。但是，可以看几个具有代表性的示例。首先，了解函数文档。

可以在多个地方找到函数文档。你所使用的系统可能有在线手册，集成开发环境通常都有在线帮助。C实现的供应商可能提供描述库函数的纸质版用户手册，或者把这些材料放在CD-ROM中或网上。有些出版社也出版C库函数的参考手册。这些材料中，有些是一般材料，有些则是针对特定实现的。本书附录B中提供了一个库函数的总结。

阅读文档的关键是看懂函数头。许多内容随时间变化而变化。下面是旧的UNIX文档中，关于`fread()`的描述：

这是一个早期UNIX文档中对 `fread()` 函数的描述格式，它省略了部分类型声明，依赖于旧的C语言默认类型规则。

text

```
#include <stdio.h>
fread(ptr, sizeof(*ptr), nitems, stream)
FILE *stream;
```

首先，给出了应该包含的文件，但是没有给出`fread()`、`ptr`、`sizeof(*ptr)`或`nitems`的类型。过去，默认类型都是`int`，但是从描述中可以看出`ptr`是一个指针（在早期的C中，指针被作为整数处理）。参数`stream`声明为指向`FILE`的指针。上面的函数声明中的第2个参数看上去像是`sizeof`运算符，而实际上这个参数的值应该是`ptr`所指向对象的大小。虽然用`sizeof`作为参数没什么问题，但是用`int`类型的值作为参数更符合语法。

后来，上面的描述变成了：

这是后来演进的 `fread()` 函数描述，明确了返回值和所有参数的类型。

text

```
#include <stdio.h>
int fread(ptr, size, nitems, stream;)
char *ptr;
int size, nitems;
FILE *stream;
```

现在，所有的类型都显式说明，`ptr`作为指向`char`的指针。

ANSI C90标准提供了下面的描述：  
`#include <stdio.h> size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);`

首先，使用了新的函数原型格式。其次，改变了一些类型。`size_t`类型被定义为`sizeof`运算符的返回值类型——无符号整数类型，通常是`unsigned int`或`unsigned long`。`stddef.h`文件中包含了`size_t`类型的`typedef`或`#define`定义。其他文件（包括`stdio.h`）通过包含`stddef.h`来包含这个定义。许多函数（包括`fread()`）的实际参数中都要使用`sizeof`运算符，形式参数的`size_t`类型中正好匹配这种常见的情况。

另外，ANSI C把指向`void`的指针作为一种通用指针，用于指针指向不同类型的情况。例如，`fread()`的第1个参数可能是指向一个`double`类型数组的指针，也可能是指向其他类型结构的指针。如果假设实际参数是一个指向内含20个`double`类型元素数组的指针，且形式参数是指向`void`的指针，那么编译器会选用合适的类型，不会出现类型冲突的问题。

C99/C11标准在以上的描述中加入了新的关键字`restrict`：  
`#include <stdio.h> size_t fread(void * restrict ptr, size_t size, size_t nmemb, FILE * restrict stream);`

接下来，我们讨论一些特殊的函数。

### 16.10　数学库

数学库中包含许多有用的数学函数。`math.h`头文件提供这些函数的原型。表16.2中列出了一些声明在`math.h`中的函数。注意，函数中涉及的角度都以弧度为单位（1弧度=180/π=57.296度）。参考资料V“新增C99和C11标准的ANSI C库”列出了C99和C11标准的所有函数。

**表16.2　ANSI C标准的一些数学函数**

|原型|描述|
|---|---|
|`double acos(double x)`|返回余弦值为x 的角度（0～π弧度）|
|`double asin(double x)`|返回正弦值为x 的角度（−π/2～π/2弧度）|
|`double atan(double x)`|返回正切值为x 的角度（−π/2～π/2弧度）|
|`double atan2(double y, double x)`|返回正弦值为y/x 的角度（−π～π弧度）|
|`double cos(double x)`|返回x 的余弦值，x 的单位为弧度|
|`double sin(double x)`|返回x 的正弦值，x 的单位为弧度|
|`double tan(double x)`|返回x 的正切值，x 的单位为弧度|
|`double exp(double x)`|返回x 的指数函数的值（ex ）|
|`double log(double x)`|返回x 的自然对数值|
|`double log10(double x)`|返回x 的以10 为底的对数值|
|`double pow(double x, double y)`|返回x 的y 次幂|
|`double sqrt(double x)`|返回x 的平方值|
|`double cbrt(double x)`|返回x 的立方值|
|`double ceil(double x)`|返回不小于x 的最小整数值|
|`double fabs(double x)`|返回x 的绝对值|
|`double floor(double x)`|返回不大于x 的最大整数值|

#### 16.10.1　三角问题

我们可以使用数学库解决一些常见的问题：把x/y 坐标转换为长度和角度。例如，在网格上画了一条线，该线条水平穿过了4个单元（x 的值），垂直穿过了3个单元（y 的值）。那么，该线的长度（量）和方向是什么？根据数学的三角公式可知：

大小 = square root (x² + y²)  
角度 = arctan(y/x)

数学库提供平方根函数和一对反正切函数，所以可以用C程序表示这个问题。平方根函数是`sqrt()`，接受一个`double`类型的参数，并返回参数的平方根，也是`double`类型。

`atan()`函数接受一个`double`类型的参数（即正切值），并返回一个角度（该角度的正切值就是参数值）。但是，当线的x 值和y值均为-5 时，`atan()`函数产生混乱。因为(-5)/(-5) 得1 ，所以`atan()`返回45°，该值与x 和y 均为5 时的返回值相同。也就是说，`atan()`无法区分角度相同但反向相反的线（实际上，`atan()`返回值的单位是弧度而不是度，稍后介绍两者的转换）。

当然，C库还提供了`atan2()`函数。它接受两个参数：x 的值和y 的值。这样，通过检查x 和y 的正负号就可以得出正确的角度值。`atan2()`和`atan()`均返回弧度值。把弧度转换为度，只需将弧度值乘以180 ，再除以pi 即可。pi 的值通过计算表达式`4*atan(1)`得到。程序清单16.13演示了这些步骤。另外，学习该程序还复习了结构和`typedef`相关的知识。

#### rect_pol.c 程序

该程序演示了如何使用数学库中的 `sqrt()` 和 `atan2()` 函数将直角坐标（x, y）转换为极坐标（模长, 角度）。它还定义了 `RAD_TO_DEG` 宏用于将弧度转换为度。

text

```
/* rect_pol.c -- 把直角坐标转换为极坐标 */
#include <stdio.h>
#include <math.h>
#define RAD_TO_DEG (180/(4 * atan(1)))
typedef struct polar_v {
double magnitude;
double angle;
} Polar_V;
typedef struct rect_v {
double x;
double y;
} Rect_V;
Polar_V rect_to_polar(Rect_V);
int main(void)
{
Rect_V input;
Polar_V result;
puts("Enter x and y coordinates; enter q to quit:");
while (scanf("%lf %lf", &input.x, &input.y) == 2)
{
result = rect_to_polar(input);
printf("magnitude = %0.2f, angle = %0.2f\n",
result.magnitude, result.angle);
}
puts("Bye.");
return 0;
}
Polar_V rect_to_polar(Rect_V rv)
{
Polar_V pv;
pv.magnitude = sqrt(rv.x * rv.x + rv.y * rv.y);
if (pv.magnitude == 0)
pv.angle = 0.0;
else
pv.angle = RAD_TO_DEG * atan2(rv.y, rv.x);
return pv;
}
```

下面是运行该程序后的一个输出示例：

这是 `rect_pol.c` 程序的一个运行示例输出。

text

```
Enter x and y coordinates; enter q to quit:
10 10
magnitude = 14.14, angle = 45.00
-12 -5
magnitude = 13.00, angle = -157.38
q
Bye.
```

如果编译时出现下面的消息：  
`Undefined: _sqrt`  
或  
`'sqrt': unresolved external`  
或者其他类似的消息，表明编译器链接器没有找到数学库。UNIX系统会要求使用`-lm`标记（flag ）指示链接器搜索数学库：  
`cc rect_pol.c –lm`

注意，`-lm`标记在命令行的末尾。因为链接器在编译器编译C文件后才开始处理。在Linux中使用GCC编译器可能要这样写：  
`gcc rect_pol.c -lm`

#### 16.10.2　类型变体

基本的浮点型数学函数接受`double`类型的参数，并返回`double`类型的值。当然，也可以把`float`或`long double`类型的参数传递给这些函数，它们仍然能正常工作，因为这些类型的参数会被转换成`double`类型。这样做很方便，但并不是最好的处理方式。如果不需要双精度，那么用`float`类型的单精度值来计算会更快些。而且把`long double`类型的值传递给`double`类型的形参会损失精度，形参获得的值可能不是原来的值。为了解决这些潜在的问题，C标准专门为`float`类型和`long double`类型提供了标准函数，即在原函数名后加上f 或l 后缀。因此，`sqrtf()`是`sqrt()`的`float`版本，`sqrtl()`是`sqrt()`的`long double`版本。

利用C11新增的泛型选择表达式定义一个泛型宏，根据参数类型选择最合适的数学函数版本。程序清单16.15演示了两种方法。

#### generic.c 程序

该程序利用C11新增的 `_Generic` 表达式来创建泛型宏。`SQRT(X)` 和 `SIN(X)` 宏可以根据传入参数 `X` 的类型（`float`, `double`, `long double`）自动选择调用相应版本的数学函数（如 `sqrtf`, `sqrt`, `sqrtl`）。

text

```
// generic.c -- 定义泛型宏
#include <stdio.h>
#include <math.h>
#define RAD_TO_DEG (180/(4 * atanl(1)))
// 泛型平方根函数
#define SQRT(X) _Generic((X),\
long double: sqrtl, \
default: sqrt, \
float: sqrtf)(X)
// 泛型正弦函数，角度的单位为度
#define SIN(X) _Generic((X),\
long double: sinl((X)/RAD_TO_DEG),\
default: sin((X)/RAD_TO_DEG),\
float: sinf((X)/RAD_TO_DEG)\
)
int main(void)
{
float x = 45.0f;
double xx = 45.0;
long double xxx = 45.0L;
long double y = SQRT(x);
long double yy = SQRT(xx);
long double yyy = SQRT(xxx);
printf("%.17Lf\n", y); // 匹配 float
printf("%.17Lf\n", yy); // 匹配 default
printf("%.17Lf\n", yyy); // 匹配 long double
int i = 45;
yy = SQRT(i); // 匹配 default
printf("%.17Lf\n", yy);
yyy = SIN(xxx); // 匹配 long double
printf("%.17Lf\n", yyy);
return 0;
}
```

下面是该程序的输出：

这是 `generic.c` 程序的输出结果，展示了泛型宏如何根据不同类型的输入调用了不同的函数版本，并打印出高精度的计算结果。

text

```
6.70820379257202148
6.70820393249936942
6.70820393249936909
6.70820393249936942
0.70710678118654752
```

如上所示，`SQRT(i)`和`SQRT(xx)`的返回值相同，因为它们的参数类型分别是`int`和`double`，所以只能与`default`标签对应。

有趣的一点是，如何让`_Generic`宏的行为像一个函数。`SIN()`的定义也许提供了一个方法：每个带标号的值都是函数调用，所以`_Generic`表达式的值是一个特定的函数调用，如`sinf((X)/RAD_TO_DEG)`，用传入`SIN()`的参数替换X 。

`SQRT()`的定义也许更简洁。`_Generic`表达式的值就是函数名，如`sinf`。函数的地址可以代替该函数名，所以`_Generic`表达式的值是一个指向函数的指针。然而，紧随整个`_Generic`表达式之后的是`(X)`，函数指针(参数)表示函数指针。因此，这是一个带指定的参数的函数指针。

简而言之，对于`SIN()`，函数调用在泛型选择表达式内部；而对于`SQRT()`，先对泛型选择表达式求值得一个指针，然后通过该指针调用它所指向的函数。

#### 16.10.3　tgmath.h 库（C99）

C99标准提供的`tgmath.h`头文件中定义了泛型类型宏，其效果与程序清单16.15类似。如果在`math.h`中为一个函数定义了3种类型（`float`、`double`和`long double`）的版本，那么`tgmath.h`文件就创建一个泛型类型宏，与原来`double`版本的函数名同名。例如，根据提供的参数类型，定义`sqrt()`宏展开为`sqrtf()`、`sqrt()`或`sqrtl()`函数。换言之，`sqrt()`宏的行为和程序清单16.15中的`SQRT()`宏类似。

如果编译器支持复数运算，就会支持`complex.h`头文件，其中声明了与复数运算相关的函数。例如，声明有`csqrtf()`、`csqrt()`和`csqrtl()`，这些函数分别返回`float complex`、`double complex`和`long double complex`类型的复数平方根。如果提供这些支持，那么`tgmath.h`中的`sqrt()`宏也能展开为相应的复数平方根函数。

如果包含了`tgmath.h`，要调用`sqrt()`函数而不是`sqrt()`宏，可以用圆括号把被调用的函数名括起来：

这段代码演示了当包含 `tgmath.h` 头文件时，如何区分调用泛型宏 `sqrt()` 和调用原始的 `sqrt()` 函数。直接使用 `sqrt(x)` 会调用宏，而使用 `(sqrt)(x)` 则会调用函数本身。

text

```
#include <tgmath.h>
...
float x = 44.0;
double y;
y = sqrt(x); // 调用宏，所以是 sqrtf(x)
y = (sqrt)(x); // 调用函数 sqrt()
```

这样做没问题，因为类函数宏的名称必须用圆括号括起来。圆括号只会影响操作顺序，不会影响括起来的表达式，所以这样做得到的仍然是函数调用的结果。实际上，在讨论函数指针时提到过，由于C语言奇怪而矛盾的函数指针规则，还也可以使用`(*sqrt)()`的形式来调用`sqrt()`函数。

不借助C标准以外的机制，C11新增的`_Generic`表达式是实现`tgmath.h`最简单的方式。
### 16.11　通用工具库

通用工具库包含各种函数，包括随机数生成器、查找和排序函数、转换函数和内存管理函数。第12章介绍过`rand()`、`srand()`、`malloc()`和`free()`函数。在ANSI C标准中，这些函数的原型都在`stdlib.h`头文件中。附录B参考资料V列出了该系列的所有函数。现在，我们来进一步讨论其中的几个函数。

#### 16.11.1　exit() 和 atexit() 函数

在前面的章节中我们已经在程序示例中用过`exit()`函数。而且，在`main()`返回系统时将自动调用`exit()`函数。ANSI标准还新增了一些不错的功能，其中最重要的是可以指定在执行`exit()`时调用的特定函数。`atexit()`函数通过退出时注册被调用的函数提供这种功能，`atexit()`函数接受一个函数指针作为参数。程序清单16.16演示了它的用法。

#### byebye.c 程序

该程序演示了如何使用`atexit()`来注册函数（`sign_off`和`too_bad`），这些函数将在程序终止时被调用。一个函数被无条件注册，而另一个仅在输入无效时才注册。

text

```
/* byebye.c -- atexit()示例 */
#include <stdio.h>
#include <stdlib.h>
void sign_off(void);
void too_bad(void);
int main(void)
{
int n;
atexit(sign_off); /* 注册 sign_off()函数 */
puts("Enter an integer:");
if (scanf("%d", &n) != 1)
{
puts("That's no integer!");
atexit(too_bad); /* 注册 too_bad()函数 */
exit(EXIT_FAILURE);
}
printf("%d is %s.\n", n, (n % 2 == 0) ? "even" : "odd");
return 0;
}
void sign_off(void)
{
puts("Thus terminates another magnificent program from");
puts("SeeSaw Software!");
}
void too_bad(void)
{
puts("SeeSaw Software extends its heartfelt condolences");
puts("to you upon the failure of your program.");
}
```

下面是该程序的一个运行示例：  
这是用户输入有效整数时的程序输出。在程序退出时，只有在`main`函数开始时注册的`sign_off`函数被调用。

text

```
Enter an integer:
212
212 is even.
Thus terminates another magnificent program from
SeeSaw Software!
```

如果在IDE中运行，可能看不到最后两行。下面是另一个运行示例：  
这是用户输入无效内容时的程序输出。`too_bad`和`sign_off`函数都在程序退出时被调用，并且调用的顺序与它们注册的顺序相反。

text

```
Enter an integer:
what?
That's no integer!
SeeSaw Software extends its heartfelt condolences
to you upon the failure of your program.
Thus terminates another magnificent program from
SeeSaw Software!
```

在IDE中运行，可能看不到最后4行。

接下来，我们讨论`atexit()`和`exit()`的参数。

**1．atexit() 函数的用法**  
这个函数使用函数指针。要使用`atexit()`函数，只需把退出时要调用的函数地址传递给`atexit()`即可。函数名作为函数参数时相当于该函数的地址，所以该程序中把`sign_off`或`too_bad`作为参数。然后，`atexit()`注册函数列表中的函数，当调用`exit()`时就会执行这些函数。ANSI保证，在这个列表中至少可以放32个函数。最后调用`exit()`函数时，`exit()`会执行这些函数（执行顺序与列表中的函数顺序相反，即最后添加的函数最先执行）。

注意，输入失败时，会调用`sign_off()`和`too_bad()`函数；但是输入成功时只会调用`sign_off()`。因为只有输入失败时，才会进入if 语句中注册`too_bad()`。另外还要注意，最先调用的是最后一个被注册的函数。

`atexit()`注册的函数（如`sign_off()`和`too_bad()`）应该不带任何参数且返回类型为`void`。通常，这些函数会执行一些清理任务，例如更新监视程序的文件或重置环境变量。

注意，即使没有显式调用`exit()`，还是会调用`sign_off()`，因为`main()`结束时会隐式调用`exit()`。

**2．exit() 函数的用法**  
`exit()`执行完`atexit()`指定的函数后，会完成一些清理工作：刷新所有输出流、关闭所有打开的流和关闭由标准I/O函数`tmpfile()`创建的临时文件。然后`exit()`把控制权返回主机环境，如果可能的话，向主机环境报告终止状态。通常，UNIX程序使用0 表示成功终止，用非零值表示终止失败。UNIX返回的代码并不适用于所有的系统，所以ANSI C为了可移植性的要求，定义了一个名为`EXIT_FAILURE`的宏表示终止失败。类似地，ANSI C还定义了`EXIT_SUCCESS`表示成功终止。不过，`exit()`函数也接受0 表示成功终止。在ANSI C中，在非递归的`main()`中使用`exit()`函数等价于使用关键字`return`。尽管如此，在`main()`以外的函数中使用`exit()`也会终止整个程序。

#### 16.11.2　qsort() 函数

对较大型的数组而言，“快速排序”方法是最有效的排序算法之一。该算法由C.A.R.Hoare于1962年开发。它把数组不断分成更小的数组，直到变成单元素数组。首先，把数组分成两部分，一部分的值都小于另一部分的值。这个过程一直持续到数组完全排序好为止。

快速排序算法在C实现中的名称是`qsort()`。`qsort()`函数排序数组的数据对象，其原型如下：  
`void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));`

第1个参数是指针，指向待排序数组的首元素。ANSI C允许把指向任何数据类型的指针强制转换成指向`void`的指针，因此，`qsort()`的第1个实际参数可以引用任何类型的数组。

第2个参数是待排序项的数量。函数原型把该值转换为`size_t`类型。前面提到过，`size_t`定义在标准头文件中，是`sizeof`运算符返回的整数类型。

由于`qsort()`把第1个参数转换为`void`指针，所以`qsort()`不知道数组中每个元素的大小。为此，函数原型用第3个参数补偿这一信息，显式指明待排序数组中每个元素的大小。例如，如果排序`double`类型的数组，那么第3个参数应该是`sizeof(double)`。

最后，`qsort()`还需要一个指向函数的指针，这个被指针指向的比较函数用于确定排序的顺序。该函数应接受两个参数：分别指向待比较两项的指针。如果第1项的值大于第2项，比较函数则返回正数；如果两项相同，则返回0；如果第1项的值小于第2项，则返回负数。`qsort()`根据给定的其他信息计算出两个指针的值，然后把它们传递给比较函数。

`qsort()`原型中的第4个参数确定了比较函数的形式：  
`int (*compar)(const void *, const void *)`

这表明`qsort()`最后一个参数是一个指向函数的指针，该函数返回`int`类型的值且接受两个指向`const void`的指针作为参数，这两个指针指向待比较项。

程序清单16.17和后面的讨论解释了如何定义一个比较函数，以及如何使用`qsort()`。该程序创建了一个内含随机浮点值的数组，并排序了这个数组。

#### qsorter.c 程序

该程序演示了如何使用标准库函数 `qsort()` 来对一个 `double` 类型的数组进行排序。它实现了一个自定义的比较函数 `mycomp`，并将其地址传递给 `qsort()` 以指定排序规则。

text

```
/* qsorter.c -- 用 qsort()排序一组数字 */
#include <stdio.h>
#include <stdlib.h>
#define NUM 40
void fillarray(double ar [], int n);
void showarray(const double ar [], int n);
int mycomp(const void * p1, const void * p2);
int main(void)
{
double vals[NUM];
fillarray(vals, NUM);
puts("Random list:");
showarray(vals, NUM);
qsort(vals, NUM, sizeof(double), mycomp);
puts("\nSorted list:");
showarray(vals, NUM);
return 0;
}
void fillarray(double ar [], int n)
{
int index;
for (index = 0; index < n; index++)
ar[index] = (double) rand() / ((double) rand() + 0.1);
}
void showarray(const double ar [], int n)
{
int index;
for (index = 0; index < n; index++)
{
printf("%9.4f ", ar[index]);
if (index % 6 == 5)
putchar('\n');
}
if (index % 6 != 0)
putchar('\n');
}
/* 按从小到大的顺序排序 */
int mycomp(const void * p1, const void * p2)
{
/* 要使用指向double的指针来访问这两个值 */
const double * a1 = (const double *) p1;
const double * a2 = (const double *) p2;
if (*a1 < *a2)
return -1;
else if (*a1 == *a2)
return 0;
else
return 1;
}
```

下面是该程序的运行示例:  
这是 `qsorter.c` 程序的一个示例输出，显示了排序前随机生成的数字列表和排序后按升序排列的列表。

text

```
Random list:
0.0001 1.6475 2.4332 0.0693 0.7268 0.7383
24.0357 0.1009 87.1828 5.7361 0.6079 0.6330
1.6058 0.1406 0.5933 1.1943 5.5295 2.2426
0.8364 2.7127 0.2514 0.9593 8.9635 0.7139
0.6249 1.6044 0.8649 2.1577 0.5420 15.0123
1.7931 1.6183 1.9973 2.9333 12.8512 1.3034
0.3032 1.1406 18.7880 0.9887
Sorted list:
0.0001 0.0693 0.1009 0.1406 0.2514 0.3032
0.5420 0.5933 0.6079 0.6249 0.6330 0.7139
0.7268 0.7383 0.8364 0.8649 0.9593 0.9887
1.1406 1.1943 1.3034 1.6044 1.6058 1.6183
1.6475 1.7931 1.9973 2.1577 2.2426 2.4332
2.7127 2.9333 5.5295 5.7361 8.9635 12.8512
15.0123 18.7880 24.0357 87.1828
```

接下来分析两点：`qsort()`的用法和`mycomp()`的定义。

**1．qsort() 的用法**  
`qsort()`函数排序数组的数据对象。该函数的ANSI原型如下：  
`void qsort (void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));`

第1个参数值指向待排序数组首元素的指针。在该程序中，实际参数是`double`类型的数组名`vals`，因此指针指向该数组的首元素。根据该函数的原型，参数`vals`会被强制转换成指向`void`的指针。由于ANSI C允许把指向任何数据类型的指针强制转换成指向`void`的指针，所以`qsort()`的第1个实际参数可以引用任何类型的数组。

第2个参数是待排序项的数量。在程序清单16.17中是`NUM`，即数组元素的数量。函数原型把该值转换为`size_t`类型。

第3个参数是数组中每个元素占用的空间大小，本例中为`sizeof(double)`。

最后一个参数是`mycomp`，这里函数名即是函数的地址，该函数用于比较元素。

**2．mycomp() 的定义**  
前面提到过，`qsort()`的原型中规定了比较函数的形式：  
`int (*compar)(const void *, const void *)`

这表明`qsort()`最后一个参数是一个指向函数的指针，该函数返回`int`类型的值且接受两个指向`const void`的指针作为参数。程序中`mycomp()`使用的就是这个原型：  
`int mycomp(const void * p1, const void * p2);`

**注意C和C++中的void***  
记住，函数名作为参数时即是指向该函数的指针。因此，`mycomp`与`compar`原型相匹配。

`qsort()`函数把两个待比较元素的地址传递给比较函数。在该程序中，把待比较的两个`double`类型值的地址赋给`p1`和`p2`。注意，`qsort()`的第1个参数引用整个数组，比较函数中的两个参数引用数组中的两个元素。这里存在一个问题。为了比较指针所指向的值，必须解引用指针。因为值是`double`类型，所以要把指针解引用为`double`类型的值。然而，`qsort()`要求指针指向`void`。要解决这个问题，必须在比较函数的内部声明两个类型正确的指针，并初始化它们分别指向作为参数传入的值：  
`/* 按从小到大的顺序排序值 */ int mycomp(const void * p1, const void * p2) { /* 使用指向double类型的指针访问值 */ const double * a1 = (const double *) p1; const double * a2 = (const double *) p2; if (*a1 < *a2) return -1; else if (*a1 == *a2) return 0; else return 1; }`

简而言之，为了让该方法具有通用性，`qsort()`和比较函数使用了指向`void`的指针。因此，必须把数组中每个元素的大小明确告诉`qsort()`，并且在比较函数的定义中，必须把该函数的指针参数转换为对具体应用而言类型正确的指针。

C和C++对待指向`void`的指针有所不同。在这两种语言中，都可以把任何类型的指针赋给`void`类型的指针。例如，程序清单16.17中，`qsort()`的函数调用中把`double*`指针赋给`void*`指针。但是，C++要求在把`void*`指针赋给任何类型的指针时必须进行强制类型转换。而C没有这样的要求。例如，程序清单16.17中的`mycomp()`函数，就使用了这样的强制类型转换：  
`const double * a1 = (const double *) p1;`

这种强制类型转换，在C中是可选的，但在C++中是必须的。因为两种语言都使用强制类型转换，所以遵循C++的要求也无不妥。将来如果要把该程序转成C++，就不必更改这部分的代码。

下面再来看一个比较函数的例子。假设有下面的声明：  
`struct names { char first[40]; char last[40]; }; struct names staff[100];`  
如何调用`qsort()`？模仿程序清单16.17中`qsort()`的函数调用，应该是这样：  
`qsort(staff, 100, sizeof(struct names), comp);`

这里`comp`是比较函数的函数名。那么，应如何编写这个函数？假设要先按姓排序，如果同姓再按名排序，可以这样编写该函数：  
这是一个 `qsort` 比较函数的示例，用于对 `struct names` 类型的数组进行排序。它首先使用 `strcmp` 比较姓氏，如果姓氏相同，则继续比较名字。

text

```
#include <string.h>
int comp(const void * p1, const void * p2) /* 该函数的形式必须是这样
*/
{
/* 得到正确类型的指针 */
const struct names *ps1 = (const struct names *) p1;
const struct names *ps2 = (const struct names *) p2;
int res;
res = strcmp(ps1->last, ps2->last); /* 比较姓 */
if (res != 0)
return res;
else /* 如果同姓，则比较名 */
return strcmp(ps1->first, ps2->first);
}
```

该函数使用`strcmp()`函数进行比较。`strcmp()`的返回值与比较函数的要求相匹配。注意，通过指针访问结构成员时必须使用`->`运算符。

### 16.12　断言库

`assert.h`头文件支持的断言库是一个用于辅助调试程序的小型库。它由`assert()`宏组成，接受一个整型表达式作为参数。如果表达式求值为假（非零），`assert()`宏就在标准错误流（`stderr`）中写入一条错误信息，并调用`abort()`函数终止程序（`abort()`函数的原型在`stdlib.h`头文件中）。`assert()`宏是为了标识出程序中某些条件为真的关键位置，如果其中的一个具体条件为假，就用`assert()`语句终止程序。通常，`assert()`的参数是一个条件表达式或逻辑表达式。如果`assert()`中止了程序，它首先会显示失败的测试、包含测试的文件名和行号。

#### 16.12.1　assert 的用法

程序清单16.18演示了一个使用assert 的小程序。在求平方根之前，该程序断言z 是否大于或等于0 。程序还错误地减去一个值而不是加上一个值，故意让z 得到不合适的值。

#### assert.c 程序

该程序使用 `assert()` 宏来验证一个条件（`z >= 0`）在运行时是否为真，然后再执行 `sqrt(z)` 操作。程序中故意引入了一个逻辑错误，以便在特定输入下触发断言失败。

text

```
/* assert.c -- 使用 assert() */
#include <stdio.h>
#include <math.h>
#include <assert.h>
int main()
{
double x, y, z;
puts("Enter a pair of numbers (0 0 to quit): ");
while (scanf("%lf%lf", &x, &y) == 2
&& (x != 0 || y != 0))
{
z = x * x - y * y; /* 应该用 + */
assert(z >= 0);
printf("answer is %f\n", sqrt(z));
puts("Next pair of numbers: ");
}
puts("Done");
return 0;
}
```

下面是该程序的运行示例：  
这是 `assert.c` 程序的示例输出。当输入导致断言条件为真时，程序正常运行。当输入 `3 5` 导致 `z` 为负数时，断言失败，程序终止并打印出详细的错误信息。

text

```
Enter a pair of numbers (0 0 to quit):
4 3
answer is 2.645751
Next pair of numbers:
5 3
answer is 4.000000
Next pair of numbers:
3 5
Assertion failed: (z >= 0), function main, file /Users/assert.c,
line 14.
```

具体的错误提示因编译器而异。让人困惑的是，这条消息可能不是指明`z >= 0`，而是指明没有满足`z >= 0`的条件。

用`if`语句也能完成类似的任务：  
这段代码展示了如何使用 `if` 语句和 `abort()` 函数来手动实现与 `assert` 类似的功能，但这种方法不会自动报告文件名和行号。

text

```
if (z < 0)
{
puts("z less than 0");
abort();
}
```

但是，使用`assert()`有几个好处：它不仅能自动标识文件和出问题的行号，还有一种无需更改代码就能开启或关闭`assert()`的机制。如果认为已经排除了程序的bug，就可以把下面的宏定义写在包含`assert.h`的位置前面：  
`#define NDEBUG`  
并重新编译程序，这样编译器就会禁用文件中的所有`assert()`语句。如果程序又出现问题，可以移除这条`#define`指令（或者把它注释掉），然后重新编译程序，这样就重新启用了`assert()`语句。

#### 16.12.2　_Static_assert （C11）

`assert()`表达式是在运行时进行检查。C11新增了一个特性：`_Static_assert`声明，可以在编译时检查`assert()`表达式。因此，`assert()`可以导致正在运行的程序中止，而`_Static_assert()`可以导致程序无法通过编译。

`_Static_assert()`接受两个参数。第1个参数是整型常量表达式，第2个参数是一个字符串。如果第1个表达式求值为0（或`_False`），编译器会显示字符串，而且不编译该程序。看看程序清单16.19的小程序，然后查看`assert()`和`_Static_assert()`的区别。

#### statasrt.c 程序

该程序使用 C11 的 `_Static_assert` 在编译时检查一个条件。它断言 `char` 类型的位数是16，这个断言在大多数现代系统上都会失败，从而导致编译错误。

text

```
// statasrt.c
#include <stdio.h>
#include <limits.h>
_Static_assert(CHAR_BIT == 16, "16-bit char falsely assumed");
int main(void)
{
puts("char is 16 bits.");
return 0;
}
```

下面是在命令行编译的示例：  
这是编译 `statasrt.c` 文件时的编译器输出。由于静态断言失败，编译过程被中止，并显示了 `_Static_assert` 中指定的错误信息。

text

```
$ clang statasrt.c
statasrt.c:4:1: error: static_assert failed "16-bit char falsely
assumed"
_Static_assert(CHAR_BIT == 16, "16-bit char falsely assumed");
^ ～～～～～～～～～～～～～～
1 error generated.
$
```

根据语法，`_Static_assert()`被视为声明。因此，它可以出现在函数中，或者在这种情况下出现在函数的外部。

`_Static_assert`要求它的第1个参数是整型常量表达式，这保证了能在编译期求值（`sizeof`表达式被视为整型常量）。不能用程序清单16.18中的`assert`代替`_Static_assert`，因为`assert`中作为测试表达式的z > 0 不是常量表达式，要到程序运行时才求值。当然，可以在程序清单16.19的`main()`函数中使用`assert(CHAR_BIT == 16)`，但这会在编译和运行程序后才生成一条错误信息，很没效率。

### 16.13　string.h 库中的memcpy() 和 memmove()

不能把一个数组赋给另一个数组，所以要通过循环把数组中的每个元素赋给另一个数组相应的元素。有一个例外的情况是：使用`strcpy()`和`strncpy()`函数来处理字符数组。`memcpy()`和`memmove()`函数提供类似的方法处理任意类型的数组。下面是这两个函数的原型：  
`void *memcpy(void * restrict s1, const void * restrict s2, size_t n);`  
`void *memmove(void *s1, const void *s2, size_t n);`

这两个函数都从`s2`指向的位置拷贝`n`字节到`s1`指向的位置，而且都返回`s1`的值。所不同的是，`memcpy()`的参数带关键字`restrict`，即`memcpy()`假设两个内存区域之间没有重叠；而`memmove()`不作这样的假设，所以拷贝过程类似于先把所有字节拷贝到一个临时缓冲区，然后再拷贝到最终目的地。如果使用`memcpy()`时，两区域出现重叠会怎样？其行为是未定义的，这意味着该函数可能正常工作，也可能失败。编译器不会在本不该使用`memcpy()`时禁止你使用，作为程序员，在使用该函数时有责任确保两个区域不重叠。

由于这两个函数设计用于处理任何数据类型，所有它们的参数都是两个指向`void`的指针。C允许把任何类型的指针赋给`void *`类型的指针。如此宽容导致函数无法知道待拷贝数据的类型。因此，这两个函数使用第3个参数指明待拷贝的字节数。注意，对数组而言，字节数一般与元素个数不同。如果要拷贝数组中10个`double`类型的元素，要使用`10*sizeof(double)`，而不是10。

程序清单16.20中的程序使用了这两个函数。该程序假设`double`类型是`int`类型的两倍大小。另外，该程序还使用了C11的`_Static_assert`特性测试断言。

#### mems.c 程序

该程序演示了 `memcpy()` 和 `memmove()` 的用法。它展示了如何进行标准的数组复制，如何使用 `memmove()` 处理重叠的内存区域，以及如何使用 `memcpy()` 在不同类型（`double` 到 `int`）的数组间进行原始字节复制。

text

```
// mems.c -- 使用 memcpy() 和 memmove()
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define SIZE 10
void show_array(const int ar [], int n);
// 如果编译器不支持C11的_Static_assert，可以注释掉下面这行
_Static_assert(sizeof(double) == 2 * sizeof(int), "double not
twice int size");
int main()
{
int values[SIZE] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int target[SIZE];
double curious[SIZE / 2] = { 2.0, 2.0e5, 2.0e10, 2.0e20,
5.0e30 };
puts("memcpy() used:");
puts("values (original data): ");
show_array(values, SIZE);
memcpy(target, values, SIZE * sizeof(int));
puts("target (copy of values):");
show_array(target, SIZE);
puts("\nUsing memmove() with overlapping ranges:");
memmove(values + 2, values, 5 * sizeof(int));
puts("values -- elements 0-4 copied to 2-6:");
show_array(values, SIZE);
puts("\nUsing memcpy() to copy double to int:");
memcpy(target, curious, (SIZE / 2) * sizeof(double));
puts("target -- 5 doubles into 10 int positions:");
show_array(target, SIZE / 2);
show_array(target + 5, SIZE / 2);
return 0;
}
void show_array(const int ar [], int n)
{
int i;
for (i = 0; i < n; i++)
printf("%d ", ar[i]);
putchar('\n');
}
```

下面是该程序的输出：  
这是 `mems.c` 程序的输出结果。它清晰地展示了 `memcpy` 的基本复制功能，`memmove` 在处理重叠内存时的正确行为，以及 `memcpy` 在不同类型间复制时如何按字节解释数据，导致数值发生变化。

text

```
memcpy() used:
values (original data):
1 2 3 4 5 6 7 8 9 10
target (copy of values):
1 2 3 4 5 6 7 8 9 10
Using memmove() with overlapping ranges:
values -- elements 0-4 copied to 2-6:
1 2 1 2 3 4 5 8 9 10
Using memcpy() to copy double to int:
target -- 5 doubles into 10 int positions:
0 1073741824 0 1091070464 536870912
1108516959 2025163840 1143320349 -2012696540 1179618799
```

程序中最后一次调用`memcpy()`从`double`类型数组中把数据拷贝到`int`类型数组中，这演示了`memcpy()`函数不知道也不关心数据的类型，它只负责从一个位置把一些字节拷贝到另一个位置（例如，从结构中拷贝数据到字符数组中）。而且，拷贝过程中也不会进行数据转换。如果用循环对数组中的每个元素赋值，`double`类型的值会在赋值过程被转换为`int`类型的值。这种情况下，按原样拷贝字节，然后程序把这些位组合解释成`int`类型。