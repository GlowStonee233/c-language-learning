头文件
`#include<stdio.h>`标准输入输出函数
printf函数的用法
`printf("I am %d years old", year);`,其中%d为占位符，year将值输入到%d中
注释
单行
//这是一个注释
多行
`/*这是一个注释`
`这是一个注释*/`
注意:C语言必须要给变量赋一个值，并指定类型，否则无法使用，这与python可以直接使用变量不同
C程序转化为可执行文件的步骤
![](附件/Snipaste_2025-09-22_18-57-26.png)
名词解释：
库代码：调用库的代码和库的函数
启动代码：程序和操作系统之间的接口，借助操作系统运行程序
目标代码：储存编译器翻译的源代码
链接器：将库代码，启动代码，目标代码转化为可执行程序

C语言编译的顺序与执行顺序不同,编译是从上到下,执行是从main()开始

定义函数与调用
例子
```c
#include <stdio.h>
void butler(void); /* ANSI/ISO C函数原型 */
int main(void)
{
printf("I will summon the butler function.\n");
butler();
printf("Yes. Bring me some tea and writeable DVDs.\n");
return 0;
}
void butler(void) /* 函数定义开始 */
{
printf("You rang, sir?\n");
}
```
解释:
butler() 函数原型中的第1个void 表明，butler() 函数没有返回值（通常，被调函数会向主调函数返回一个值，但是bulter() 函数没有）。第2个void （butler(void) 中的void ）的意思是 butler() 函数不带参数。因此，当编译器运行至此，会检查 butler() 是否使用得当
缓冲区
在C语言中，缓冲区刷新的条件包括：
1. 缓冲区满时。 
2. 程序正常终止时。 
3. 显式调用`fflush`函数时。 
4. 遇到换行符时（对于行缓冲的流）。 
5. 在进行输入操作前（对于标准输出流）。
对于输入缓冲区，刷新通常发生在缓冲区为空且需要更多数据时，或者用户按下回车键时（对于行缓冲输入）。
# 原码与补码与反码
考虑有限位的带符号的二进制数，两个数的加减法直接按照数学规则计算即可。但在计算机中这有所不同，由于存在溢出机制，两个数的加减法所得到的结果是有限的，且构成一个对称的剩余系，根据剩余系的性质可以得出一个有用的结论：可以将减去一个数转化为加上它的“补数”。即：
$$
a-b=a+(n-b)(mod n)，n是计算机计算时使用的编码可表示的所有数字的种数
$$
这步变换的意义是将负数转为正数，而正数加法在不溢出的前提下是完全遵守数学上的加法法则的，计算机计算不会出错。但由于原码中有+0和-0的存在，一旦涉及到正负数相加就有可能产生错误，以上公式就是为了避免这种情况。
由此可以将负数转化为正数，那怎么求一个二进制数的“补数”呢？
以一个8位二进制数为例演示如何求我们定义的“补数"。
示例：
以减$01011011$为例，这是一个正数，数值上等于$1011011$，他的模是
$$
1+2^1+2^2+……+2^6+1=2^7=(10000000)_2
$$
因此可以得出它的补数就是
$$(10000000)_2-(1011011)_2=(1111111)_2+(1)_2-(1011011)_2=(0000001)_2+(0100100)_2=(0100101)_2$$
而-01011011的补码是00100101，事实上，如果我们将数码的首位视为正常的数字，而不是一种符号。那么原码和补码互为补数。
以上的公式说明，将原码替换为补码运算的结果不变，而在不发生溢出的的前提下，直接用原码计算两个正数的加法是不会出错的。这样，不好处理的负数转化为了较好处理的正数。
而反码则是历史上的一个过程，现在已经不在使用，定义补码实际上也不需要使用反码，不过可以将反码视作计算补码的一个中间量。

