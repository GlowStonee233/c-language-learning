如何组织程序？C的设计思想是，把函数用作构件块。我们已经用过C标准库的函数，如printf() 、scanf() 、getchar() 、 putchar() 和strlen() 。现在要进一步学习如何创建自己的函数。
# 函数定义
函数 （function ）是完成特定任务的独立程序代码单元。语法规则定义了函数的结构和使用方式。虽然C中的函数和其他语言中的函数、子程序、过程作用相同，但是细节上略有不同。一些函数执行某些动作，如printf() 把数据打印到屏幕上；一些函数找出一个值供程序使用，如strlen() 把指定字符串的长度返回给程序。一般而言，函数可以同时具备以上两种功能。
为什么要使用函数？首先，使用函数可以省去编写重复代码的苦差。如果程序要多次完成某项任务，那么只需编写一个合适的函数， 就可以在需要时使用这个函数，或者在不同的程序中使用该函数，就像许多程序中使用putchar() 一样。其次，即使程序只完成某项任务一次，也值得使用函数。因为函数让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改、完善。
许多程序员喜欢把函数看作是根据传入信息（输入）及其生成的值或响应的动作（输出）来定义的“黑盒”。如果不是自己编写函数， 根本不用关心黑盒的内部行为。以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上。因此，在动手编写代码之前，仔细考虑一下函数应该完成什么任务，以及函数和程序整体的关系。
# 创建并使用简单函数
使用的函数标识符：函数原型 （function prototype ）告诉编译器函数starbar() 的类型；函数调用 （function call ）表明在此处执行函数；函数定义 （function definition ）明确地指定了函数要做什么。
函数和变量一样，有多种类型。任何程序在使用函数之前都要声明该函数的类型。示例：
```c
void starbar(void);
```
圆括号表明starbar 是一个函数名。第1个void 是函数类型， void 类型表明函数没有返回值。第2个void （在圆括号中）表明该函数不带参数。分号表明这是在声明函数，不是定义函数。
对于不识别ANSI C风格原型的编译器，只需声明函数的类型，如下所示：
```c
void starbar();
```
一般而言，函数原型指明了函数的返回值类型和函数接受的参数类型。这些信息称为该函数的签名 （signature ）。对于 starbar() 函数而言，其签名是该函数没有返回值，没有参数。
程序把starbar() 原型置于main() 的前面。当然，也可以放在main() 里面的声明变量处。放在哪个位置都可以。
在main() 中，执行到下面的语句时调用了starbar() 函数：
```
starbar();
```
当计算机执行到 starbar(); 语句时，会找到该函数的定义并执行其中的内容。执行完starbar() 中的代码后，计算机返回主调函数 （calling function ）继续执行下一行，更确切地说，编译器把C程序翻译成执行以上操作的机器语言代码。
```c
void starbar(void) /* 定义函数 */
{
int count;
for (count = 1; count <= WIDTH; count++)
putchar('*');
putchar('\n');
}
```
程序中starbar() 和main() 的定义形式相同。首先函数头包括函数类型、函数名和圆括号，接着是左花括号、变量声明、函数表达式语句，最后以右花括号结束。注意，函数头中的starbar() 后面没有分号，告诉编译器这是定义 starbar() ，而不是调用函数或声明函数原型。
程序把starbar() 和main() 放在一个文件中。当然，也可以把它们分别放在两个文件中。把函数都放在一个文件中的单文件形式比较容易编译，而使用多个文件方便在不同的程序中使用同一个函数。如果把函数放在一个单独的文件中，要把#define 和 、#include 指令也放入该文件。
现在，先把所有的函数都放在一个文件中。main() 的右花括号告诉编译器该函数结束的位置，后面的starbar() 函数头告诉编译器starbar() 是一个函数。
starbar() 函数中的变量count 是局部变量 （local variable ），意思是该变量只属于starbar() 函数。可以在程序中的其他地方（包括main() 中）使用count ，这不会引起名称冲突， 它们是同名的不同变量。

# 定义带形式参数的函数
函数定义从下面的ANSI C风格的函数头开始：
```c
void show_n_char(char ch, int num)
```
该行告知编译器show_n_char() 使用两个参数ch 和num ，ch 是char 类型，num 是int 类型。这两个变量被称为形式参数 （formal argument ，但是最近的标准推荐使用formal parameter ），简称形参。和定义在函数中变量一样，形式参数也是局部变量， 属该函数私有。这意味着在其他函数中使用同名变量不会引起名称冲突。每次调用函数，就会给这些变量赋值。
注意，ANSI C要求在每个变量前都声明其类型。也就是说，不能像普通变量声明那样使用同一类型的变量列表：
```c
void dibs(int x, y, z) /* 无效的函数头 */
void dubs(int x, int y, int z) /* 有效的函数头 */
```
ANSI C也接受ANSI C之前的形式，但是将其视为废弃不用的形式：
```c
void show_n_char(ch, num)
char ch;
int num;
```
这里，圆括号中只有参数名列表，而参数的类型在后面声明。注意，普通的局部变量在左花括号之后声明，而上面的变量在函数左花括号之前声明。如果变量是同一类型，这种形式可以用逗号分隔变量名列表，如下所示：
```c
void dibs(x, y, z)
int x, y, z; /* 有效 */
```
当前的标准正逐渐淘汰ANSI之前的形式。读者应对此有所了解， 以便能看懂以前编写的程序，但是自己编写程序时应使用现在的标准形式（C99和C11标准继续警告这些过时的用法即将被淘汰）。
## 声明带形式参数函数的原型
在使用函数之前，要用ANSI C形式声明函数原型：
```c
void show_n_char(char ch, int num);
```

当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型。根据个人喜好，你也可以省略变量名：
```c
void show_n_char(char, int);
```
在原型中使用变量名并没有实际创建变量，char 仅代表了一个 char 类型的变量，以此类推。
再次提醒读者注意，ANSI C也接受过去的声明函数形式，即圆括号内没有参数列表：
```c
void show_n_char();
```
这种形式最终会从标准中剔除。即使没有被剔除，现在函数原型的设计也更有优势（稍后会介绍）。了解这种形式的写法是为了以后读得懂以前写的代码。
## 调用带实际参数的函数
在函数调用中，实际参数 （actual argument ，简称实参）提供了ch 和num 的值。
简而言之，形式参数是被调函数 （called function ）中的变量，实际参数是主调函数 （calling function ）赋给被调函数的具体值。
实际参数可以是常量、变量，或甚至是更复杂的表达式。无论实际参数是何种形式都要被求值，然后该值被拷贝给被调函数相应的形式参数。
实际参数是具体的值，该值要被赋给作为形式参数的变量。因为被调函数使用的值是从主调函数中拷贝而来，所以无论被调函数对拷贝数据进行什么操作，都不会影响主调函数中的原始数据。
## 黑盒视角
从黑盒的视角看show_n_char() ，待显示的字符和显示的次数是输入。执行后的结果是打印指定数量的字符。输入以参数的形式被传递给函数。这些信息清楚地表明了如何在main()中使用该函数。而且，这也可以作为编写该函数的设计说明。黑盒方法的核心部分是：ch 、num 和count 都是 show_n_char() 私有的局部变量。如果在main() 中使用同名变量，那么它们相互独立，互不影响。也就是说，如果main() 有一个 count 变量，那么改变它的值不会改变show_n_char() 中的count ，反之亦然。黑盒里发生了什么对主调函数是不可见的。
## 使用return 从函数中返回值
前面介绍了如何把信息从主调函数传递给被调函数。反过来，函数的返回值可以把信息从被调函数传回主调函数。为进一步说明，我们将创建一个返回两个参数中较小值的函数。由于函数被设计用来处理int 类型的值，所以被命名为imin() 。另外，还要创建一个简单的main() ，用于检查imin() 是否正常工作。这种被设计用于测试函数的程序有时被称为驱动程序 （driver ），该驱动程序调用一个函数。如果函数成功通过了测试，就可以安装在一个更重要的程序中使用。以下是代码：
```c
/* lesser.c -- 找出两个整数中较小的一个 */
#include <stdio.h>
int imin(int, int);
int main(void)
{
int evil1, evil2;
printf("Enter a pair of integers (q to quit):\n");
while (scanf("%d %d", &evil1, &evil2) == 2)
{
printf("The lesser of %d and %d is %d.\n",
evil1, evil2, imin(evil1, evil2));
printf("Enter a pair of integers (q to quit):\n");
}
printf("Bye.\n");
return 0;
}
int imin(int n, int m)
{
int min;
if (n < m)
min = n;
else
min = m;
return min;
}
```
返回值不仅可以赋给变量，也可以被用作表达式的一部分。返回值不一定是变量的值，也可以是任意表达式的值。
如果函数返回值的类型与函数声明的类型不匹配，实际得到的返回值相当于把函数中指定的返回值赋给与函数类型相同的变量所得到的值。
使用return 语句的另一个作用是，终止函数并把控制返回给主调函数的下一条语句。因此，可以这样编写imin() ：
```c
/*返回最小值的函数，第3个版本*/
imin(int n,int m)
{
if (n < m)
return n;
else
return m;
}
```
许多C程序员都认为只在函数末尾使用一次return 语句比较好， 因为这样做更方便浏览程序的人理解函数的控制流。但是，在函数中使用多个return 语句也没有错。无论如何，对用户而言，这3个版本的函数用起来都一样，因为所有的输入和输出都完全相同，不同的是函数内部的实现细节。下面的版本也没问题：
```c
/*返回最小值的函数，第4个版本*/
imin(int n, int m)
{
if (n < m)
return n;
else
return m;
printf("Professor Fleppard is like totally a fopdoodle.\n");
}
```
return 语句导致printf() 语句永远不会被执行。如果 Fleppard教授在自己的程序中使用这个版本的函数，可能永远不知道编写这个函数的学生对他的看法。
另外，还可以这样使用return ：
```
return;
```
这条语句会导致终止函数，并把控制返回给主调函数。因为 return 后面没有任何表达式，所以没有返回值，只有在void 函数中才会用到这种形式。
# 函数类型
声明函数时必须声明函数的类型。带返回值的函数类型应该与其返回值类型相同，而没有返回值的函数应声明为void 类型。如果没有声明函数的类型，旧版本的C编译器会假定函数的类型是int 。这一惯例源于C的早期，那时的函数绝大多数都是int 类型。然而，C99 标准不再支持int 类型函数的这种假定设置。
类型声明是函数定义的一部分。要记住，函数类型指的是返回值的类型，不是函数参数的类型。
要正确地使用函数，程序在第1次使用函数之前必须知道函数的类型。方法之一是，把完整的函数定义放在第1次调用函数的前面。然而，这种方法增加了程序的阅读难度。而且，要使用的函数可能在 C库或其他文件中。因此，通常的做法是提前声明函数，把函数的信息告知编译器。
我们把函数的前置声明放在主调函数外面。当然，也可以放在主调函数里面。注意在这两种情况中，函数原型都声明在使用函数之前。
ANSI C标准库中，函数被分成多个系列，每一系列都有各自的头文件。这些头文件中除了其他内容，还包含了本系列所有函数的声明。例如，stdio.h 头文件包含了标准I/O库函数（如，printf() 和scanf() ）的声明。math.h 头文件包含了各种数学函数的声明。
不要混淆函数的声明和定义。函数声明告知编译器函数的类型，而函数定义则提供实际的代码。在程序中包含 math.h 头文件告知编译器：sqrt() 返回double 类型，但是 sqrt() 函数的代码在另一个库函数的文件中。
## ANSI C函数原型
在ANSI C标准之前，声明函数的方案有缺陷，因为只需要声明函数的类型，不用声明任何参数。下面我们看一下使用旧式的函数声明会导致什么问题。
下面是ANSI之前的函数声明，告知编译器imin() 返回int 类型的值：
```c
int imin();
```
然而，以上函数声明并未给出imin() 函数的参数个数和类型。因此，如果调用imin() 时使用的参数个数不对或类型不匹配，编译器根本不会察觉出来。
### 问题所在
我们看看与imax() 函数相关的一些示例，该函数与imin() 函数关系密切。我们演示一个程序，用过去声明函数的方式声明了imax() 函数，然后错误地使用该函数。
```c
/* misuse.c -- 错误地使用函数 */
#include <stdio.h>
int imax(); /* 旧式函数声明 */
int main(void)
{
printf("The maximum of %d and %d is %d.\n",3, 5, imax(3));
printf("The maximum of %d and %d is %d.\n",3, 5, imax(3.0,
5.0));
return 0;
}
int imax(n, m)
{
int n, m;
return (n > m ? n : m);
}
```
第1次调用printf() 时省略了imax() 的一个参数，第2次调用 printf() 时用两个浮点参数而不是整数参数。尽管有些问题，但程序可以编译和运行。
下面是使用Xcode 4.6运行的输出示例：
```
The maximum of 3 and 5 is 1606416656.
The maximum of 3 and 5 is 3886.
```
使用gcc 运行该程序，输出的值是1359379472 和1359377160 。这两个编译器都运行正常，之所以输出错误的结果，是因为它们运行的程序没有使用函数原型。
%% visual studio直接报错 %%

到底是哪里出了问题？由于不同系统的内部机制不同，所以出现问题的具体情况也不同。下面介绍的是使用PC和VAX的情况。主调函数把它的参数储存在被称为栈 （stack ）的临时存储区，被调函数从栈中读取这些参数。对于该例，这两个过程并未相互协调。主调函数根据函数调用中的实际参数决定传递的类型，而被调函数根据它的形式参数读取值。因此，函数调用imax(3) 把一个整数放在栈中。当 imax() 函数开始执行时，它从栈中读取两个整数。而实际上栈中只存放了一个待读取的整数，所以读取的第2个值是当时恰好在栈中的其他值。

第2次使用imax() 函数时，它传递的是float 类型的值。这次把两个double 类型的值放在栈中（回忆一下，当float 类型被作为参数传递时会被升级为double 类型）。在我们的系统中，两个 double 类型的值就是两个64位的值，所以128位的数据被放在栈中。当imax() 从栈中读取两个int 类型的值时，它从栈中读取前64 位。在我们的系统中，每个int 类型的变量占用32位。这些数据对应两个整数，其中较大的是3886。
### 解决方案
针对参数不匹配的问题，ANSI C标准要求在函数声明时还要声明变量的类型，即使用函数原型 （function prototype ）来声明函数的返回类型、参数的数量和每个参数的类型。
有了这些信息，编译器可以检查函数调用是否与函数原型匹配。参数的数量是否正确？参数的类型是否匹配？以imax() 为例，如果两个参数都是数字，但是类型不匹配，编译器会把实际参数的类型转换成形式参数的类型。例如，imax(3.0, 5.0) 会被转换成 imax(3, 5) 。
错误和警告的区别是：错误导致无法编译，而警告仍然允许编译。一些编译器在进行类似的类型转换时不会通知用户，因为C标准中对此未作要求。不过，许多编译器都允许用户选择警告级别来控制编译器在描述警告时的详细程度。
## 无参数和未指定参数的函数原型
假设有下面的函数原型：
```c
void print_name();
```
一个支持ANSI C的编译器会假定用户没有用函数原型来声明函数，它将不会检查参数。为了表明函数确实没有参数，应该在圆括号中使用void 关键字：
```c
void print_name(void);
```
支持ANSI C的编译器解释为print_name() 不接受任何参数。然后在调用该函数时，编译器会检查以确保没有使用参数。
一些函数接受（如，printf() 和scanf() ）许多参数。例如对于printf() ，第1个参数是字符串，但是其余参数的类型和数量都不固定。对于这种情况，ANSI C允许使用部分原型。例如，对于 printf() 可以使用下面的原型：
```
int printf(const char *, ...);
```
这种原型表明，第1个参数是一个字符串，可能还有其他未指定的参数。C库通过stdarg.h 头文件提供了一个定义这类（形参数量不固定的）函数的标准方法。
## 函数原型的优点
函数原型是C语言的一个强有力的工具，它让编译器捕获在使用函数时可能出现的许多错误或疏漏。如果编译器没有发现这些问题， 就很难觉察出来。是否必须使用函数原型？不一定。你也可以使用旧式的函数声明（即不用声明任何形参），但是这样做的弊大于利。
有一种方法可以省略函数原型却保留函数原型的优点。首先要明白，之所以使用函数原型，是为了让编译器在第1次执行到该函数之前就知道如何使用它。因此，把整个函数定义放在第1次调用该函数之前，也有相同的效果。此时，函数定义也相当于函数原型。对于较小的函数，这种用法很普遍：
```c
// 下面这行代码既是函数定义，也是函数原型
int imax(int a, int b) { return a > b ? a : b; }
int main()
{
int x, z;
...
z = imax(x, 50);
...
}
```
# 递归
C允许函数调用它自己，这种调用过程称为递归 （recursion ）。递归有时难以捉摸，有时却很方便实用。结束递归是使用递归的难点，因为如果递归代码中没有终止递归的条件测试部分，一个调用自己的函数会无限递归。
可以使用循环的地方通常都可以使用递归。有时用循环解决问题比较好，但有时用递归更好。递归方案更简洁，但效率却没有循环高。
## 演示递归
我们通过一个程序示例，来学习什么是递归。程序中的 main() 函数调用up_and_down() 函数，这次调用称为“第1级递归”。然后up_and_down() 调用自己，这次调用称为“第2级递归”。接着第2级递归调用第3级递归，以此类推。该程序示例共有4级递归。为了进一步深入研究递归时发生了什么，程序不仅显示了变量n 的值，还显示了储存n 的内存地址&n（用%p） 。
```c
/* recur.c -- 递归演示 */
#include <stdio.h>
void up_and_down(int);
int main(void)
{
up_and_down(1);
return 0;
}
void up_and_down(int n)
{
printf("Level %d: n location %p\n", n, &n); // #1
if (n < 4)
up_and_down(n + 1);
printf("LEVEL %d: n location %p\n", n, &n); // #2
}
```
输出：
```
Level 1: n location 0x0012ff48
Level 2: n location 0x0012ff3c
Level 3: n location 0x0012ff30
Level 4: n location 0x0012ff24
LEVEL 4: n location 0x0012ff24
LEVEL 3: n location 0x0012ff30
LEVEL 2: n location 0x0012ff3c
LEVEL 1: n location 0x0012ff48
```
**注意：如果将n+1改为n++，由于后缀形式会先使用变量（给函数传递参数），再递增，将会导致程序一直执行up_and_dowm(1),从而导致栈溢出，正确做法是改为++n**

我们来仔细分析程序中的递归是如何工作的。首先，main() 调用了带参数1 的up_and_down() 函数，执行结果是 up_and_down() 中的形式参数n 的值是1 ，所以打印语句#1 打印 Level 1 。然后，由于n 小于4 ，up_and_down() （第1级）调用实际参数为n + 1 （或2 ）的up_and_down() （第2级）。于是第2 级调用中的n 的值是2 ，打印语句#1 打印Level 2 。与此类似，下面两次调用打印的分别是Level 3 和Level 4 。

当执行到第4级时，n 的值是4 ，所以if 测试条件为假。 up_and_down() 函数不再调用自己。第4 级调用接着执行打印语句 #2 ，即打印LEVEL 4 ，因为n 的值是4 。此时，第4级调用结束，控制被传回它的主调函数（即第3级调用）。在第3级调用中，执行的最后一条语句是调用if 语句中的第4级调用。被调函数（第4级调用） 把控制返回在这个位置，因此，第3级调用继续执行后面的代码，打印语句#2 打印LEVEL 3 。然后第3级调用结束，控制被传回第2级调用，接着打印LEVEL 2 ，以此类推。

注意，每级递归的变量n 都属于本级递归私有。这从程序输出的地址值可以看出（当然，不同的系统表示的地址格式不同，这里关键要注意，Level 1 和LEVEL 1 的地址相同，Level 2 和LEVEL 2 的地址相同，等等）。

如果觉得不好理解，可以假设有一条函数调用链——fun1() 调用fun2() 、fun2() 调用fun3() 、fun3() 调用fun4() 。当 fun4() 结束时，控制传回fun3() ；当fun3() 结束时，控制传回 fun2() ；当fun2() 结束时，控制传回fun1() 。递归的情况与此类似，只不过fun1() 、fun2() 、fun3() 和fun4() 都是相同的函数。
## 递归的基本原理
第1，每级函数调用都有自己的变量。也就是说，第1级的n 和第 2级的n 不同，所以程序创建了4个单独的变量，每个变量名都是n ， 但是它们的值各不相同。当程序最终返回up_and_down() 的第1级调用时，最初的n 仍然是它的初值1 。

第2，每次函数调用都会返回一次。当函数执行完毕后，控制权将被传回上一级递归。程序必须按顺序逐级返回递归，从某级 up_and_down() 返回上一级的up_and_down() ，不能跳级回到 main() 中的第1级调用。

第3，递归函数中位于递归调用之前的语句，均按被调函数的顺序执行。例如，演示中的打印语句#1 位于递归调用之前，它按照递归的顺序：第1级、第2级、第3级和第4级，被执行了4次。

第4，递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。例如，打印语句#2 位于递归调用之后，其执行的顺序是第4级、第3级、第2级、第1级。

第5，虽然每级递归都有自己的变量，但是并没有拷贝函数的代码。程序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代码。除了为每次递归调用创建变量外，递归调用非常类似于一个循环语句。实际上，递归有时可用循环来代替，循环有时也能用递归来代替。

最后，递归函数必须包含能让递归调用停止的语句。通常，递归函数都使用if 或其他等价的测试条件在函数形参等于某特定值时终止递归。为此，每次递归调用的形参都要使用不同的值。

## 尾递归
最简单的递归形式是把递归调用置于函数的末尾，即正好在 return 语句之前。这种形式的递归被称为尾递归 （tail recursion ），因为递归调用在函数的末尾。尾递归是最简单的递归形式，因为它相当于循环。
下面是一个计算阶乘的程序。
```c
// factor.c -- 使用循环和递归计算阶乘
#include <stdio.h>
long fact(int n);
long rfact(int n);
int main(void)
{
int num;
printf("This program calculates factorials.\n");
printf("Enter a value in the range 0-12 (q to quit):\n");
while (scanf("%d", &num) == 1)
{
if (num < 0)
printf("No negative numbers, please.\n");
else if (num > 12)
printf("Keep input under 13.\n");
else
{
printf("loop: %d factorial = %ld\n",
num, fact(num));
printf("recursion: %d factorial = %ld\n",
num, rfact(num));
}
printf("Enter a value in the range 0-12 (q to quit):\n");
}
printf("Bye.\n");
return 0;
}
long fact(int n) // 使用循环的函数
{
long ans;
for (ans = 1; n > 1; n--)
ans *= n;
return ans;
}
long rfact(int n) // 使用递归的函数
{
long ans;
if (n > 0)
ans = n * rfact(n - 1);
else
ans = 1;
return ans;
}
```
使用循环的函数把ans 初始化为1 ，然后把ans 与从n~2 的所有递减整数相乘。根据阶乘的公式，还应该乘以1 ，但是这并不会改变结果。
现在考虑使用递归的函数。该函数的关键是n! = n ×(n-1)! 。可以这样做是因为(n-1)! 是n-1~1 的所有正整数的乘积。因此， n 乘以n-1 的阶乘就得到n 的阶乘。阶乘的这一特性很适合使用递归。如果调用函数rfact() ，rfact(n) 是n*rfact(n-1) 。因此，通过调用rfact(n-1) 来计算rfact(n) ，这相当于累乘法。
$$
\begin{aligned}令b_{n}=\dfrac{a_{n}}{a_{n-1}}则a_{n}=b_{n}b_{n-1}\ldots b_{1}，其中b_{1}=a_{1}\end{aligned}
$$
既然用递归和循环来计算都没问题，那么到底应该使用哪一个？ 一般而言，选择循环比较好。首先，每次递归都会创建一组变量，所以递归使用的内存更多，而且每次递归调用都会把创建的一组新变量放在栈中。递归调用的数量受限于内存空间。其次，由于每次函数调用要花费一定的时间，所以递归的执行速度较慢。
## 递归和倒序计算
下面是一个计算二进制表示的程序。
```c
/* binary.c -- 以二进制形式打印制整数 */
#include <stdio.h>
void to_binary(unsigned long n);
int main(void)
{
	unsigned long number;
	printf("Enter an integer (q to quit):\n");
	while (scanf_s("%lu", &number) == 1)
	{
		printf("Binary equivalent: ");
		to_binary(number);
		putchar('\n');
		printf("Enter an integer (q to quit):\n");
	}
	printf("Done.\n");
	return 0;
}
void to_binary(unsigned long n)
{
	int r = n % 2;
	if (n >= 2) 
	{
		to_binary(n / 2);
	}
	putchar(r == 0 ? '0' : '1');
}
```
**计算二进制数的算法:反复对2做带余除法**
在该程序中，如果r 的值是0 ，to_binary() 函数就显示字符'0' ；如果r 的值是1 ，to_binary() 函数则显示字符'1' 。条件表达式r == 0 ? '0' : '1' 用于把数值转换成字符。
不用递归，是否能实现这种用二进制形式表示整数的算法？当然可以。但是由于这种算法要首先计算最后一位二进制数，所以在显示结果之前必须把所有的位数都储存在别处（例如，数组）。
## 递归的优缺点
递归既有优点也有缺点。优点是递归为某些编程问题提供了最简单的解决方案。缺点是一些递归算法会快速消耗计算机的内存资源。另外，递归不方便阅读和维护。
下面是一个说明递归的优缺点的例子。
```c
//计算斐波那契数列
unsigned long Fibonacci(unsigned n)
{
if (n > 2)
return Fibonacci(n-1) + Fibonacci(n-2);
else
return 1;
}
```
这个递归函数只是重述了数学定义的递归。该函数使用了双递归 （double recursion ），即函数每一级递归都要调用本身两次。这暴露了一个问题。
为了说明这个问题，假设调用Fibonacci(40) 。这是第1级递归调用，将创建一个变量n 。然后在该函数中要调用Fibonacci() 两次，在第2级递归中要分别创建两个变量n 。这两次调用中的每次调用又会进行两次调用，因而在第3级递归中要创建4个名为n 的变量。此时总共创建了7个变量。由于每级递归创建的变量都是上一级递归的两倍，所以变量的数量呈指数增长！
该例说明：在程序中使用递归要特别注意，尤其是效率优先的程序。

**所有的C 函数皆平等**
程序中的每个C函数与其他函数都是平等的。每个函数都可以调用其他函数，或被其他函数调用。这点与Pascal和Modula-2中的过程不同，虽然过程可以嵌套在另一个过程中，但是嵌套在不同过程中的过程之间不能相互调用。
main() 函数是否与其他函数不同？是的，main() 的确有点特殊。当main() 与程序中的其他函数放在一起时，最开始执行的是main() 函数中的第1条语句，但是这也是局限之处。main() 也可以被自己或其他函数递归调用——尽管很少这样做。
# 编译多源代码文件的程序
使用多个函数最简单的方法是把它们都放在同一个文件中，然后像编译只有一个函数的文件那样编译该文件即可。其他方法因操作系统而异，下面将举例说明。
## UNIX
假定在UNIX系统中安装了UNIX C编译器cc （最初的cc 已经停用，但是许多UNIX系统都给cc 命令起了一个别名用作其他编译器命令，典型的是gcc 或clang ）。假设file1.c 和file2.c 是两个内含C函数的文件，下面的命令将编译两个文件并生成一个名为a.out 的可执行文件：
```
cc file1.c file2.c
```
另外，还生成两个名为file1.o 和file2.o 的目标文件。如果后来改动了file1.c ，而file2.c 不变，可以使用以下命令编译第 1个文件，并与第2个文件的目标代码合并：
```
cc file1.c file2.o
```
注意，OS X的Terminal工具可以打开UNIX命令行环境，但是必须先下载命令行编译器（GCC和Clang）。
## Linux
假定Linux系统安装了GNU C编译器GCC。假设file1.c 和 file2.c 是两个内含C函数的文件，下面的命令将编译两个文件并生成名为a.out 的可执行文件：
```
gcc file1.c file2.c
```
另外，还生成两个名为file1.o 和file2.o 的目标文件。如果后来改动了file1.c ，而file2.c 不变，可以使用以下命令编译第 1个文件，并与第2个文件的目标代码合并：
```
gcc file1.c file2.o
```
## DOS命令行编译器
绝大多数DOS命令行编译器的工作原理和UNIX的cc 命令类似， 只不过使用不同的名称而已。其中一个区别是，对象文件的扩展名是.obj ，而不是.o 。一些编译器生成的不是目标代码文件，而是汇编语言或其他特殊代码的中间文件。
## Windows和苹果的IDE编译器
Windows和Macintosh系统使用的集成开发环境中的编译器是面向项目的。项目 （project ）描述的是特定程序使用的资源。资源包括源代码文件。这种IDE中的编译器要创建项目来运行单文件程序。对于多文件程序，要使用相应的菜单命令，把源代码文件加入一个项目中。要确保所有的源代码文件都在项目列表中列出。许多IDE都不用在项目列表中列出头文件（即扩展名为.h 的文件），因为项目只管理使用的源代码文件，源代码文件中的#include 指令管理该文件中使用的头文件。但是，Xcode要在项目中添加头文件。
## 使用头文件
如果把main() 放在第1个文件中，把函数定义放在第2个文件中，那么第1个文件仍然要使用函数原型。把函数原型放在头文件中，就不用在每次使用函数文件时都写出函数的原型。C标准库就是这样做的，例如，把I/O函数原型放在stdio.h 中，把数学函数原型放在math.h 中。你也可以这样用自定义的函数文件。

另外，程序中经常用C预处理器定义符号常量。这种定义只储存了那些包含#define 指令的文件。如果把程序的一个函数放进一个独立的文件中，你也可以使用#define 指令访问每个文件。最直接的方法是在每个文件中再次输入指令，但是这个方法既耗时又容易出错。另外，还会有维护的问题：如果修改了#define 定义的值，就必须在每个文件中修改。更好的做法是，把#define 指令放进头文件，然后在每个源文件中使用#include 指令包含该文件即可。

总之，把函数原型和已定义的字符常量放在头文件中是一个良好的编程习惯。
# 查找地址：&运算符
指针 （pointer ）是C语言最重要的（有时也是最复杂的）概念之一，用于储存变量的地址。前面使用的scanf() 函数中就使用地址作为参数。概括地说，如果主调函数不使用return 返回的值，则必须通过地址才能修改主调函数中的值。接下来，我们将介绍带地址参数的函数。首先介绍一元& 运算符的用法。

一元& 运算符给出变量的存储地址。如果pooh 是变量名，那么 &pooh 是变量的地址。可以把地址看作是变量在内存中的位置。假设有下面的语句：
```c
pooh = 24;
```
假设pooh 的存储地址是0B76 （PC 地址通常用十六进制形式表示）。那么，下面的语句：
```c
printf("%d %p\n", pooh, &pooh);
```
将输出如下内容（%p 是输出地址的转换说明）：
```
24 0B76
```
实现不同，%p 表示地址的方式也不同。然而，许多实现都以十六进制显示地址。顺带一提，每个十六进制数对应4位。
## 更改主调函数中的变量
有时需要在一个函数中更改其他函数的变量。例如，普通的排序任务中交换两个变量的值。假设要交换两个变量x 和y 的值。简单的思路是：
```c
x = y;
y = x;
```
这完全不起作用，因为执行到第2行时，x 的原始值已经被y 的原始值替换了。因此，要多写一行代码，储存x 的原始值：
```c
temp = x;
x = y;
y = temp;
```
上面这3行代码便可实现交换值的功能，可以编写成一个函数并构造一个驱动程序来测试。
以下程序演示了这个函数
```c
/* swap1.c -- 第1个版本的交换函数 */
#include <stdio.h>
void interchange(int u, int v); /* 声明函数 */
int main(void)
{
int x = 5, y = 10;
printf("Originally x = %d and y = %d.\n", x, y);
interchange(x, y);
printf("Now x = %d and y = %d.\n", x, y);
return 0;
}
void interchange(int u, int v) /* 定义函数 */
{
int temp;
temp = u;
u = v;
v = temp;
}
```
由于把结果传回main() 时。interchange() 使用的变量并不是 main() 中的变量。因此，交换u 和v 的值对x 和y 的值没有影响，两个变量的值并未交换。
为实现交换的目的，需要把值传递回main（）函数。用return 语句只能把被调函数中的一个值传回主调函数，但是现在要传回两个值。
# 指针简介
从根本上看，指针 （pointer ）是一个值为内存地址的变量（或数据对象）。在C语言中，指针有许多用法。以下将介绍如何把指针作为函数参数使用，以及为何要这样用。
假设一个指针变量名是ptr ，可以编写如下语句：
```c
ptr = &pooh; // 把pooh的地址赋给ptr
```
对于这条语句，我们说ptr “指向”pooh 。ptr 和&pooh 的区别是ptr 是变量，而&pooh 是常量。或者，ptr 是可修改的左值，而 &pooh 是右值。还可以把ptr 指向别处：
```c
ptr = &bah; // 把ptr指向bah，而不是pooh
```
现在ptr 的值是bah 的地址。
要创建指针变量，先要声明指针变量的类型。假设想把ptr 声明为储存int 类型变量地址的指针，就要使用下面介绍的新运算符。
## 间接运算符：*
设已知ptr 指向bah ，如下所示：
```c
ptr = &bah;
```
然后使用间接运算符 *（ indirection operator ）找出储存在bah 中的值，该运算符有时也称为解引用运算符 （dereferencing operator ）。不要把间接运算符和二元乘法运算符（*）混淆，虽然它们使用的符号相同，但语法功能不同。
```c
val = *ptr; // 找出ptr指向的值
```
语句ptr = &bah; 和val = *ptr; 放在一起相当于下面的语句：
```c
val = bah;
```
由此可见，使用地址和间接运算符可以间接完成上面这条语句的功能，这也是“间接运算符”名称的由来。
## 声明指针
声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。另外，程序必须知道储存在指定地址上的数据类型。long 和float 可能占用相同的存储空间，但是它们储存数字却大相径庭。
下面是一些指针的声明示例：
```
int * pi; // pi是指向int类型变量的指针
char * pc; // pc是指向char类型变量的指针
float * pf, * pg; // pf、pg都是指向float类型变量的指针
```
类型说明符表明了指针所指向对象的类型，星号（*）表明声明的变量是一个指针。int * pi; 声明的意思是pi 是一个指针，*pi 是int 类型。
*和指针名之间的空格可有可无。通常，程序员在声明时使用空格，在解引用变量时省略空格。

pc 指向的值（*pc ）是char 类型。pc 本身是什么类型？我们描述它的类型是“指向char 类型的指针”。pc 的值是一个地址，在大部分系统内部，该地址由一个无符号整数表示。但是，不要把指针认为是整数类型。一些处理整数的操作不能用来处理指针，反之亦然。例如，可以把两个整数相乘，但是不能把两个指针相乘。所以，指针实际上是一个新类型，不是整数类型。因此，如前所述，ANSI C专门为指针提供了%p 格式的转换说明。
## 使用指针在函数间通信
以下使用指针对程序进行改造，使其能正常交换值。
```c
/* swap3.c -- 使用指针解决交换函数的问题 */
#include <stdio.h>
void interchange(int * u, int * v);
int main(void)
{
int x = 5, y = 10;
printf("Originally x = %d and y = %d.\n", x, y);
interchange(&x, &y); // 把地址发送给函数
printf("Now x = %d and y = %d.\n", x, y);
return 0;
}
void interchange(int * u, int * v)
{
int temp;
temp = *u; // temp获得 u 所指向对象的值
*u = *v;
*v = temp;
}
```
### 分析
首先看函数调用：
```c
interchange(&x, &y);
```
该函数传递的不是x 和y 的值 ，而是它们的地址。这意味着出现在interchange() 原型和定义中的形式参数u 和v 将把地址作为它们的值。因此，应把它们声明为指针。由于x 和y 是整数，所以u 和v 是指向整数的指针，其声明如下：
```c
void interchange (int * u, int * v)
```
接下来，在函数体中声明了一个交换值时必需的临时变量：
```c
int temp;
```
通过下面的语句把x 的值储存在temp 中：
```c
temp = *u;
```
记住，u 的值是&x ，所以u 指向x 。这意味着用*u 即可表示x 的值，这正是我们需要的。不要写成这样：
```c
temp = u; /* 不要这样做 */
```
因为这条语句赋给temp 的是x 的地址（u 的值就是x 的地址）， 而不是x 的值。函数要交换的是x 和y 的值，而不是它们的地址。
与此类似，把y 的值赋给x ，要使用下面的语句：
```c
*u = *v;
```
这条语句相当于：
```c
x = y;
```
我们总结一下该程序示例做了什么。我们需要一个函数交换x 和y 的值。把x 和y 的地址传递给函数，我们让interchange() 访问这两个变量。使用指针和*运算符，该函数可以访问储存在这些位置的值并改变它们。
可以省略ANSI C风格的函数原型中的形参名，如下所示：
```c
void interchange(int *, int *);
```
一般而言，可以把变量相关的两类信息传递给函数。如果这种形式的函数调用，那么传递的是x 的值：
```c
function1(x);
```
如果下面形式的函数调用，那么传递的是x 的地址：
```c
function2(&x);
```
第1种形式要求函数定义中的形式参数必须是一个与x 的类型相同的变量：
```c
int function1(int num)
```
第2种形式要求函数定义中的形式参数必须是一个指向正确类型的指针：
```c
int function2(int * ptr)
```
如果要计算或处理值，那么使用第1种形式的函数调用；如果要在被调函数中改变主调函数的变量，则使用第2种形式的函数调用。我们用过的scanf() 函数就是这样。当程序要把一个值读入变量时 （如本例中的num ），调用的是scanf("%d", &num) 。scanf() 读取一个值，然后把该值储存到指定的地址上。

对本例而言，指针让interchange() 函数通过自己的局部变量改变main() 中变量的值。

熟悉Pascal和Modula-2的读者应该看出第1种形式和Pascal的值参数相同，第2种形式和Pascal的变量参数类似。C++程序员可能认为， 既然C和C++都使用指针变量，那么C应该也有引用变量。让他们失望了，C没有引用变量。对BASIC程序员而言，可能很难理解整个程序。
## 变量：名称、地址和值
通过前面的讨论发现，变量的名称、地址和变量的值之间关系密切。我们来进一步分析。
编写程序时，可以认为变量有两个属性：名称和值（还有其他性质，如类型，暂不讨论）。计算机编译和加载程序后，认为变量也有两个属性：地址和值。地址就是变量在计算机内部的名称。
在许多语言中，地址都归计算机管，对程序员隐藏。然而在C中，可以通过& 运算符访问地址，通过*运算符获得地址上的值。例如，&barn 表示变量barn 的地址，使用变量名即可获得变量的数值。例如，printf("%d\n", barn) 打印barn 的值，使用*运算符即可获得储存在地址上的值。如果pbarn = &barn; ，那么\*pbarn 表示的是储存在&barn 地址上的值。
简而言之，普通变量把值作为基本量，把地址作为通过& 运算符获得的派生量，而指针变量把地址作为基本量，把值作为通过\*运算符获得的派生量。
虽然打印地址可以满足读者好奇心，但是这并不是& 运算符的主要用途。更重要的是使用& 、\*和指针可以操纵地址和地址上的内容。
变量名只是**编译器提供的便利标签**（符号），它在函数作用域内**本地化**。而**地址**是**内存的物理/逻辑位置**，它**超越作用域**，代表数据的**真实存储位置**。指针通过地址**直接访问内存**，绕过了符号的限制。
C 是“带变量名的汇编”，指针让它退化为汇编风格。
