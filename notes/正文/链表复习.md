
# 链表的本质

> **链表不是一个变量，而是一堆结构体通过 next 保存地址值连起来**

- `head`：只是一个**指针变量**
    
- 链表的“头”= `head` 里存的那个地址
    
- 插入 / 删除 ≠ 改结构  
    👉 **本质是修改指针里存的地址值**
    

---

# 结构体定义（标准）

```c
typedef struct Node {
    int data;
    struct Node *next;
} Node;
```

---

# 创建节点（malloc 必考）

## ✅ 正确代码（模板）

```c
Node *p = (Node*)malloc(sizeof(Node));
p->data = 10;
p->next = NULL;
```

## ❌ 易错点

```c
malloc(sizeof(Node*))   // ❌ 只分配了指针大小
```

---

# 头插法（送分题）

## ✅ 正确代码（永远 2 行）

```c
p->next = head;
head = p;
```

### 记忆口诀

> **先接旧头，再换新头**

## ❌ 常见错误

```c
head = p;
p->next = head;   // ❌ 自己指向自己
```

---

# 尾插法（高频易错）

## ✅ 正确代码（满分版）

```c
if(head == NULL){
    head = p;
    p->next = NULL;
}
else{
    Node *q = head;
    while(q->next != NULL){
        q = q->next;
    }
    q->next = p;
    p->next = NULL;
}
```

## ❌ 易错点 1：while 条件写错

```c
while(q != NULL)   // ❌ 会走到 NULL
```

✅ 正确：

```c
while(q->next != NULL)
```

## ❌ 易错点2：空链表和非空链表不分开

```c
head = p;
...
q = head;   // ❌ 顺序执行，逻辑错误
```

---

# 遍历链表（基础）

## ✅ 正确

```c
Node *p = head;
while(p != NULL){
    printf("%d ", p->data);
    p = p->next;
}
```

## ❌ 错误

```c
while(p->next != NULL)  // ❌ 少访问最后一个节点
```

---

# 删除节点（期末压轴）

## 🎯 删除第一个 data == x 的节点（最标准）

### ✅ 正确写法

```c
Node *p = head;
Node *prev = NULL;

while(p != NULL){
    if(p->data == x){
        if(prev == NULL){        // 删除头结点
            head = p->next;
        } else {                 // 删除中间或尾结点
            prev->next = p->next;
        }
        free(p);
        break;
    }
    prev = p;
    p = p->next;
}
```

---

## ❌ 常见错误点 1：直接 free 头结点

```c
free(p);        // ❌
```

❌ 后果：  
`head` 仍指向已释放内存 → **野指针**

---

## ❌ 常见错误点 2：用两层 while 找前驱

```c
while(p != NULL){
    ...
    while(q != NULL){
        ...
    }
}
```

❌ 问题：
- 逻辑复杂
- 容易死循环
- 考试极易崩
✅ 用 `prev` 一次遍历解决

---

# free 的铁律

### ✅ 正确顺序

> **先断链，再 free**

```c
prev->next = p->next;
free(p);
```

### ❌ 错误认知

- `free(p)` ❌ 不会自动改 `head`

- `free(p)` ❌ 不会把指针变 NULL

---

# 释放整个链表（加分题）

```c
Node *p = head;
while(p != NULL){
    Node *temp = p;
    p = p->next;
    free(temp);
}
head = NULL;
```

---

# 期末必背总结（10 行）

1. 链表 = 节点 + next 里的地址值
    
2. head 只是入口指针，不是节点
    
3. malloc 用 `sizeof(Node)`
    
4. 头插法：`p->next = head; head = p;`
    
5. 尾插法：找 `q->next == NULL`
    
6. 遍历条件：`p != NULL`
    
7. 删除节点：**先改指针，再 free**
    
8. 删除头结点：必须先改 `head`
    
9. free 不会改任何指针
    
10. 删除题首选 `prev + curr`

