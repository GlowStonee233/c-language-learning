字符串 （character string ）是一个或多个字符的序列，如下所示：
```c
"Zing went the strings of my heart!"
```
# char类型数组和null字符
C语言没有专门用于储存字符串的变量类型，字符串都被储存在 char 类型的数组中。数组由连续的存储单元组成，字符串中的字符被储存在相邻的存储单元中，每个单元储存一个字符
字符\0 。这是空字符 （null character ），C语言用它标记字符串的结束。空字符不是数字0，它是非打印字符，其ASCII码值是（或等价于）0。C中的字符串一定以空字符结束，这意味着数组的容量必须至少比待存储字符串中的字符数多1
可以把数组看作是一行连续的多个存储单元。用更正式的说法是，数组是同类型数据元素的有序序列。
**声明格式**
```c
char name[40];
```
转换符号：%s
# strlen() 函数
sizeof 运算符：以字节为单位给出对象的大小
strlen() 函数：给出字符串中的字符长度
虽然一个字符占一个字节，但两个函数对同一个字符串的的运算结果不同，sizeof给出的是这个字符串的大小，包含空字符和垃圾数据，stelen则给出的是有意义的字符的长度。
二者共用%zd 转换说明
sizeof何时使用圆括号取决于运算对象是类型还是特定量。运算对象是类型时，圆括号必不可少，但是对于特定量，可有可无。尽管如此，还是建议所有情况下都使用圆括号
# 常量和C预处理器
创建符号常量可以采用两种方法方法之一是声明一个变量，然后将该变量设置为所需的常量。但这样创建的是一个变量，程序可能会无意间改变它的值。
C语言还提供了一个更好的方案——C预处理器，预处理器也可用来定义常量。只需在程序顶部添加下面一行：
```c
#define NAME value
```
编译程序时，程序中所有的量NAME都会被替换成值value。这一过程被称为编译时替换
为什么常量名要用大写？用大写表示符号常量是C语言一贯的传统。另外，还有一个不常用的命名约定，即在名称前带c_ 或k_ 前缀来表示常量。
符号常量的命名规则与变量相同。可以使用大小写字母、数字和下划线字符，首字符不能为数字。
``#define`` 指令还可定义字符和字符串常量。前者使用单引号，后者使用双引号。如下所示：
```c
#define BEEP '\a'
#define TEE 'T'
#define ESC '\033'
#define OOPS "Now you have done it!"
```

C90标准新增了const 关键字，用于限定一个==变量==为只读  。其声明如下：
```c
const int MONTHS = 12; // MONTHS在程序中不可更改，值为12
```
这使得MONTHS 成为一个只读值。也就是说，可以在计算中使用 MONTHS ，可以打印MONTHS ，但是不能更改MONTHS 的值。const 用起来比#define 更灵活
# 明示常量
C头文件limits.h 和float.h 分别提供了与整数类型和浮点类型大小限制相关的详细信息。每个头文件都定义了一系列供实现使用的明示常量 。例如，limits.h 头文件包含以下类似的代码：
```c
#define INT_MAX +32767
#define INT_MIN -32768
```
这些明示常量代表int 类型可表示的最大值和最小值。如果系统
使用32位的int ，该头文件会为这些明示常量提供不同的值。如果在
程序中包含limits.h 头文件，就可编写下面的代码：
```c
printf("Maximum int value on this system = %d\n", INT_MAX);
```
如果系统使用4字节的int ，limits.h 头文件会提供符合4字节
int 的INT_MAX 和INT_MIN 。下表列出了limits.h 中能找到的
一些明示常量。

| 明示常量       | 含义                        |
| ---------- | ------------------------- |
| CHAR_BIT   | char 类型的位数                |
| CHAR_MAX   | char 类型的最大值               |
| CHAR_MIN   | char 类型的最小值               |
| SCHAR_MAX  | signed char 类型的最大值        |
| SCHAR_MIN  | signed char 类型的最小值        |
| UCHAR_MAX  | unsigned char 类型的最大值      |
| SHRT_MAX   | short 类型的最大值              |
| SHRT_MIN   | short 类型的最小值              |
| USHRT_MAX  | unsigned short 类型的最大值     |
| INT_MAX    | int 类型的最大值                |
| INT_MIN    | int 类型的最小值                |
| UINT_MAX   | unsigned int 的最大值         |
| LONG_MAX   | long 类型的最大值               |
| LONG_MIN   | long 类型的最小值               |
| ULONG_MAX  | unsigned long 类型的最大值      |
| LLONG_MAX  | long long 类型的最大值          |
| LLONG_MIN  | long long 类型的最小值          |
| ULLONG_MAX | unsigned long long 类型的最大值 |
类似地，float.h 头文件中也定义一些明示常量，如FLT_DIG
和DBL_DIG ，分别表示float 类型和double 类型的有效数字位
数。下表列出了float.h 中的一些明示常量（可以使用文本编辑器
打开并查看系统使用的float.h 头文件）表中所列都与float 类型相关。把明示常量名中的FLT 分别替换成DBL 和LDBL ，即可分别表示double 和long double 类型对应的明示常量（表中假设系统使用2的幂来表示浮点数）。

| 明示常量           | 含义                             |
| -------------- | ------------------------------ |
| FLT_MANT_DIG   | float 类型的尾数位数                  |
| FLT_DIG        | float 类型的最少有效数字位数（十进制）         |
| FLT_MIN_10_EXP | 带全部有效数字的float 类型的最小负指数（以10 为底） |
| FLT_MAX_10_EXP | float 类型的最大正指数（以10 为底）         |
| FLT_MIN        | 保留全部精度的float 类型最小正数            |
| FLT_MAX        | float 类型的最大正数                  |
| FLT_EPSILON    | 1.00 和比1.00 大的最小float 类型值之间的差值 |
注意，编译器要完全支持C99标准才能识别LLONG_MIN 标识
# printf()和scanf()

## 使用printf()
printf() 函数的格式：
```c
printf( 格式字符串, 待打印项1, 待打印项2,...);
```
待打印项1、待打印项2等都是要打印的项。它们可以是变量、常量，甚至是在打印之前先要计算的表达式。格式字符串应包含每个待打印项对应的转换说明。
格式字符串包含两种形式不同的信息：
	实际要打印的字符
	转换说明
格式字符串中的转换说明一定要与后面的每个项相匹配，若忘记这个基本要求会导致严重的后果。
如果只打印短语或句子，就不需要使用任何转换说明。如果只打印数据，也不用加入说明文字。
### printf()转换说明
请求printf() 函数打印数据的指令要与待打印数据的类型相匹配。这些符号被称为转换说明 （conversion specification ），它们指定了如何把数据转换成可显示的形式。
下表列出了一些转换说明和各自对应的输出类型。

| 转换说明 | 输出                                          |
| ---- | ------------------------------------------- |
| %a   | 浮点数、十六进制数（p 记数法）（C99/C11）                   |
| %A   | 浮点数、十六进制数（p 记数法）（C99/C11）                   |
| %c   | 单个字符                                        |
| %d   | 有符号十进制整数                                    |
| %e   | 浮点数，e 记数法                                   |
| %E   | 浮点数，e 记数法                                   |
| %f   | 浮点数，十进制记数法                                  |
| %g   | 根据值的不同，自动选择%f 或%e 。%e 格式用于指数小于-4 或者大于或等于精度时 |
| %G   | 根据值的不同，自动选择%f 或%E 。%E 格式用于指数小于-4 或者大于或等于精度时 |
| %i   | 有符号十进制整数（与%d 相同）                            |
| %o   | 指针                                          |
| %s   | 字符串                                         |
| %u   | 无符号十进制整数                                    |
| %x   | 无符号十六进制整数，使用十六进制数0f                         |
| %X   | 无符号十六进制整数，使用十六进制数0F                         |
| %%   | 打印一个百分号                                     |
### printf() 的转换说明修饰符
下表列出了printf() 的修饰符

| 修饰符    | 含义                                                                                                                                                                                                                                                                                                             |
| ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 数字     | 最小字段宽度，如果该字段不能容纳待打印的数字或字符串，系统会使用更宽的字段 <br>示例："%4d"                                                                                                                                                                                                                                                             |
| . 数字   | 精度                                                                                                           对于%e 、%E 和%f 转换，表示小数点右边数字的位数<br>对于%g 和%G 转换，表示有效数字最大位数<br>对于%s 转换，表示待打印字符的最大数量对于整型转换，表示待打印数字的最小位数如有必要，使用前导0 来达到这个位数<br>只使用. 表示其后跟随一个0 ，所以%.f 和%.0f 相同<br>示例："%5.2f" 打印一个浮点数，字段宽度为5 字符，其中小数点后有两位数字 |
| h      | 和整型转换说明一起使用，表示short int 或unsigned short int 类型的值<br>示例："%hu" 、"%hx" 、"%6.4hd"                                                                                                                                                                                                                                  |
| hh     | 和整型转换说明一起使用，表示signed char 或unsigned char 类型的值<br>示例："%hhu" 、"%hhx" 、"%6.4hhd"                                                                                                                                                                                                                                  |
| j      | 和整型转换说明一起使用，表示intmax_t 或uintmax_t 类型的值。这些类型定义在stdint.h 中<br>示例："%jd" 、"%8jx"                                                                                                                                                                                                                                   |
| l      | 和整型转换说明一起使用，表示long int 或unsigned long int 类型的值<br>示例："%ld" 、"%8lu"                                                                                                                                                                                                                                             |
| ll     | 和整型转换说明一起使用，表示long long int 或unsigned long long int 类型的值（C99）<br>示例："%lld" 、"%8llu"                                                                                                                                                                                                                            |
| L      | 和浮点转换说明一起使用，表示long double 类型的值<br>示例："%Lf" 、"%10.4Le"                                                                                                                                                                                                                                                          |
| t      | 和整型转换说明一起使用，表示ptrdiff_t 类型的值。ptrdiff_t 是两个指针差值的类型（C99）<br>示例："%td" 、"%12ti"                                                                                                                                                                                                                                    |
| z      | 和整型转换说明一起使用，表示size_t 类型的值。size_t 是sizeof 返回的类型（C99）<br>示例："%zd" 、"%12zd"                                                                                                                                                                                                                                       |
| 标记     | 5种标记（- 、+ 、空格、# 和0 ），可以不使用标记或使用多个标记，具体作用见下表 <br>示例："%-10d"                                                                                                                                                                                                                                                     |
| -      | 待打印项左对齐。即，从字段的左侧开始打印该项<br>示例："%-20s"                                                                                                                                                                                                                                                                           |
| +      | 有符号值若为正，则在值前面显示加号；若为负，则在值前面显示减号<br>示例："%+6.2f"                                                                                                                                                                                                                                                                 |
| 空格<br> | 有符号值若为正，则在值前面显示前导空格（不显示任何符号）；若为负，<br>则在值前面显示减号<br>+ 标记覆盖一个空格<br>示例："% 6.2f"                                                                                                                                                                                                                                    |
| #      | 把结果转换为另一种形式。如果是%o 格式，则以0 开始；<br>如果是%x 或%X 格式，则以0x 或0X 开始；<br>对于所有的浮点格式，# 保证了即使后面没有任何数字，也打印一个小数点字符。<br>对于%g 和%G 格式，# 防止结果后面的0 被删除<br>示例："%#o" 、"%#8.0f" 、"%+#10.3e"                                                                                                                                             |
| 0      | 对于数值格式，用前导0 代替空格填充字段宽度。对于整数格式，如果出现-<br>标记或指定精度，则忽略该标记<br>示例："%010d" 和"%0.83f"                                                                                                                                                                                                                                  |
### **注意**
**类型可移植性**
sizeof 运算符以字节为单位返回类型或值的大小。这应该是某种形式的整数，但是标
准只规定了该值是无符号整数。在不同的实现中，它可以是unsigned int 、unsigned
long 甚至是unsigned long long 。因此，如果要用printf() 函数显示sizeof 表达
式，根据不同系统，可能使用%u 、%lu 或%llu 。这意味着要查找你当前系统的用法，如果把程序移植到不同的系统还要进行修改。鉴于此，C提供了可移植性更好的类型。首先，stddef.h 头文件（在包含stdio.h 头文件时已包含其中）把size_t 定义成系统使用
sizeof 返回的类型，这被称为底层类型（underlying type ）。其次，printf() 使用z
修饰符表示打印相应的类型。同样，C还定义了ptrdiff_t 类型和t 修饰符来表示系统使
用的两个地址差值的底层有符号整数类型。

**float 参数的转换**
对于浮点类型，有用于double 和long double 类型的转换说明，却没有float 类
型的。这是因为在K&R C中，表达式或参数中的float 类型值会被自动转换成double 类
型。一般而言，ANSI C不会把float 自动转换成double 。然而，为保护大量假设float
类型的参数被自动转换成double 的现有程序，printf() 函数中所有float 类型的参数
（对未使用显式原型的所有C函数都有效）仍自动转换成double 类型。因此，无论是K&RC还是ANSI C，都没有显示float 类型值专用的转换说明。

### 示例（星号（`*`）标出每个字段的开始和结束）
```c
/* width.c -- 字段宽度 */
#include <stdio.h>
#define PAGES 959
int main(void)
{
printf("*%d*\n", PAGES);
printf("*%2d*\n", PAGES);
printf("*%10d*\n", PAGES);
printf("*%-10d*\n", PAGES);
return 0;
}
```
**输出**：
```
*959*
*959*
* 959*
*959 *
```

```c
// floats.c -- 一些浮点型修饰符的组合
#include <stdio.h>
int main(void)
{
const double RENT = 3852.99; // const变量
printf("*%f*\n", RENT);
printf("*%e*\n", RENT);
printf("*%4.2f*\n", RENT);
printf("*%3.1f*\n", RENT);
printf("*%10.3f*\n", RENT);
printf("*%10.3E*\n", RENT);
printf("*%+4.2f*\n", RENT);
printf("*%010.2f*\n", RENT);
return 0;
}
```
**输出：**
```
*3852.990000*
*3.852990e+03*
*3852.99*
*3853.0*
* 3852.990*
* 3.853E+03*
*+3852.99*
*0003852.99*
```

```c
/* flags.c -- 演示一些格式标记 */
#include <stdio.h>
int main(void)
{
printf("%x %X %#x\n", 31, 31, 31);
printf("**%d**% d**% d**\n", 42, 42, -42);
printf("**%5d**%5.3d**%05d**%05.3d**\n", 6, 6, 6, 6);
return 0;
}
```
**输出：**
```
1f 1F 0x1f
**42** 42**-42**
** 6** 006**00006** 006**
```

```c
/* stringf.c -- 字符串格式 */
#include <stdio.h>
#define BLURB "Authentic imitation!"
int main(void)
{
printf("[%2s]\n", BLURB);
printf("[%24s]\n", BLURB);
printf("[%24.5s]\n", BLURB);
printf("[%-24.5s]\n", BLURB);
return 0;
}
```
**输出：**
```
[Authentic imitation!]
[ Authentic imitation!]
[ Authe]
[Authe ]
```

### 转换说明的意义
转换说明把以二进制格式储存在计算机中的值转换成一系列字符（字符串）以便于显示。转换 （conversion ）可能会误导读者认为原始值被替换成转换后
的值。实际上，转换说明是翻译说明，%d 的意思是“把给定的值翻译
成十进制整数文本并打印出来”。
### 转换不匹配
转换说明应该与待打印值的类型相匹配。通常都有多种选择。匹配非常重要，一定要牢记于心。转换说明与待打印值的类型不匹配会产生各种问题。
下面是演示了一些不匹配的整型转换的示例：
```c
/* intconv.c -- 一些不匹配的整型转换 */
#include <stdio.h>
#define PAGES 336
#define WORDS 65618
int main(void)
{
short num = PAGES;
short mnum = -PAGES;
printf("num as short and unsigned short: %hd %hu\n",
num,num);
printf("-num as short and unsigned short: %hd %hu\n",
mnum,mnum);
printf("num as int and char: %d %c\n", num, num);
printf("WORDS as int, short, and char: %d %hd
%c\n",WORDS,WORDS, WORDS);
return 0;
}
```
**输出：**
```
num as short and unsigned short: 336 336
-num as short and unsigned short: -336 65200
num as int and char: 336 P
WORDS as int, short, and char: 65618 82 R
```
请看输出的第1行，num 变量对应的转换说明%hd 和%hu 输出的
结果都是336 。这没有任何问题。然而，第2行mnum 变量对应的转换
说明%u （无符号）输出的结果却为65200 ，并非期望的-336 。这是
由于有符号short int 类型的值在我们的参考系统中的表示方式所
致。首先，short int 的大小是2字节；其次，系统使用二进制补码
来表示有符号整数。这种方法，数字0 ～32767 代表它们本身，而数
字32768 ～65535 则表示负数。其中，65535 表示-1 ，65534 表
示-2 ，以此类推。因此，-336 表示为65200 （即，65536-336
）。所以被解释成有符号int 时，65200 代表-336 ；而被解释成无
符号int 时，65200 则代表65200 。一定要谨慎！一个数字可以被
解释成两个不同的值。尽管并非所有的系统都使用这种方法来表示负
整数，但要注意一点：别期望用%u 转换说明能把数字和符号分开。

第3行演示了如果把一个大于255的值转换成字符会发生什么情
况。在我们的系统中，short int 是2字节，char 是1字节。当
printf() 使用%c 打印336 时，它只会查看储存336 的2字节中的后
1字节。这种截断（见图4.8）相当于用一个整数除以256，只保留其
余数。在这种情况下，余数是80，对应的ASCII值是字符P 。用专业术
语来说，该数字被解释成“以256为模”（modulo 256 ），即该数字除
以256后取其余数。

最后，我们在该系统中打印比short int 类型最大整数 （32767）更大的整数（65618）。这次，计算机也进行了求模运算。在本系统中，应把数字65618储存为4字节的int 类型值。用%hd 转换说明打印时，printf() 只使用最后2个字节。这相当于65618除以 65536的余数。这里，余数是82 。鉴于负数的储存方法，如果余数在 32767 ～65536 范围内会被打印成负数。对于整数大小不同的系统，相应的处理行为类似，但是产生的值可能不同。

**混淆整型和浮点型，结果会更奇怪。**
```c
/* floatcnv.c -- 不匹配的浮点型转换 */
#include <stdio.h>
int main(void)
{
float n1 = 3.0;
double n2 = 3.0;
long n3 = 2000000000;
long n4 = 1234567890;
printf("%.1e %.1e %.1e %.1e\n", n1, n2, n3, n4);
printf("%ld %ld\n", n3, n4);
printf("%ld %ld %ld %ld\n", n1, n2, n3, n4);
return 0;
}
```
**输出：**
```
3.0e+00 3.0e+00 3.1e+46 1.7e+266
2000000000 1234567890
0 1074266112 0 1074266112
```
%%实测visual studio可以正确输出部分值：（可能与硬件相关，有可能是寄存器映射错误）
```
3.0e+00 3.0e+00 9.9e-315 7.0e-310
2000000000 1234567890
0 0 2000000000 1234567890
```
%%
第1行输出显示，%e 转换说明没有把整数转换成浮点数。考虑一
下，如果使用%e 转换说明打印n3 （long 类型）会发生什么情况。
首先，%e 转换说明让printf() 函数认为待打印的值是double 类
型（本系统中double 为8字节）。当printf() 查看n3 （本系统中
是4字节的值）时，除了查看n3 的4 字节外，还会查看查看n3 相邻的
4字节，共8字节单元。接着，它将8字节单元中的位组合解释成浮点
数（如，把一部分位组合解释成指数）。因此，即使n3 的位数正确，
根据%e 转换说明和%ld 转换说明解释出来的值也不同。最终得到的
结果是无意义的值。
第1行也说明了前面提到的内容：float 类型的值作为
printf() 参数时会被转换成double 类型。在本系统中，float 是
4字节，但是为了printf() 能正确地显示该值，n1 被扩成8字节。
第2行输出显示，只要使用正确的转换说明，printf() 就可以
打印n3 和n4 。
第3行输出显示，如果printf() 语句有其他不匹配的地方，即
使用对了转换说明也会生成虚假的结果。用%ld 转换说明打印浮点数
会失败，但是在这里，用%ld 打印long 类型的数竟然也失败了！问
题出在C如何把信息传递给函数。具体情况因编译器实现而异。“参数
传递”框中针对一个有代表性的系统进行了讨论。
### 参数传递
参数传递机制因实现而异。下面以我们的系统为例，分析参数传递的原理。函数调用如
下：
```
printf("%ld %ld %ld %ld\n", n1, n2, n3, n4);
```

该调用告诉计算机把变量n1 、n2 、n3 和n4 的值传递给程序。这是一种常见的参数
传递方式。程序把传入的值放入被称为栈（stack ）的内存区域。计算机根据变量类型（不是根据转换说明）把这些值放入栈中。因此，n1 被储存在栈中，占8字节（float 类型被转换成double 类型）。同样，n2 也在栈中占8字节，而n3 和n4 在栈中分别占4字节。然后，控制转到printf() 函数。该函数根据转换说明（不是根据变量类型）从栈中读取值。%ld 转换说明表明printf() 应该读取4字节，所以printf() 读取栈中的前4字节作
为第1个值。这是n1 的前半部分，将被解释成一个long 类型的整数。根据下一个%ld 转换说明，printf() 再读取4字节，这是n1 的后半部分，将被解释成第2个long 类型的整数。类似地，根据第3个和第4个%ld ，printf() 读取n2 的前半部分和后半部分，并解释成两个long 类型的整数。因此，对于n3 和n4 ，虽然用对了转换说明，但printf() 还是读错了字节。
### printf() 的返回值
printf() 函数有一个返回值，它返回打印字符的个数。如果有输出错误，printf() 则返回一个负值。printf() 的返回值是其打印输出功能的附带用途，通常很少用到，但在检查输出错误时可能会用到。注意计算针对所有字符数，包括空格和不可见的换行符 （\n ）
直接赋值即可获取printf（）的返回值
### 打印较长的字符串
有时，printf() 语句太长，在屏幕上不方便阅读。如果空白 （空格、制表符、换行符）仅用于分隔不同的部分，C编译器会忽略它们。因此，一条语句可以写成多行，只需在不同部分之间输入空白即可。但是，不能在双引号括起来的字符串中间断行。在字符串中，可以使用\n 来表示换行字符，但是不能通过按下Enter （或Return ）键产生实际的换行符。
给字符串断行有3种方法：
	方法1：使用多个printf() 语句
	方法2：用反斜杠（\）和Enter （或Return ）键组合来断行。这使得光标移至下一行，而且字符串中不会包含换行符。其效果是在下一行继续输出。但是，下一行代码必须从最左边开始。如果缩进该行，比如缩进5个空格，那么这5个空格就会成为字符串的一部分。
	方法3：ANSI C引入的字符串连接。在两个用双引号括起来的字符串之间用空白隔开，C编译器会把多个字符串看作是一个字符串。
## 使用scanf()
scanf() 把输入的字符串转换成整数、浮点数、字符或字符串
scanf() 和printf() 类似，也使用格式字符串和参数列表。 scanf() 中的格式字符串表明字符输入流的目标数据类型。两个函数主要的区别在参数列表中。printf() 函数使用变量、常量和表达式，而scanf() 函数使用指向变量的指针。
这里，读者不必了解如何使用指针，
只需记住以下两条简单的规则：
	如果用scanf() 读取基本变量类型的值，在变量名前加上一个& ；
	 如果用scanf() 把字符串读入字符数组中，不要使用& 
canf() 函数使用空白（换行符、制表符和空格）把输入分成多个字段。在依次把转换说明和字段匹配时跳过空白。用户的输入可以断行，只要在每个输入项之间输入至少一个换行符、空格或制表符即可。（唯一例外的是%c 转换说明。根据%c ，scanf() 会读取每个字符，包括空白。）
scanf() 函数所用的转换说明与printf() 函数几乎相同。主要的区别是，对于float 类型和double 类型，printf() 都使用%f 、%e 、%E 、%g 和%G 转换说明。而scanf() 只把它们用于 float 类型，对于double 类型要使用l修饰符。
### **scanf() 的转换说明**及修饰符

| 转换说明           | 含义                                        |
| -------------- | ----------------------------------------- |
| %c             | 把输入解释成字符                                  |
| %d             | 把输入解释成有符号十进制整数                            |
| %e 、%f 、%g 、%a | 把输入解释成浮点数（C99标准新增了%a ）                    |
| %E 、%F 、%G 、%A | 把输入解释成浮点数（C99标准新增了%A                      |
| %i             | 把输入解释成有符号十进制整数                            |
| %o             | 把输入解释成有符号八进制整数                            |
| %p             | 把输入解释成指针（地址）                              |
| %s             | 把输入解释成字符串。从第1个非空白字符开始，到下一个空白字符之前的所有字符都是输入 |
| %u             | 把输入解释成无符号十进制整数                            |
| %x 、%X         | 把输入解释成有符号十六进制整数                           |

可以在上表所列的转换说明中（百分号和转换字符之间）使用修饰符。如果要使用多个修饰符，必须按下表所列的顺序书写。

| 转换说明    | 含义                                                                                                                                                                                                                                                                                                                                              |
| ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| *       | 抑制赋值<br>示例："% *d"                                                                                                                                                                                                                                                                                                                               |
| 数字      | 最大字段宽度。输入达到最大字段宽度处，或第1 次遇到空白字符时停止<br>示例："%10s"                                                                                                                                                                                                                                                                                                  |
| hh      | 把整数作为signed char 或unsigned char 类型读取<br>示例："%hhd" 、"%hhu"                                                                                                                                                                                                                                                                                       |
| ll      | 把整数作为long long 或unsigned long long 类型读取（C99 ）<br>示例："%lld" 、"%llu"                                                                                                                                                                                                                                                                              |
| h 、l 或L | "%hd" 和"%hi" 表明把对应的值储存为short int 类型<br>"%ho" 、"%hx" 和"%hu" 表明把对应的值储存为unsigned short int 类型<br>"%ld" 和"%li" 表明把对应的值储存为long 类型<br>"%lo" 、"%lx" 和"%lu" 表明把对应的值储存为unsigned long 类型<br>"%le" 、"%lf" 和"%lg" 表明把对应的值储存为double 类型<br>在e 、f 和g 前面使用L 而不是l ，表明把对应的值被储存为long double 类<br>型。如果没有修饰符，d 、i 、o 和x 表明对应的值被储存为int 类型，f 和<br>g 表明把对应的值储存为float 类型 |
| j       | 在整型转换说明后面时，表明使用intmax_t 或uintmax_t 类型（C99）<br>示例："%jd" 、"%ju"                                                                                                                                                                                                                                                                                   |
| z       | 在整型转换说明后面时，表明使用sizeof 的返回类型（C99）<br>示例："%zd" 、"%zo"                                                                                                                                                                                                                                                                                             |
| t       | 在整型转换说明后面时，表明使用表示两个指针差值的类型（C99）<br>示例："%td" 、"%tx"                                                                                                                                                                                                                                                                                              |
使用转换说明比较复杂，而且这些表中还省略了一些特性。省略的主要特性是，从高度格式化源中读取选定数据，如穿孔卡或其他数据记录。在此不加讨论。
### 从scanf() 角度看输入
假设 scanf() 根据一个%d 转换说明读取一个整数。scanf() 函数每次读取一个字符，跳过所有的空白字符，直至遇到第1个非空白字符才开始读取。因为要读取整数，所以scanf() 希望发现一个数字字符或者一个符号（+ 或- ）。如果找到一个数字或符号，它便保存该字符，并读取下一个字符。如果下一个字符是数字，它便保存该数字并读取下一个字符。scanf() 不断地读取和保存字符，直至遇到非数字字符。如果遇到一个非数字字符，它便认为读到了整数的末尾。然后，scanf() 把非数字字符放回输入。这意味着程序在下一次读取输入时，首先读到的是上一次读取丢弃的非数字字符。最后，scanf() 计算已读取数字（可能还有符号）相应的数值，并将计算后的值放入指定的变量中。
如果使用字段宽度，scanf() 会在字段结尾或第1个空白字符处停止读取（满足两个条件之一便停止）。
如果第1个非空白字符是A 而不是数字，会发生什么情况？ scanf() 将停在那里，并把A 放回输入中，不会把值赋给指定变量。程序在下一次读取输入时，首先读到的字符是A 。如果程序只使用%d 转换说明，scanf() 就一直无法越过A 读下一个字符。另外，如果使用带多个转换说明的scanf() ，C规定在第1个出错处停止读取输入。
用其他数值匹配的转换说明读取输入和用%d 的情况相同。区别在于scanf() 会把更多字符识别成数字的一部分。例如，%x 转换说明要求scanf() 识别十六进制数a ～f 和A ～F 。浮点转换说明要求 scanf() 识别小数点、e 记数法（指数记数法）和新增的p 记数法 （十六进制指数记数法）。
如果使用%s 转换说明，scanf() 会读取除空白以外的所有字符。scanf() 跳过空白开始读取第1 个非空白字符，并保存非空白字符直到再次遇到空白。这意味着scanf() 根据%s 转换说明读取一个单词，即不包含空白字符的字符串。如果使用字段宽度，scanf() 在字段末尾或第1 个空白字符处停止读取。无法利用字段宽度让只有一个%s 的scanf() 读取多个单词。最后要注意一点：当scanf() 把字符串放进指定数组中时，它会在字符序列的末尾加上'\0' ，让数组中的内容成为一个C字符串。
实际上，在C语言中scanf() 并不是最常用的输入函数。这里重点介绍它是因为它能读取不同类型的数据。C语言还有其他的输入函数，如getchar() 和fgets() 。这两个函数更适合处理一些特殊情况，如读取单个字符或包含空格的字符串。
### 格式字符串中的普通字符
scanf() 函数允许把普通字符放在格式字符串中。除空格字符外的普通字符必须与输入字符串严格匹配。例如，假设在两个转换说明中添加一个逗号：
```c
scanf("%d,%d", &n, &m);
```
scanf() 函数将其解释成：用户将输入一个数字、一个逗号，然后再输入一个数字。也就是说，用户必须像下面这样进行输入两个整数：
```
88,121
```
格式字符串中的空白意味着跳过下一个输入项前面的所有空白。例如，对于下面的语句：
```c
scanf("%d ,%d", &n, &m);
```
以下的输入格式都没问题：
```
88,121
88 ,121
88 , 121
```
请注意，“所有空白”的概念包括没有空格的特殊情况。
除了%c ，其他转换说明都会自动跳过待输入值前面所有的空白。因此
scanf("%d%d", &n, &m) 与scanf("%d %d", &n, &m) 的行为相同。对于%c ，在格式字符串中添加一个空格字符会有所不同。例如，如果在格式字符串中把空格放到%c 的前面，scanf() 便会跳过空格，从第1个非空白字符开始读取。也就是说， scanf("%c", &ch) 从输入中的第1个字符开始读取，而scanf(" %c", &ch) 则从第1个非空白字符开始读取。
### scanf() 的返回值
scanf() 函数返回成功读取的项数。如果没有读取任何项，且需要读取一个数字而用户却输入一个非数值字符串，scanf() 便返回0 。当scanf() 检测到“文件结尾”时，会返回EOF （EOF 是stdio.h 中定义的特殊值，通常用#define 指令把EOF 定义为-1 ）。

## printf() 和scanf()\*的*修饰符
printf() 和scanf() 都可以使用*修饰符来修改转换说明的含义。但是，它们的用法不太一样。
### printf()
如果你不想预先指定字段宽度，希望通过程序来指定，那么可以用*修饰符代替字段宽度。但还是要用一个参数告诉函数，字段宽度应该是多少。也就是说，如果转换说明是% *d ，那么参数列表中应包含*和d 对应的值。这个技巧也可用于浮点值指定精度和字段宽度。
以下程序演示了相关用法
```
/* varwid.c -- 使用变宽输出字段 */
#include <stdio.h>
int main(void)
{
unsigned width, precision;
int number = 256;
double weight = 242.5;
printf("Enter a field width:\n");
scanf("%d", &width);
printf("The number is :%*d:\n", width, number);
printf("Now enter a width and a precision:\n");
scanf("%d %d", &width, &precision);
printf("Weight = %*.*f\n", width, precision, weight);
printf("Done!\n");
return 0;
}
```
变量width 提供字段宽度，number 是待打印的数字。因为转换说明中*在d 的前面，所以在printf() 的参数列表中，width 在number 的前面。同样，width 和precision 提供打印weight 的格式化信息。下面是一个运行示例：
```
Enter a field width:
6
The number is : 256:
Now enter a width and a precision:
8 3
Weight = 242.500
Done!
```

### scanf（）
scanf() 中*的用法与此不同。把*放在% 和转换字符之间时，会使得scanf() 跳过相应的输出项。下面是一个例子：
```c
/* skiptwo.c -- 跳过输入中的前两个整数 */
#include <stdio.h>
int main(void)
{
int n;
printf("Please enter three integers:\n");
scanf("%*d %*d %d", &n);
printf("The last integer was %d\n", n);
return 0;
}
```
\*使得scanf()跳过两个整数，把第3个整数拷贝给n 。下面是一个运行示例：
```
Please enter three integers:
2013 2014 2015
The last integer was 2015
```
在程序需要读取文件中特定列的内容时，这项跳过功能很有用。

## printf() 的用法提示
想把数据打印成列，指定固定字段宽度很有用。因为默认的字段
宽度是待打印数字的宽度，如果同一列中打印的数字位数不同，那么
下面的语句：
```c
printf("%d %d %d\n", val1, val2, val3);
```
打印出来的数字可能参差不齐。例如，假设执行3次printf()
语句，用户输入不同的变量，其输出可能是这样：
```
12 234 1222
4 5 23
22334 2322 10001
```
使用足够大的固定字段宽度可以让输出整齐美观。例如，若使用
下面的语句：
```c
printf("%9d %9d %9d\n", val1, val2, val3);
```
上面的输出将变成：
```
    12    234      1222
    4       5        23
22334    2322     10001
```
在两个转换说明中间插入一个空白字符，可以确保即使一个数字溢出了自己的字段，下一个数字也不会紧跟该数字一起输出（这样两个数字看起来像是一个数字）。这是因为格式字符串中的普通字符(包括空格）会被打印出来。
另一方面，如果要在文字中嵌入一个数字，通常指定一个小于或
等于该数字宽度的字段会比较方便。这样，输出数字的宽度正合适，
没有不必要的空白。例如，下面的语句：
```
printf("Count Beppo ran %.2f miles in 3 hours.\n", distance);
```
其输出如下：
```
Count Beppo ran 10.22 miles in 3 hours.
```
如果把转换说明改为%10.2f ，则输出如下：
```
Count Beppo ran      10.22 miles in 3 hours
```
### 本地化设置
美国和世界上的许多地区都使用一个点来分隔十进制值的整数部分和小数部分，如
3.14159。然而，许多其他地区用逗号来分隔，如3,14159。读者可能注意到了，printf()
和scanf() 都没有提供逗号的转换说明。C语言考虑了这种情况。本书附录B的参考资料V
中介绍了C支持的本地化概念，因此C程序可以选择特定的本地化设置。例如，如果指定了荷兰语言环境，printf() 和scanf() 在显示和读取浮点值时会使用本地惯例（在这种情
况下，用逗号代替点分隔浮点值的整数部分和小数部分）。另外，一旦指定了环境，便可在代码的数字中使用逗号：
```
double pi = 3,14159; // 荷兰本地化设置
```
C标准有两个本地化设置："C" 和"" （空字符串）。默认情况下，程序使用"C" 本地
化设置，基本上符合美国的用法习惯。而"" 本地化设置可以替换当前系统中使用的本地语言环境。原则上，这与"C" 本地化设置相同。事实上，大部分操作系统（如UNIX、Linux和Windows）都提供本地化设置选项列表，只不过它们提供的列表可能不同。
## 总结
C语言用char 类型表示单个字符，用字符串表示字符序列。字符
常量是一种字符串形式，即用双引号把字符括起来："Good luck,
my friend" 。可以把字符串储存在字符数组（由内存中相邻的字节
组成）中。字符串，无论是表示成字符常量还是储存在字符数组中，
都以一个叫做空字符 的隐藏字符结尾。
在程序中，最好用#define 定义数值常量，用const 关键字声
明的变量为只读变量。在程序中使用符号常量（明示常量），提高了
程序的可读性和可维护性。
C语言的标准输入函数（scanf() ）和标准输出函数
（printf() ）都使用一种系统。在该系统中，第1个参数中的转换
说明必须与后续参数中的值相匹配。例如，int 转换说明%d 与一个
浮点值匹配会产生奇怪的结果。必须格外小心，确保转换说明的数量
和类型与函数的其余参数相匹配。对于scanf() ，一定要记得在变量
名前加上地址运算符（& ）。
空白字符（制表符、空格和换行符）在scanf() 处理输入时起着
至关重要的作用。除了%c 模式（读取下一个字符），scanf() 在读
取输入时会跳过非空白字符前的所有空白字符，然后一直读取字符，
直至遇到空白字符或与正在读取字符不匹配的字符。考虑一下，如果
scanf() 根据不同的转换说明读取相同的输入行，会发生什么情况。
假设有如下输入行：
```
-13.45e12# 0
```

如果其对应的转换说明是%d ，scanf() 会读取3个字符（-13
）并停在小数点处，小数点将被留在输入中作为下一次输入的首字
符。如果其对应的转换说明是%f ，scanf() 会读取-13.45e12 ，
并停在# 符号处，而# 将被留在输入中作为下一次输入的首字符；然
后，scanf() 把读取的字符序列-13.45e12 转换成相应的浮点值，
并储存在float 类型的目标变量中。如果其对应的转换说明是%s ，
scanf() 会读取-13.45e12# ，并停在空格处，空格将被留在输入
中作为下一次输入的首字符；然后，scanf() 把这10个字符的字符
码储存在目标字符数组中，并在末尾加上一个空字符。如果其对应的
转换说明是%c ，scanf() 只会读取并储存第1个字符，该例中是一
个空格 。
# 本章小结
字符串是一系列被视为一个处理单元的字符。在C语言中，字符
串是以空字符（ASCII码是0）结尾的一系列字符。可以把字符串储存
在字符数组中。数组是一系列同类型的项或元素。下面声明了一个名
为name 、有30个char 类型元素的数组：
```c
char name[30];
```
要确保有足够多的元素来储存整个字符串（包括空字符）。
字符串常量是用双引号括起来的字符序列，如："This is
anexample of a string" 。
strlen() 函数（声明在string.h 头文件中）可用于获得字符
串的长度（末尾的空字符不计算在内）。scanf() 函数中的转换说明
是%s 时，可读取一个单词。
C预处理器为预处理器指令（以# 符号开始）查找源代码程序，并
在开始编译程序之前处理它们。处理器根据#include 指令把另一个
文件中的内容添加到该指令所在的位置。#define 指令可以创建明示
常量（符号常量），即代表常量的符号。limits.h 和float.h 头
文件用#define 定义了一组表示整型和浮点型不同属性的符号常量。
另外，还可以使用const 限定符创建定义后就不能修改的变量。
printf() 和scanf() 函数对输入和输出提供多种支持。两个
函数都使用格式字符串，其中包含的转换说明表明待读取或待打印数
据项的数量和类型。另外，可以使用转换说明控制输出的外观：字段
宽度、小数位和字段内的布局。
# 注释：关于明示常量与符号常量
符号常量的概念在K&R合著的《C语言程序设计》中介绍过。但是，在历年的C标准中（包括最新的C11），并没有符号常量的概念，只提到过#define 最简单的用法是定义一个“明示常量”。本文这两个词语是混用的，意思一样。
关于这两个词语的定义不明确，难以分析，目前多见于二者混用
注意本书的明示常量是manifest constant，符号常量是symbolic constant，有AI认为明示常量是literal Constant，这个词组有时也被翻译为字面常量
