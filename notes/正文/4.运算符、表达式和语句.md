# 基本运算符
=、+、-、* 和/,C没有指数运算符。不过，C的标准数学库（math.h）提供了一个pow() 函数用于指数运算。例如，pow(3.5, 2.2) 返回3.5 的2.2 次幂
## 赋值运算符：=
在C语言中，=并不意味着“相等”，而是一个赋值运算符。下面的赋值表达式语句：
```c
bmw = 2002;
```
把值2002 赋给变量bmw 。也就是说，=号左侧是一个变量名， 右侧是赋给该变量的值。符号=被称为赋值运算符。另外，上面的语句不读作“bmw 等于2002 ”，而读作“把值2002 赋给变量bmw ”。赋值行为从右往左进行。
也许变量名和变量值的区别看上去微乎其微，但是，考虑下面这条常用的语句：
```c
i = i + 1;
```
对数学而言，这完全行不通。如果给一个有限的数加上1 ，它不可能“等于”原来的数。但是，在计算机赋值表达式语句中，这很合理。该语句的意思是：找出变量i 的值，把该值加1 ，然后把新值赋值变量i
在C语言中，类似这样的语句没有意义（实际上是无效的）：
```c
2002 = bmw;
```
因为在这种情况下，2002 被称为右值 （rvalue ），只能是字面常量。不能给常量赋值，常量本身就是它的值。因此，在编写代码时要记住，=号左侧的项必须是一个变量名。
实际上，赋值运算符左侧必须引用一个存储位置。最简单的方法就是使用变量名。
赋值表达式语句的目的是把值储存到内存位置上。用于储存值的数据存储区域统称为数据对象，使用变量名是标识对象的一种方法。
左值 （lvalue ）是C语言的术语，用于标识特定数据对象的名称或表达式。因此，对象指的是实际的数据存储，而左值是用于标识或定位存储位置的标签。
赋值运算符的左侧应该是可修改的左值。当前标准建议，使用术语对象定位值 （object locator value ）更好。
右值 （rvalue ）指的是能赋值给可修改左值的量，且本身不是左值。右值可以是常量、变量或其他可求值的表达式。实际上，当前标准在描述这一概念时使用的是表达式的值 （value of an expression ），而不是右值。
在学习名称时，被称为“项”（如，赋值运算符左侧的项）的就是运算对象 （operand ）。运算对象是运算符操作的对象。
C的基本赋值运算符有些与众不同，请看示例：
```c
/* golf.c -- 高尔夫锦标赛记分卡 */
#include <stdio.h>
int main(void)
{
int jane, tarzan, cheeta;
cheeta = tarzan = jane = 68;
printf(" cheeta tarzan jane\n");
printf("First round score %4d %8d %8d\n", cheeta, tarzan,
jane);
return 0;
}
```
许多其他语言都会回避该程序中的三重赋值，但是C完全没问题。赋值的顺序是从右往左：首先把68 赋给jane ，然后再赋给 tarzan ，最后赋给cheeta 。因此，程序的输出如下：
```
                  cheetah tarzan jane
First round score   68      68    68
```
## 加法运算符：+
加法运算符 （addition operator ）用于加法运算，使其两侧的值相加。相加的值（运算对象）可以是变量，也可以是常量。
## 减法运算符：-
 减法运算符 （subtraction operator ）用于减法运算，使其左侧的数减去右侧的数。
 +和-运算符都被称为二元运算符 （binary operator ），即这些运算符需要两个运算对象才能完成操作。减号还可用于标明或改变一个值的代数符号。
## 乘法运算符：*
符号\*表示乘法。
## 除法运算符：/
C使用符号/ 来表示除法。/ 左侧的值是被除数，右侧的值是除数。
整数除法和浮点数除法不同。浮点数除法的结果是浮点数，而整数除法的结果是整数。在C语言中，整数除法结果的小数部分被丢弃，这一过程被称为截断 （truncation ）。
注意，整数除法会截断计算结果的小数部分（丢弃整个小数部分），不会四舍五入结果。
混合整数和浮点数计算的结果是浮点数。实际上，计算机不能真正用浮点数除以整数，编译器会把两个运算对象转换成相同的类型。
C99标准以前，C语言给语言的实现者留有一些空间，让他们来决定如何进行负数的整数除法。一种方法是，舍入过程采用小于或等于浮点数的最大整数。另一种舍入方法是直接丢弃小数部分，这种方法被称为“趋零截断 ”。在C99以前，不同的实现采用不同的方法。但是C99规定使用趋零截断。
## 运算符优先级
与代数中的运算优先级相同
运算符优先级为表达式中的求值顺序提供重要的依据，但是并没有规定所有的顺序。当运算符共享一个运算对象时，优先级决定了求值顺序。但是，优先级并未规定不共享一个运算对象的运算符的顺序
示例：
```c
y = 6 * 12 + 5 * 20;
```
C语言标准未规定是先算6\*12还是先算5\*20
# 其他常用运算符
## sizeof 运算符和size_t 类型
sizeof 运算符以字节为单位返回运算对象的大小（在C中，1字节定义为char 类型占用的空间大小。过去，1字节通常是8位，但是一些字符集可能使用更大的字节).
运算对象可以是具体的数据对象（如，变量名）或类型。如果运算对象是类型（如，float ），则必须用圆括号将其括起来。
C语言规定，sizeof 返回size_t 类型的值。这是一个无符号整数类型，但它不是新类型。前面介绍过，size_t 是语言定义的标准类型。C有一个typedef 机制，允许程序员为现有类型创建别名。例如，
```c
typedef double real;
```
这样，real 就是double 的别名。现在，可以声明一个real 类型的变量：
```c
real deal; // 使用typedef
```
编译器查看real 时会发现，在typedef 声明中real 已成为 double 的别名，于是把deal 创建为double 类型的变量。类似地，C头文件系统可以使用typedef 把size_t 作为unsigned int 或unsigned long 的别名。这样，在使用size_t 类型时，编译器会根据不同的系统替换标准类型。
C99做了进一步调整，新增了%zd 转换说明用于printf() 显示 size_t 类型的值。如果系统不支持%zd ，可使用%u 或%lu 代替%zd 。
## 求模运算符：%
求模运算符 （modulus operator ）用于整数运算。求模运算符给出其左侧整数除以右侧整数的余数 （remainder ）。求模运算符只能用于整数，不能用于浮点数。
实际上，标准规定：无论何种情况，只要a 和b 都是整数值，便可通过a - (a/b)\*b 来计算a\%b 。
## 递增运算符：++
递增运算符 （increment operator ）执行简单的任务，将其运算对象递增1。该运算符以两种方式出现。第1种方式，++出现在其作用的变量前面，这是前缀模式；第2种方式，++出现在其作用的变量后面，这是后缀模式。两种模式的区别在于递增行为发生的时间不同。
++的前缀形式是在使用变量前递增，后缀形式则是在使用变量后才递增。(**这里的使用指的是获取该变量的值，并将其用于当前所在的整个表达式（或语句）的计算**。)
如果使用前缀形式和后缀形式会对代码产生不同的影响，那么最为明智的是不要那样使用它们，可以选择先递增再进行运算。
## 递减运算符：--
每种形式的递增运算符都有一个递减运算符 （decrement operator ）与之对应，用-- 代替++ 即可
## 优先级
递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高。因此，x*y++ 表示的是(x)*(y++) ，而不是 (x*y)++ 。不过后者无效，因为递增和递减运算符只能影响一个变量 （或者，更普遍地说，只能影响一个可修改的左值），而组合x*y 本身不是可修改的左值。
不要混淆这两个运算符的优先级和它们的求值顺序。假设有如下语句：
```c
y = 2; 
n = 3; 
nextnum = (y + n++)*6;
```
nextnum 的值是多少？把y 和n 的值带入上面的第3条语句得：
```c
nextnum = (2 + 3)*6 = 5*6 = 30
```
n 的值只有在被使用之后才会递增为4 。根据优先级的规定，++ 只作用于n ，不作用与y + n 。除此之外，根据优先级可以判断何时使用n 的值对表达式求值，而递增运算符的性质决定了何时递增n 的值。
如果n++ 是表达式的一部分，可将其视为“先使用n ，再递增”； 而++n 则表示“先递增n ，再使用”。
## 递增运算符的使用问题
在C语言中，编译器可以自行选择先对函数中的哪个参数求值。这样做提高了编译器的效率，但是如果在函数的参数中使用了递增运算符，就会有一些问题。
示例：
```c
n = 3; 
y = n++ + n++;
```
无法判断运算顺序，n和y的值不确定
```c
ans = num/2 + 5*(1 + num++);
```
编译器先算哪一项不确定
使用递增运算符的注意事项
	如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运符；
	如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符。
# 表达式和语句
## 表达式
表达式 （expression ）由运算符和运算对象组成（前面介绍过， 运算对象是运算符操作的对象）。最简单的表达式是一个单独的运算对象，以此为基础可以建立复杂的表达式。运算对象可以是常量、变量或二者的组合。一些表达式由子表达式（subexpression ）组成（子表达式即较小的表达式）。
**每个表达式都有一个值**
C表达式的一个最重要的特性是，每个表达式都有一个值。要获得这个值，必须根据运算符优先级规定的顺序来执行操作。要获得这个值，必须根据运算符优先级规定的顺序来执行操作。有赋值运算符（= ）的表达式的值与赋值运算符左侧变量的值相同。
## 语句
语句 （statement ）是C程序的基本构建块。一条语句相当于一条完整的计算机指令。在C中，大部分语句都以分号结尾。最简单的语句是空语句：
```c
   ；//这是空语句
```
C把末尾加上一个分号的表达式都看作是一条语句（即，表达式语句）。但是，如果语句在程序中什么也不做，不算是真正有用的语句。更确切地说，语句可以改变值或调用函数。
虽然一条语句（或者至少是一条有用的语句）相当于一条完整的指令，但并不是所有的指令都是语句。考虑下面的语句：
```c
x = 6 + (y = 5);
```
该语句中的子表达式y = 5 是一条完整的指令，但是它只是语句的一部分。因为一条完整的指令不一定是一条语句，所以分号用于识别在这种情况下的语句（即，简单语句）。声明创建了名称和类型， 并为其分配内存位置。
注意，声明不是表达式语句。也就是说，如果删除声明后面的分号，剩下的部分不是一个表达式，也没有值
赋值表达式语句在程序中很常用：它为变量分配一个值。赋值表达式语句的结构是，一个变量名，后面是一个赋值运算符，再跟着一个表达式，最后以分号结尾。
函数表达式语句会引起函数调用。
while 语句是一种迭代语句，有时也被称为结构化语句 ，因为它的结构比简单的赋值表达式语句复杂。
### 副作用和序列点
我们再讨论一个C语言的术语副作用 （side effect ）。副作用是对数据对象或文件的修改。例如，语句：
```c
states = 50;
```
它的副作用是将变量的值设置为50 。副作用？这似乎更像是主要目的！但是从C语言的角度看，主要目的是对表达式求值。
类似地，调用printf() 函数时，它显示的信息其实是副作用 （printf() 的返回值是待显示字符的个数）。
==序列点== （sequence point ）是程序执行的点，在该点上，所有的副作用都在进入下一步之前发生。在C语言中，语句中的分号标记了一个序列点。意思是，在一个语句中，赋值运算符、递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成。后面我们要讨论的一些运算符也有序列点。另外，任何一个完整表达式的结束也是一个序列点。
什么是完整表达式？所谓完整表达式 （full expression ），就是指这个表达式不是另一个更大表达式的子表达式。
序列点有助于分析后缀递增何时发生。
## 复合语句（块）
复合语句 （compound statement ）是用花括号括起来的一条或多条语句，复合语句也称为块 （block ）。

**风格提示**
循环体中的缩进对编译器不起作用，编译器通过花括号和while 循环的结构来识别和解释指令。这里，缩进是为了让读者一眼就可以看出程序是如何组织的。
常见风格：
```c
index = 0;
while (index++ < 10)
{
sam = 10 * index + 2;
printf("sam = %d\n", sam);
}
```
强调语句形成一个块
或者：
```c
while (index++ < 10) {
sam = 10*index + 2;
printf("sam = %d \n", sam);
}
```
这种风格突出了块附属于while 循环
这两种风格对编译器完全一样
# 类型转换
## 基本的类型转换规则
1．当类型转换出现在表达式时，无论是unsigned 还是signed的char 和short 都会被自动转换成int ，如有必要会被转换成unsigned int （如果short 与int 的大小相同，unsigned short 就比int 大。这种情况下，unsigned short 会被转换成unsigned int ）。在K&R那时的C中，float 会被自动转换成double （目前的C不是这样）。由于都是从较小类型转换为较大类型，所以这些转换被称为升级 （promotion ）。
2．涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。
3．类型的级别从高至低依次是long double 、double 、float 、unsigned long long 、long long 、unsignedlong 、long 、unsigned int 、int 。例外的情况是，当long和int 的大小相同时，unsigned int 比long 的级别高。之所以short 和char 类型没有出，是因为它们已经被升级到int 或unsigned int 。
4．在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。这个过程可能导致类型升级或降级 （demotion ）。所谓降级，是指把一种类型转换成更低级别的类型。
5．当作为函数参数传递时，char 和short 被转换成int ，
float 被转换成double 。函数原型会覆盖自动升级。

类型升级通常都不会有什么问题，但是类型降级会导致真正的麻
烦。原因很简单：较低类型可能放不下整个数字。例如，一个8位的char 类型变量储存整数101 没问题，但是存不下22334 。如果待转换的值与目标类型不匹配怎么办？这取决于转换涉及的类型。待赋值的值与目标类型不匹配时，规则如下。
1．目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略。例如，如果目标类型是8位unsigned char ，待赋的值是原始值求模256 。
2．如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异。
3．如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的。
如果把一个浮点值转换成整数类型会怎样？当浮点类型被降级为
整数类型时，原来的浮点值会被截断。例如，23.12 和23.99 都会
被截断为23 ，-23.5 会被截断为-23 。
## 强制类型转换运算符
通常，应该避免自动类型转换，尤其是类型降级。但是如果能小心使用，类型转换也很方便。我们前面讨论的类型转换都是自动完成的。然而，有时需要进行精确的类型转换，或者在程序中表明类型转换的意图。这种情况下要用到强制类型转换 （cast ），即在某个量的前面放置用圆括号括起来的类型名，该类型名即是希望转换成的目标类型。圆括号和它括起来的类型名构成了强制类型转换运算符 （cast operator ），其通用形式是：
```c
(type) //用实际需要的类型（如，long ）替换 type 即可。
```
一般而言，不应该混合使用类型（因此有些语言直接不允许这样做），但是偶尔这样做也是有用的。C语言的原则是避免给程序员设置障碍，但是程序员必须承担使用的风险和责任。
# 带参数的函数
示例：
```c
/* pound.c -- 定义一个带一个参数的函数 */
#include <stdio.h>
void pound(int n); // ANSI函数原型声明
int main(void)
{
int times = 5;
char ch = '!'; // ASCII码是33
float f = 6.0f;
pound(times); // int类型的参数
pound(ch); // 和pound((int)ch);相同
pound(f); // 和pound((int)f);相同
return 0;
}
```
函数头：`void pound(int n)`
如果函数不接受任何参数，函数头的圆括号中应该写上关键字 void 。由于该函数接受一个int 类型的参数，所以圆括号中包含一个int 类型变量n 的声明。参数名应遵循C语言的命名规则。
声明参数就创建了被称为形式参数 （formal argument 或formal parameter ，简称形参）的变量。该例中，形式参数是int 类型的变量n 。像pound(10) 这样的函数调用会把10 赋给n 。在该程序中， 调用pound(times) 就是把times 的值（5 ）赋给n 。我们称函数调用传递的值为实际参数 （actual argument 或actual parameter 注意 ），简称实参。所以，函数调用pound(10) 把实际参数10 传递给函数，然后该函数把10 赋给形式参数（变量n ）。也就是说，main() 中的变量times 的值被拷贝给pound() 中的新变量n 。

**注意：形参与实参**
在英文中，argument和parameter经常可以互换使用，但是C99标准规定了：对于
actual argument或actual parameter使用术语argument（译为实参）；对于formal
argument或formal parameter使用术语parameter（译为形参）。为遵循这一规定，我们可以说形参是变量，实参是函数调用提供的值，实参被赋给相应的形参。因此，在以上程序中，times 是pound() 的实参，n 是pound() 的形参。类似地，在函数调用pound(times + 4) 中，表达式times + 4 的值是该函数的实参。

变量名是函数私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突。也就是说，即使程序中出现了两个同名的变量，程序仍然可以区分它们。
原型 （prototype ）即是函数的声明，描述了函数的返回值和参数。
pound() 函数的原型说明了两点：
该函数没有返回值（函数名前面有void 关键字）； 
该函数有一个int 类型的参数。

在ANSI C之前，C使用的是函数声明，而不是函数原型。函数声明只指明了函数名和返回类型，没有指明参数类型。为了向下兼容， C现在仍然允许这样的形式：
```c
void pound(); /* ANSI C之前的函数声明 */
```
# 小结
C语言有许多运算符，如本章讨论的赋值运算符和算术运算符。
一般而言，运算符需要一个或多个运算对象才能完成运算生成一个值。只需要一个运算对象的运算符（如负号和sizeof ）称为一元运算符 ，需要两个运算对象的运算符（如加法运算符和乘法运算符）称为二元运算符 。
表达式由运算符和运算对象组成。在C语言中，每个表达式都有一个值，包括赋值表达式和比较表达式。运算符优先级规则决定了表达式中各项的求值顺序。当两个运算符共享一个运算对象时，先进行优先级高的运算。如果运算符的优先级相等，由结合律（从左往右或从右往左）决定求值顺序。
大部分语句都以分号结尾。最常用的语句是表达式语句 。用花括号括起来的一条或多条语句构成了复合语句 （或称为块 ）。while 语句是一种迭代语句 ，只要测试条件为真，就重复执行循环体中的语句。
在C语言中，许多类型转换都是自动进行的。当char 和short类型出现在表达式里或作为函数的参数（函数原型除外）时，都会被升级为int 类型；float 类型在函数参数中时，会被升级为double类型。在K&R C（不是ANSI C）下，表达式中的float 也会被升级为double 类型。当把一种类型的值赋给另一种类型的变量时，值将被转换成与变量的类型相同。当把较大类型转换成较小类型时（如，long 转换成short ，或double 转换成float ），可能会丢失数据。在混合类型的运算中，较小类型会被转换成较大类型。
定义带一个参数的函数时，便在函数定义中声明了一个变量， 或称为形式参数 。然后，在函数调用中传入的值会被赋给这个变量。这样，在函数中就可以使用该值了。
# 注释
**C 语言的函数声明**
如果主函数（`main`）需要调用一个稍后才定义的函数，必须先提供一个函数声明 (Prototype)。
如果函数定义（包含签名和函数体）出现在所有调用它的地方之前，那么这个定义本身就充当了声明的作用，因此不再需要一个单独的声明。

