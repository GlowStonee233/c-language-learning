# while 循环
通用形式如下：
```c
while ( expression
)
statement
```
statement 部分可以是以分号结尾的简单语句，也可以是用花括号括起来的复合语句。
如果 expression 为真（或者更一般地说，非零），执行statement 部分一次，然后再次判断 expression 。在expression 为假（0 ）之前，循环的判断和执行一直重复进行。每次循环都被称为一次迭代 （iteration ）
## 终止while 循环
while 循环有一点非常重要：在构建while 循环时，必须让测试表达式的值有变化，表达式最终要为假。否则，循环就不会终止。
## 入口条件循环
while 循环是使用入口条件的有条件循环。所谓“有条件”指的是语句部分的执行取决于测试表达式描述的条件，如(index < 5) 。该表达式是一个入口条件 （entry condition ），因为必须满足条件才能进入循环体。如果条件一开始就为假，就不会进入循环体。
## 语法要点
使用while 时，要牢记一点：只有在测试条件后面的单独语句 （简单语句或复合语句）才是循环部分。
## 用关系运算符和表达式比较大小
while 循环经常依赖测试表达式作比较，这样的表达式被称为关系表达式 （relational expression ），出现在关系表达式中间的运算符叫做关系运算符 （relational operator ）。前面的示例中已经用过一些关系运算符，下表列出了C语言的所有关系运算符。该表也涵盖了所有的数值关系。

| 运算符 | 含义    |
| --- | ----- |
| <   | 小于    |
| <=  | 小于或等于 |
| ==  | 等于    |
| >=  | 大于或等于 |
| >   | 大于    |
| !=  | 不等于   |
关系表达式还可用于比较字符。比较时使用的是机器字符码（假定为ASCII）。但是，不能用关系运算符比较字符串。
虽然关系运算符也可用来比较浮点数，但是要注意：比较浮点数时，尽量只使用<和>。因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等。使用fabs() 函数（声明在math.h 头文件中）可以方便地比较浮点数，该函数返回一个浮点值的绝对值（即没有代数符号的值）。
## C的真值
对C而言，表达式为真的值是1，表达式为假的值是0。一般而言，所有的非零值都视为真，只有0 被视为假。
应用：
用 while (goats) 替换while (goats != 0)
**真值的问题**
许多经验丰富的程序员在构建比较是否相等的表达式时，都习惯把常量放在左侧。这样方便编译器检查出错误。
具体原因如下：
```c
5 = canoes //语法错误
5 == canoes //检查canoes的值是否为5
```
## _Bool 类型
在C语言中，一直用int 类型的变量表示真/假值。C99专门针对这种类型的变量新增了_Bool 类型。该类型是以英国数学家George Boole的名字命名的，他开发了用代数表示逻辑和解决逻辑问题。在编程中，表示真或假的变量被称为布尔变量 （Boolean variable ），所以_Bool 是C语言中布尔变量的类型名。_Bool 类型的变量只能储存 1 （真）或0 （假）。如果把其他非零数值赋给_Bool 类型的变量， 该变量会被设置为1 。这反映了C把所有的非零值都视为真。
C99提供了stdbool.h 头文件，该头文件让bool 成为_Bool 的别名，而且还把true 和false 分别定义为1 和0 的符号常量。包含该头文件后，写出的代码可以与C++兼容，因为C++把bool 、true 和false 定义为关键字。
## 优先级和关系运算符
关系运算符的优先级比算术运算符（包括+和-）低，比赋值运算符高。
关系运算符之间有两种不同的优先级。
高优先级组： `< <= > >=`
低优先级组： `== !=`
与其他大多数运算符一样，关系运算符的结合律也是从左往右。
## 不确定循环和计数循环
一些while 循环是不确定循环 （indefinite loop ）。所谓不确定循环，指在测试表达式为假之前，预先不知道要执行多少次循环。另外，还有一类是计数循环 （counting loop ）。这类循环在执行循环之前就知道要重复执行多少次。
在创建一个重复执行固定次数的循环中涉及了3个行为： 
1．必须初始化计数器； 2．计数器与有限的值作比较； 3．每次循环时递增计数器。
# for 循环

for 循环的第1行的三个表达式包含了循环所需的所有信息：计数器的初值， 计数器的终值 和每次循环计数器的增量。
for 循环把上述3个行为（初始化、测试和更新）组合在一处。
## 语法要点
**形式：**
```c
for ( initialize ; test ; update ) 
{
statement
}
```
**解释：**
for 语句使用3个表达式控制循环过程，分别用分号隔开。 initialize 表达式在执行for 语句之前只执行一次；然后对 test 表达式求值，如果表达式为真（或非零），执行循环一次；接着对 update 表达式求值，并再次检查 test 表达式。for 语句是一种入口条件循环，即在执行循环之前就决定了是否执行循环。因此，for 循环可能一次都不执行。 statement 部分可以是一条简单语句或复合语句。

第3个表达式可以使用任意合法的表达式。无论是什么表达式， 每次迭代都会更新该表达式的值。
可以省略一个或多个表达式（但是不能省略分号），只要在循环中包含能结束循环的语句即可。
第1个表达式不一定是给变量赋初值，也可以使用printf() 。记住，在执行循环的其他部分之前，只对第1个表达式求值一次或执行一次。
循环体中的行为可以改变循环头中的表达式。

# 其他赋值运算符：+= 、-= 、*= 、/= 、%=
**解释：**
```
scores += 20 与 scores = scores + 20 相同
dimes -= 2 与 dimes = dimes - 2 相同
bunnies *= 2 与 bunnies = bunnies * 2 相同
time /= 2.73 与 time = time / 2.73 相同
reduce %= 3 与 reduce = reduce % 3 相同
```
以上提到的赋值运算符与=的优先级相同，即比+ 或*优先级低。
并非一定要使用这些组合形式的赋值运算符。但是，它们让代码更紧凑，而且与一般形式相比，组合形式的赋值运算符生成的机器代码更高效。当需要在for 循环中塞进一些复杂的表达式时，这些组合的赋值运算符特别有用。
## 逗号运算符
逗号运算符并不局限于在for 循环中使用，但是这是它最常用的地方。逗号运算符有两个其他性质。首先，它保证了被它分隔的表达式从左往右求值（换言之，逗号是一个序列点，所以逗号左侧项的所有副作用都在程序执行逗号右侧项之前发生）。
其次，整个逗号表达式的值是右侧项的值。例如，下面语句
```
x = (y = 3, (z = ++y + 2) + 5);
```
效果是：先把3 赋给y ，递增y 为4 ，然后把4 加2 之和（6 ） 赋给z ，接着加上5 ，最后把结果11 赋给x 。
另一方面，假设在写数字时不小心输入了逗号：
```c
houseprice = 249,500;
```
这不是语法错误，C编译器会将其解释为一个逗号表达式，即 houseprice = 249 是逗号左侧的子表达式，500 是右侧的子表达式。因此，整个逗号表达式的值是逗号右侧表达式的值，而且左侧的小结：新的运算符赋值表达式把249 赋给变量houseprice 。
因此，这与下面代码的效果相同：
```c
houseprice = 249;
500;
```
另外，下面的语句:
```c
houseprice = (249,500);
```
赋给houseprice 的值是逗号右侧子表达式的值，即500 。
逗号也可用作分隔符。在下面语句中的逗号都是分隔符，不是逗号运算符：
```c
char ch, date;
printf("%d %d\n", chimps, chumps);
```

# 出口条件循环：do while
while 循环和for 循环都是入口条件循环，即在循环的每次迭代之前检查测试条件，所以有可能根本不执行循环体中的内容。C语言还有出口条件循环 （exit-condition loop ），即在循环的每次迭代之后检查测试条件，这保证了至少执行循环体中的内容一次。这种循环被称为do while 循环。
格式：
```
do
{
statement 
}
while ( expression );
```
do while 循环适用于那些至少要迭代一次的循环。例如，下面是一个包含do while 循环的密码程序伪代码：
```
do
{
提示用户输入密码
读取用户输入的密码
} while
(用户输入的密码不等于密码);
```
避免使用这种形式的do　while 结构：
```
do
{
询问用户是否继续
其他行为
} while (回答是yes);
```
# 如何选择循环
如何选择使用哪一种循环？首先，确定是需要入口条件循环还是出口条件循环。通常，入口条件循环用得比较多，有几个原因。其一，一般原则是在执行循环之前测试条件比较好。其二，测试放在循环的开头，程序的可读性更高。另外，在许多应用中，要求在一开始不满足测试条件时就直接跳过整个循环。
那么，假设需要一个入口条件循环，用for 循环还是while 循环？这取决于个人喜好，因为二者皆可。要让for 循环看起来像 while 循环，可以省略第1个和第3个表达式。例如：
```c
for ( ; test; )
```
与下面的while 效果相同：
```c
while ( test )
```
要让while 循环看起来像for 循环，可以在while 循环的前面初始化变量，并在while 循环体中包含更新语句。例如：
```
初始化;
while ( 测试 )
{
其他语句
更新语句
}
```
与下面的for 循环效果相同：
```
for ( 初始化 ;测试 ; 更新 )
其他语句
```
一般而言，当循环涉及初始化和更新变量时，用for 循环比较合适，而在其他情况下用while 循环更好。对于涉及索引计数的循环，用for 循环更适合。
# 数组简介
数组 （array ）是按顺序储存的一系列类型相同的值，如10个 char 类型的字符或15个int 类型的值。整个数组有一个数组名，通过整数下标访问数组中单独的项或元素 （element ）。
例如，以下声明：
```c
float debts[20];
```
声明debts 是一个内含20个元素的数组，每个元素都可以储存 float 类型的值。数组的第1个元素是debts\[0] ，第2个元素是 debts\[1] ，以此类推，直到debts\[19] 。注意，数组元素的编号从0 开始，不是从1 开始。可以给每个元素赋float 类型的值。例如，可以这样写：
```c
debts[5] = 32.54;
debts[6] = 1.2e+21;
```
实际上，使用数组元素和使用同类型的变量一样。
这里要注意一个潜在的陷阱：考虑到影响执行的速度，C编译器不会检查数组的下标是否正确。编译器不会查找这样的错误。当运行程序时，这会导致数据被放置在已被其他数据占用的地方，可能会破坏程序的结果甚至导致程序异常中断。
数组的类型可以是任意数据类型。
可以把字符串储存在char 类型的数组中,如果char 类型的数组末尾包含一个表示字符串末尾的空字符 \0 ，则该数组中的内容就构成了一个字符串。
用于识别数组元素的数字被称为下标 （subscript ）、索引 （indice ）或偏移量 （offset ）。下标必须是整数，而且要从0 开始计数。数组的元素被依次储存在内存中相邻的位置。
# 模块化原则(modularity)
模块化隐含的思想是：应该把程序划分为一些独立的单元，每个单元执行一个任务。这样做提高了程序的可读性。也许更重要的是，模块化使程序的不同部分彼此独立，方便后续更新或修改程序。在掌握如何使用函数后，可以把每个执行任务的单元放进函数中，提高程序的模块化。
# 使用函数返回值的循环示例
```c
// power.c -- 计算数的整数幂
#include <stdio.h>
double power(double n, int p); // ANSI函数原型
int main(void)
{
double x, xpow;
int exp;
printf("Enter a number and the positive integer power");
printf(" to which\nthe number will be raised. Enter q");
printf(" to quit.\n");
while (scanf("%lf%d", &x, &exp) == 2)
{
xpow = power(x, exp); // 函数调用
printf("%.3g to the power %d is %.5g\n", x, exp, xpow);
printf("Enter next pair of numbers or q to quit.\n");
}
printf("Hope you enjoyed this power trip -- bye!\n");
return 0;
}
double power(double n, int p) // 函数定义
{
double pow = 1;
int i;
for (i = 1; i <= p; i++)
pow *= n;
return pow; // 返回pow的值
}
```
## 程序分析
该程序示例中的main() 是一个驱动程序 （driver ），即被设计用来测试函数的小程序。
该例的while 循环是前面讨论过的一般形式。输入1.2 12 ， scanf() 成功读取两值，并返回2 ，循环继续。因为scanf() 跳过空白，所以可以像输出示例那样，分多行输入。但是输入q 会使 scanf() 的返回值为0 ，因为q 与scanf() 中的转换说明%1f 不匹配。scanf() 将返回0 ，循环结束。类似地，输入2.8 q 会使 scanf() 的返回值为1 ，循环也会结束。
现在分析一下与函数相关的内容。power() 函数在程序中出现了 3次。首次出现是：
```c
double power(double n, int p); // ANSI函数原型
```
这是power() 函数的原型，它声明程序将使用一个名为 power() 的函数。开头的关键字double 表明power() 函数返回一个double 类型的值。编译器要知道power() 函数返回值的类型，才能知道有多少字节的数据，以及如何解释它们。这就是为什么必须声明函数的原因。圆括号中的double n, int p 表示power() 函数的两个参数。第1个参数应该是double 类型的值，第2个参数应该是 int 类型的值。
第2次出现是：
```c
xpow = power(x,exp); // 函数调用
```
程序调用power() ，把两个值传递给它。该函数计算x 的exp 次幂，并把计算结果返回给主调函数。在主调函数中，返回值将被赋给变量xpow 。
第3次出现是：
```c
double power(double n, int p) // 函数定义
```
这里，power() 有两个形参，一个是double 类型，一个是int 类型，分别由变量n 和变量p 表示。注意，函数定义的末尾没有分号，而函数原型的末尾有分号。在函数头后面花括号中的内容，就是 power() 完成任务的代码。 power() 函数用for 循环计算n 的p 次幂，并把计算结果赋给 pow ，然后返回pow 的值，如下所示：
```c
return pow; //返回pow的值
```
## 怎么使用带返回值的函数
既然在使用函数返回值之前要声明函数，那么为什么在使用scanf() 的返回值之前没有声明 scanf() ？为什么在定义中说明了power() 的返回类型为double ，还要单独声明这个函数？
回答：编译器在程序中首次遇到power() 时， 需要知道power() 的返回类型。此时，编译器尚未执行到power() 的定义，并不知道函数定义中的返回类型是double 。因此，必须通过前置声明 （forward declaration ）预先说明函数的返回类型。前置声明告诉编译器，power() 定义在别处，其返回类型为double 。如果把power() 函数的定义置于main() 的文件顶部，就可以省略前置声明，因为编译器在执行到main() 之前已经知道power() 的所有信息。但是，这不是C的标准风格。因为main() 通常只提供整个程序的框架，最好把main() 放在所有函数定义的前面。另外，通常把函数放在其他文件中，所以前置声明必不可少。
接下来，为什么不用声明scanf() 函数就可以使用它？其实，你已经声明了。stdio.h 头文件中包含了scanf() 、printf() 和其他I/O函数的原型。scanf() 函数的原型表明，它返回的类型是int
