# if 语句
## if else 语句
简单形式的if 语句可以让程序选择执行一条语句，或者跳过这条语句。C还提供了if else 形式，可以在两条语句之间作选择。
注意，if else 语句的通用形式是：
```c
if ( expression)
{
statement1
}
else
{
statement2
}
```
示例：介绍getchar() 和putchar()
getchar() 函数不带任何参数，它从输入队列中返回下一个字符。例如，下面的语句读取下一个字符输入，并把该字符的值赋给变量ch ：
```c
ch = getchar();
```
该语句与下面的语句效果相同：
```c
scanf("%c", &ch);
```
putchar() 函数打印它的参数。例如，下面的语句把之前赋给 ch 的值作为字符打印出来：
```c
putchar(ch);
```
该语句与下面的语句效果相同：
```c
printf("%c", ch);
```
由于这些函数只处理字符，所以它们比更通用的scanf() 和 printf() 函数更快、更简洁。而且，注意getchar() 和 putchar() 不需要转换说明，因为它们只处理字符。这两个函数通常定义在stdio.h 头文件中，而且，它们通常是预处理宏 ，而不是真正的函数。
以下是一个演示这两个函数的程序：
```c
// cypher1.c -- 更改输入，空格不变
#include <stdio.h>
#define SPACE ' ' // SPACE表示单引号-空格-单引号
int main(void)
{
char ch;
ch = getchar(); // 读取一个字符
while (ch != '\n') // 当一行未结束时
{
if (ch == SPACE) // 留下空格
putchar(ch); // 该字符不变
else
putchar(ch + 1); // 改变其他字符
ch = getchar(); // 获取下一个字符
}
putchar(ch); // 打印换行符
return 0;
}
```
该程序的输入示例：
```
CALL ME HAL.

DBMM NF IBM/
```
C的语法比较灵活，也可以把读取和测试合并成一个表达式。也就是说，可以把这种形式的循环：
```c
ch = getchar(); /* 读取一个字符 */
while (ch != '\n') /* 当一行未结束时 */
{
..． /* 处理字符 */
ch = getchar(); /* 获取下一个字符 */
}
```
替换成下面形式的循环：
```c
while ((ch = getchar()) != '\n')
{
..． /* 处理字符 */
}
```
这体现了C特有的编程风格——把两个行为合并成一个表达式。
关键的一行解释：
```
while ((ch = getchar()) != '\n')
```
以上执行的行为是赋值给ch 和把ch 的值与换行符作比较。表达式ch = getchar() 两侧的圆括号使之成为!= 运算符的左侧运算对象。要对该表达式求值，必须先调用getchar() 函数，然后把该函数的返回值赋给ch 。因为赋值表达式的值是赋值运算符左侧运算对象的值，所以ch = getchar() 的值就是ch 的新值，因此，读取ch 的值后，测试条件相当于是ch != '\n' （即，ch 不是换行符）。
## ctype.h 系列的字符函数
C有一系列专门处理字符的函数，ctype.h 头文件包含了这些函数的原型。这些函数接受一个字符作为参数，如果该字符属于某特殊的类别，就返回一个非零值 （真）；否则，返回0（假）。例如，如果isalpha() 函数的参数是一个字母，则返回一个非零值。
下表列出了ctype.h 头文件中的一些函数。有些函数涉及本地化，指的是为适应特定区域的使用习惯修改或扩展C基本用法的工具（例如，许多国家在书写小数点时，用逗号代替点号，于是特殊的本地化可以指定C编译器使用逗号以相同的方式输出浮点数，这样123.45 可以显示为123,45 ）。注意，字符映射函数不会修改原始的参数，这些函数只会返回已修改的值。

| 函数名        | 如果是下列参数时，返回值为真                              |
| ---------- | ------------------------------------------- |
| isalnum()  | 字母数字（字母或数字）                                 |
| isalpha()  | 字母                                          |
| isblank()  | 标准的空白字符（空格、水平制表符或换行符）或任何其他本地化指定为空白的字符       |
| iscntrl()  | 控制字符，如Ctrl+B                                |
| isdigit()  | 数字                                          |
| isgraph()  | 除空格之外的任意可打印字符                               |
| islower()  | 小写字母                                        |
| isprint()  | 可打印字符                                       |
| ispunct()  | 标点符号（除空格或字母数字字符以外的任何可打印字符）                  |
| isspace()  | 空白字符（空格、换行符、换页符、回车符、垂直制表符、水平制表符或其他本地化定义的字符） |
| isupper()  | 大写字母                                        |
| isxdigit() | 十六进制数字符                                     |

| 函数名       | 行为                            |
| --------- | ----------------------------- |
| tolower() | 如果参数是大写字符，该函数返回小写字符；否则，返回原始参数 |
| toupper() | 如果参数是小写字符，该函数返回大写字符；否则，返回原始参数 |
## 多重选择else if
示例：
```c
// electric.c -- 计算电费
#include <stdio.h>
#define RATE1 0.13230 // 首次使用 360 kwh 的费率
#define RATE2 0.15040 // 接着再使用 108 kwh 的费率
#define RATE3 0.30025 // 接着再使用 252 kwh 的费率
#define RATE4 0.34025 // 使用超过 720kwh 的费率
#define BREAK1 360.0 // 费率的第1个分界点
#define BREAK2 468.0 // 费率的第2个分界点
#define BREAK3 720.0 // 费率的第3个分界点
#define BASE1 (RATE1 * BREAK1) // 使用360kwh的费用
#define BASE2 (BASE1 + (RATE2 * (BREAK2 - BREAK1)))
// 使用468kwh的费用
#define BASE3 (BASE1 + BASE2 + (RATE3 *(BREAK3 - BREAK2))) //使用720kwh的费用
int main(void)
{
double kwh; // 使用的千瓦时
double bill; // 电费
printf("Please enter the kwh used.\n");
scanf("%lf", &kwh); // %lf对应double类型
if (kwh <= BREAK1)
bill = RATE1 * kwh;
else if (kwh <= BREAK2) // 360～468 kwh
bill = BASE1 + (RATE2 * (kwh - BREAK1));
else if (kwh <= BREAK3) // 468～720 kwh
bill = BASE2 + (RATE3 * (kwh - BREAK2));
else // 超过 720 kwh
bill = BASE3 + (RATE4 * (kwh - BREAK3));
printf("The charge for %.1f kwh is $%1.2f.\n", kwh, bill);
return 0;
}
```
实际上，else　if 是已学过的if　else 语句的变式。例如，该程序的核心部分只不过是下面代码的另一种写法：
```c
if (kwh <= BREAK1)
bill = RATE1 * kwh;
else
  if (kwh <= BREAK2) // 360～468 kwh
  bill = BASE1 + (RATE2 * (kwh - BREAK1));
  else
   if (kwh <= BREAK3) // 468～720 kwh
   bill = BASE2 + (RATE3 * (kwh - BREAK2));
   else // 超过720 kwh
   bill = BASE3 + (RATE4 * (kwh - BREAK3));
```
也就是说，该程序由一个if else 语句组成，else 部分包含另一个if else 语句，该if else 语句的else 部分又包含另一个ifelse 语句。第2个if else 语句嵌套 在第 1个if　else 语句中，第3个if　else 语句嵌套在第2个if　else 语句中。回忆一下，整个if　else 语句被视为一条语句，因此不必把嵌套的if　else 语句用花括号括起来。当然，花括号可以更清楚地表明这种特殊格式的含义。
这两种形式完全等价。唯一不同的是使用空格和换行的位置不同，不过编译器会忽略这些。尽管如此，第1种形式还是好些，因为这种形式更清楚地显示了有4种选择。在浏览程序时，这种形式让读者更容易看清楚各项选择。
可以把多个else if 语句连成一串使用，如下所示（当然，要在编译器的限制范围内）：
```c
if (score < 1000)
bonus = 0;
else if (score < 1500)
bonus = 1;
else if (score < 2000)
bonus = 2;
else if (score < 2500)
bonus = 4;
else
bonus = 6;
```
对于编译器的限制范围，C99标准要求编译器最少支持127层套嵌。
## else 与if 配对
规则是，如果没有花括号，else 与离它最近的if 匹配，除非最近的if 被花括号括起来
示例：
```c
if （条件）
语句
if （条件）
语句
else
语句
//else与第二个if配对
```

```c
if （条件）
{
语句
if （条件）
语句
}
else
语句
//else与第一个if配对
```
注意：要缩进“语句”，“语句”可以是一条简单语句或复合语句。第1个例子的缩进使得else 看上去与第1个if 相匹配，但是记住，编译器是忽略缩进的。如果希望else 与第1个if 匹配，应该写成第二个例子的样子。
## 多层嵌套的if 语句
示例：
```c
// divisors.c -- 使用嵌套if语句显示一个数的约数
#include <stdio.h>
#include <stdbool.h>//使我们能用bool 代替_Bool 类型，用true 和false 分别代替1 和0 
int main(void)
{
unsigned long num; // 待测试的数
unsigned long div; // 可能的约数
bool isPrime; // 素数标记
printf("Please enter an integer for analysis; ");
printf("Enter q to quit.\n");
while (scanf("%lu", &num) == 1)
{
for (div = 2, isPrime = true; (div * div) <= num; div++)/*给isprime初始化为true
{
if (num % div == 0)
{
if ((div * div) != num)
printf("%lu is divisible by %lu and %lu.\n",
num, div, num / div);
else
printf("%lu is divisible by %lu.\n",
num, div);
isPrime = false; // 该数不是素数
}
}
if (isPrime)
printf("%lu is prime.\n", num);
printf("Please enter another integer for analysis; ");
printf("Enter q to quit.\n");
}
printf("Bye.\n");
return 0;
}
```
**注意：从技术角度看，if else 语句作为一条单独的语句，不必使用花括号。外层if 也是一条单独的语句，也不必使用花括号。但是，当语句太长时，使用花括号能提高代码的可读性，而且还可防止今后在if 循环中添加其他语句时忘记加花括号。**
分析：可以在外层循环把一个变量设置为某个值（如，1 ），然后在if 语句中把该变量重新设置为0 。循环完成后，检查该变量是否是1 ，如果是，说明没有进入if 语句，那么该数就是素数。这样的变量通常称为标记 （flag ）。从而判断num是不是素数。
isprime初始化为true可以防止一开始就出现素数导致程序出错。
该程序会把1 认为是素数，其实它不是，可以排除这个bug。

# 逻辑运算符
逻辑运算符的优先级比关系运算符低，所以不必在子表达式两侧加圆括号。
C有3种逻辑运算符，与&& ，或||，非! 

假设exp1 和exp2 是两个简单的关系表达式，那么：
且仅当exp1 和exp2 都为真时，exp1 && exp2 才为真；
如果exp1 或exp2 为真，则exp1 || exp2 为真；
如果exp1 为假，则!exp1 为真；如果exp1 为真，则!exp1 为假。
## 备选拼写：iso646.h 头文件
C是在美国用标准美式键盘开发的语言。但是在世界各地，并非所有的键盘都有和美式键盘一样的符号。因此，C99标准新增了可代替逻辑运算符的拼写，它们被定义在iso646.h 头文件中。如果在程序中包含该头文件，便可用and 代替&& 、or 代替|| 、not 代替! 。
为何C不直接使用and 、or 和not ？因为C一直坚持尽量保持较少的关键字。
## 优先级
!运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低。&& 运算符的优先级比|| 运算符高，但是两者的优先级都比关系运算符低，比赋值运算符高。
许多程序员更喜欢使用带圆括号的写法。这样做即使不记得逻辑运算符的优先级，表达式的含义也很清楚。
## 求值顺序
除了两个运算符共享一个运算对象的情况外，C通常不保证先对复杂表达式中哪部分求值。C把先计算哪部分的决定权留给编译器的设计者，以便针对特定系统优化设计。但是，对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右。&& 和|| 运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。而且，==C保证一旦发现某个元素让整个表达式无效，便立即停止求值。==
例如：
```c
if (number != 0 && 12/number == 2)
printf("The number is 5 or 6.\n");
```
如果number 的值是0 ，那么第1个子表达式为假，且不再对关系表达式求值。这样避免了把0 作为除数。许多语言都没有这种特性， 知道number 为0 后，仍继续检查后面的条件。
```c
while ( x++ < 10 && x + y < 20)
```
实际上，&& 是一个序列点，这保证了在对&& 右侧的表达式求值之前，已经递增了x 。
## 范围
&& 运算符可用于测试范围。例如，要测试score 是否在90 ～ 100 的范围内，可以这样写：
```c
if (range >= 90 && range <= 100) 
	printf("Good show!\n");
```
千万不要模仿数学上的写法：
```c
if (90 <= range <= 100) // 千万不要这样写！
	printf("Good show!\n");
```
这样写的问题是代码有语义错误，而不是语法错误，所以编译器不会捕获这样的问题（虽然可能会给出警告）。由于<=运算符的求值顺序是从左往右，所以编译器把测试表达式解释为：
```c
90 <= range) <= 100
```
子表达式90 <= range 的值要么是1 （为真），要么是0 （为假）。这两个值都小于100 ，所以不管range 的值是多少，整个表达式都恒为真。因此，在范围测试中要使用&& 。
# 知识应用：一个统计单词的程序
## 分析：
我们暂时选用一个文本中不常用的字符（如，|）作为输入的末尾标记。
为了统计行数，程序要能检查换行字符。如果输入的字符是一个换行符，该程序应该递增行数计数器。这里要注意STOP 字符位于一行的中间的情况。是否递增行数计数？我们可以作为特殊行计数，即没有换行符的一行字符。可以通过记录之前读取的字符识别这种情况，即如果读取时发现STOP 字符的上一个字符不是换行符，那么这行就是特殊行。
最棘手的部分是识别单词。首先，必须定义什么是该程序识别的单词。我们用一个相对简单的方法，把一个单词定义为一个不含空白 （即，没有空格、制表符或换行符）的字符序列。使用ctype.h 头文件中的函数isspace()即可判断是否为空白字符。
要查找一个单词里是否有某个字符，可以在程序读入单词的首字符时把一个标记（名为inword ）设置为1 。也可以在此时递增单词计数。然后，只要inword 为1 （或true ），后续的非空白字符都不记为单词的开始。下一个空白字符，必须重置标记为0 （或false ），然后程序就准备好读取下一个单词。
## 代码：
```c
// wordcnt.c -- 统计字符数、单词数、行数
#include <stdio.h>
#include <ctype.h> // 为isspace()函数提供原型
#include <stdbool.h> // 为bool、true、false提供定义
#define STOP '|'
int main(void)
{
char c; // 读入字符
char prev; // 读入的前一个字符
long n_chars = 0L; // 字符数
int n_lines = 0; // 行数
int n_words = 0; // 单词数
int p_lines = 0; // 不完整的行数
bool inword = false; // 如果c在单词中，inword 等于 true
printf("Enter text to be analyzed (| to terminate):\n");
prev = '\n'; // 用于识别完整的行
while ((c = getchar()) != STOP)
{
n_chars++; // 统计字符
if (c == '\n')
n_lines++; // 统计行
if (!isspace(c) && !inword)
{
inword = true; // 开始一个新的单词
n_words++; // 统计单词
}
if (isspace(c) && inword)
inword = false; // 达到单词的末尾
prev = c; // 保存字符的值
}
if (prev != '\n')
p_lines = 1;
printf("characters = %ld, words = %d, lines = %d, ",
n_chars, n_words, n_lines);
printf("partial lines = %d\n", p_lines);
return 0;
}
```
# 条件运算符：? :
提供条件表达式 （conditional expression ）作为表达if else 语句的一种便捷方式，该表达式使用?:条件运算符。该运算符分为两部分，需要3个运算对象。条件运算符是C语言中唯一的三元运算符。下面的代码得到一个数的绝对值：
```c
x = (y < 0) ? -y : y;
```
在= 和; 之间的内容就是条件表达式，该语句的意思是“如果y 小于0 ，那么x = -y; 否则，x = y ”。用if else 可以这样表达：
```c
if (y < 0) 
	x = -y; 
else
	x = y;
```
条件表达式的通用形式如下：
```
expression1 ? expression2 : expression3
```
如果 expression1 为真（非0 ），那么整个条件表达式的值与 expression2 的值相同；如果 expression1 为假（0 ），那么整个条件表达式的值与 expression3 的值相同。
需要把两个值中的一个赋给变量时，就可以用条件表达式。典型的例子是，把两个值中的最大值赋给变量：
```c
max = (a > b) ? a : b;
```
通常，条件运算符完成的任务用if else 语句也可以完成。但是，使用条件运算符的代码更简洁，而且编译器可以生成更紧凑的程序代码。
# 循环辅助：continue 和break
## continue 语句
3种循环都可以使用continue 语句。执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。如果continue 语句在嵌套循环内，则只会影响包含该语句的内层循环。
示例：
```c
/* skippart.c -- 使用continue跳过部分循环 */
#include <stdio.h>
int main(void)
{
const float MIN = 0.0f;
const float MAX = 100.0f;
float score;
float total = 0.0f;
int n = 0;
float min = MAX;
float max = MIN;
printf("Enter the first score (q to quit): ");
while (scanf("%f", &score) == 1)
{
if (score < MIN || score > MAX)
{
printf("%0.1f is an invalid value. Try again:
",score);
continue; // 跳转至while循环的测试条件
}
printf("Accepting %0.1f:\n", score);
min = (score < min) ? score : min;
max = (score > max) ? score : max;
total += score;
n++;
printf("Enter next score (q to quit): ");
}
if (n > 0)
{
printf("Average of %d scores is %0.1f.\n", n, total / n);
printf("Low = %0.1f, high = %0.1f\n", min, max);
}
else
printf("No valid scores were entered.\n");
return 0;
}
```
注意，有两种方法可以避免使用continue ，一是省略continue ，把剩余部分放在一个else 块中：
```c
if (score < 0 || score > 100)
/* printf()语句 */
else
{
/* 语句*/
}
```
另一种方法是，用以下格式来代替：

```c
if (score >= 0 && score <= 100)
{
/* 语句 */
}
```
这种情况下，使用continue 的好处是减少主语句组中的一级缩进。当语句很长或嵌套较多时，紧凑简洁的格式提高了代码的可读性。
continue 还可用作占位符。例如，下面的循环读取并丢弃输入的数据，直至读到行末尾：
```c
while (getchar() != '\n')
;
```
当程序已经读取一行中的某些内容，要跳至下一行开始处时，这种用法很方便。问题是，一般很难注意到一个单独的分号。如果使用continue ，可读性会更高：
```c
while (getchar() != '\n')
continue;
```
如果用了continue 没有简化代码反而让代码更复杂，就不要使用continue 。例如，考虑下面的程序段：
```c
while ((ch = getchar() ) != '\n')
{
if (ch == '\t')
continue;
putchar(ch);
}
```
该循环跳过制表符，并在读到换行符时退出循环。以上代码这样表示更简洁：
```c
while ((ch = getchar()) != '\n')
if (ch != '\t')
putchar(ch);
```
通常，在这种情况下，把if 的测试条件的关系反过来便可避免使用continue 。

对于while 和do　while 循环，执行continue 语句后的下一个行为是对循环的测试表达式求值。对于for 循环，执行continue 后的下一个行为是对更新表达式求值，然后是对循环测试表达式求值。
## break 语句
程序执行到循环中的break 语句时，会终止包含它的循环，并继续执行下一阶段。如果break 语句位于嵌套循环内， 它只会影响包含它的当前循环。
示例：
```c
/* break.c -- 使用 break 退出循环 */
#include <stdio.h>
int main(void)
{
float length, width;
printf("Enter the length of the rectangle:\n");
while (scanf("%f", &length) == 1)
{
printf("Length = %0.2f:\n", length);
printf("Enter its width:\n");
if (scanf("%f", &width) != 1)
break;
printf("Width = %0.2f:\n", width);
printf("Area = %0.2f:\n", length * width);
printf("Enter the length of the rectangle:\n");
}
printf("Done.\n");
return 0;
}
```
如果用户输入非数字作为矩形的长或宽，则终止循环。
和continue 一样，如果用了break 代码反而更复杂，就不要使用break 。例如，考虑下面的循环：
```c
while ((ch = getchar()) != '\n')
{
if (ch == '\t')
break;
putchar(ch);
}
```
如果把两个测试条件放在一起，逻辑就更清晰了
```c
while ((ch = getchar() ) != '\n' && ch != '\t')
putchar(ch);
```
## 多重选择：switch 和break
使用条件运算符和if else 语句很容易编写二选一的程序。然而，有时程序需要在多个选项中进行选择。可以用if else if...else 来完成。但是，大多数情况下使用switch 语句更方便。
break 语句可用于循环和switch 语句中，但是 continue 只能用于循环中。
switch 在圆括号中的测试表达式的值应该是一个整数值（包括 char 类型）。case 标签必须是整数类型（包括char 类型）的常量或整型常量表达式（即，表达式中只包含整型常量）。不能用变量作为case 标签。switch 的构造如下：
```c
switch ( 整型表达式)
{
case 常量1:
语句 <--可选
case 常量2:
语句 <--可选
default : 　　 <--可选
语句 <--可选
}
```
可以有多个标签语句
### switch 和if　else
如果是根据浮点类型的变量或表达式来选择，就无法使用switch 。如果根据变量在某范围内决定程序流的去向，使用switch 就很麻烦，这种情况用if 就很方便：
```c
if (integer < 1000 && integer > 2)
```
使用switch 要涵盖以上范围，需要为每个整数（3 ～999 ）设置case 标签。但是，如果使用switch ，程序通常运行快一些，生成的代码少一些。
## goto 语句
早期版本的BASIC和FORTRAN所依赖的goto 语句，在C中仍然可用。但是C和其他两种语言不同，没有goto 语句C程序也能运行良好。Kernighan和Ritchie提到goto 语句“易被滥用”，并建议“谨慎使用，或者根本不用”。
goto 语句有两部分：goto 和标签名。标签的命名遵循变量命名规则，如下所示：
```c
goto part2;
```
要让这条语句正常工作，函数还必须包含另一条标为part2 的语句，该语句以标签名后紧跟一个冒号开始：
```c
part2: printf("Refined analysis:\n");
```
## 避免使用goto
原则上，根本不用在C程序中使用goto 语句。但是，如果你曾经学过FORTRAN或BASIC（goto 对这两种语言而言都必不可少），可能还会依赖用goto 来编程。
**处理包含多条语句的if 语句：**
```c
if (size > 12)
　 goto a;
goto b;
a: cost = cost * 1.05;
flag = 2;
b: bill = cost * flag;
```
对于以前的BASIC和FORTRAN，只有直接跟在if 条件后面的一条语句才属于if ，不能使用块或复合语句。我们把以上模式转换成等价的C代码，标准C用复合语句或块来处理这种情况：
```c
if (size > 12)
{
　 cost = cost * 1.05;
　 flag = 2;
}
bill = cost * flag;
```
**二选一：**
```c
if (ibex > 14)
　 goto a;
sheds = 2;
goto b;
a: sheds= 3;
b: help = 2 * sheds;
```
C通过if else 表达二选一更清楚：
```c
if (ibex > 14)
　 sheds = 3;
else
　 sheds = 2;
help = 2 * sheds;
```
**创建不确定循环：**
```c
readin: scanf("%d", &score);
if (score < O)
　 goto stage2;
lots of statements
goto readin;
stage2: more stuff;
```
C用while 循环代替：
```c
scanf("%d", &score);
while (score <= 0)
{
　 lots of statements
　 scanf("%d", &score);
}
more stuff;
```
跳转至循环末尾，并开始下一轮迭代。C使用continue 语句代替。跳出循环。C使用break 语句。实际上，break 和continue 是 goto 的特殊形式。使用break 和continue 的好处是：其名称已经表明它们的用法，而且这些语句不使用标签，所以不用担心把标签放错位置导致的危险。胡乱跳转至程序的不同部分。简而言之，不要这样做！

但是，C程序员可以接受一种goto 的用法——出现问题时从一组嵌套循环中跳出（一条break 语句只能跳出当前循环）：
```c
while (funct > 0)
{
for (i = 1, i <= 100; i++)
{
for (j = 1; j <= 50; j++)
{
其他语句
if (问题)
goto help;
其他语句
}
其他语句
}
其他语句
}
其他语句
help: 语句
```
从其他例子中也能看出，程序中使用其他形式比使用goto 的条理更清晰。当多种情况混在一起时，这种差异更加明显。哪些goto 语句可以帮助if 语句？哪些可以模仿if else ？哪些控制循环？哪些是因为程序无路可走才不得已放在那里？过度地使用goto 语句， 会让程序错综复杂。如果不熟悉goto 语句，就不要使用它。如果已经习惯使用goto 语句，试着改掉这个毛病。讽刺地是，虽然C根本不需要goto ，但是它的goto 比其他语言的goto 好用，因为C允许在标签中使用描述性的单词而不是数字。
# 小结
if 语句使用测试条件控制程序是否执行测试条件后面的一条简单语句或复合语句。如果测试表达式的值是非零值，则执行语句；如果测试表达式的值是零，则不执行语句。
if else 语句可用于二选一的情况。如果测试条件是非零，则执行else 前面的语句；如果测试表达式的值是零，则执行 else 后面的语句。
在else 后面使用另一个if 语句形成else if ，可构造多选一的结构。测试条件通常都是关系表达式 ，即用一个关系运算符（如，<或 \==）的表达式。
使用C的逻辑运算符，可以把关系表达式组合成更复杂的测试条件。在多数情况下，用条件运算符 （?: ）写成的表达式比if else 语句更简洁。 
ctype.h 系列的字符函数（如，issapce() 和isalpha() ） 为创建以分类字符为基础的测试表达式提供了便捷的工具。 
switch 语句可以在一系列以整数作为标签的语句中进行选择。如果紧跟在switch 关键字后的测试条件的整数值与某标签匹配，程序就转至执行匹配的标签语句，然后在遇到break 之前，继续执行标签语句后面的语句。
break 、continue 和goto 语句都是跳转语句，使程序流跳转至程序的另一处。break 语句使程序跳转至紧跟在包含break 语句的循环或switch 末尾的下一条语句。continue 语句使程序跳出当前循环的剩余部分，并开始下一轮迭代。
