ASCII码表格

| L \ H | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 0000  | NLL  | DLE  |  SP  |  0   |  @   |  P   |  '   |  p   |
| 0001  | SOH  | DC1  |  !   |  1   |  A   |  Q   |  a   |  q   |
| 0010  | STX  | DC2  |  "   |  2   |  B   |  R   |  b   |  r   |
| 0011  | ETX  | DC3  |  #   |  3   |  C   |  S   |  c   |  s   |
| 0100  | EOT  | DC4  |  $   |  4   |  D   |  T   |  d   |  t   |
| 0101  | ENQ  | MAK  |  %   |  5   |  E   |  U   |  e   |  u   |
| 0110  | ACK  | SYN  |  &   |  6   |  F   |  V   |  f   |  v   |
| 0111  | BEL  | ETB  |  -   |  7   |  G   |  W   |  g   |  w   |
| 1000  |  BS  | CAN  |  (   |  8   |  H   |  X   |  h   |  x   |
| 1001  |  HT  |  EM  |  )   |  9   |  I   |  Y   |  i   |  y   |
| 1010  |  LF  | SUB  |  *   |  :   |  J   |  Z   |  j   |  z   |
| 1011  |  VT  | ESC  |  +   |  :   |  K   |  [   |  k   |  {   |
| 1100  |  FF  |  FS  |  ,   |  <   |  L   |  \   |  l   |  }   |
| 1101  |  CR  |  GS  |  -   |  =   |  M   |  ]   |  m   |  }   |
| 1110  |  SO  |  RS  |  .   |  >   |  N   |  ^   |  n   |  ~   |
| 1111  |  SI  |  US  |  /   |  ?   |  O   |  _   |  o   | DEL  |
常用：
A=65(0100001),其余字母按顺序数值依次递增，小写字母=大写字母+32
0=48(0011000)，其他数字按顺序依次递增。
Unicode码兼容ASCII码

---
# 进制转换方法
## 其他进制转十进制
直接按位权与数字展开
## 十进制转其他进制
分开处理整数和小数部分
### A. 整数部分：**除基取余法**
1. 整数 ÷ 基数，得商和余数
2. 记录余数
3. 用商继续 ÷ 基数，重复直到商为0
4. 余数**从下往上**读取
### B. 小数部分：**乘基取整法**
1. 小数 × 基数，得乘积
2. 记录整数部分
3. 用小数部分继续 × 基数，重复直到小数部分为0或达到精度
4. 整数部分**从上往下**读取
## 二进制转八进制/十六进制
将二进制分为若干个组（3(8进制)/4(16进制)个数字，不足补上0）再进行转换
# 原码、反码与补码精要笔记
## 基本概念
### 原码
- **定义**：最高位为符号位（0正1负），其余位表示绝对值
- **示例**：
  - +1：`0000 0001`
  - -1：`1000 0001`
- **问题**：
  - 存在±0 (`0000 0000`和`1000 0000`)
  - 加法运算出错
### 反码
- **正数**：与原码相同
- **负数**：符号位不变，数值位取反
- **示例**：
  - -1：原码`1000 0001` → 反码`1111 1110`
- **改进**：部分解决加法问题
- **遗留问题**：仍存在±0
### 补码
- **正数**：与原码相同
- **负数**：反码+1
- **示例**：
  - -1：原码`1000 0001` → 反码`1111 1110` → 补码`1111 1111`
- **现代计算机标准**
## 核心原理
### 补码的精妙设计
- **数学基础**：模运算理论
- **负数表示**：`-X`的补码 = 模 - |X|
- **零的唯一性**：+0和-0补码相同 (`0000 0000`)
- **范围扩展**：将-0编码重用作-128
### 8位编码范围对比
| 编码方案 | 范围 | 零的表示 |
|---------|------|----------|
| 原码 | -127 ~ +127 | ±0 |
| 反码 | -127 ~ +127 | ±0 |
| 补码 | -128 ~ +127 | 唯一零 |
# C语言基本数据结构与运算笔记

## 一、基本数据类型

### 整型
```c
int a = 10;          // 基本整型
short b = 5;         // 短整型
long c = 1000L;      // 长整型
unsigned int d = 20; // 无符号整型
```
### 浮点型
```c
float f = 3.14f;     // 单精度
double g = 3.14159;  // 双精度
```
### 字符型
```c
char ch = 'A';       // 字符类型
```
## 二、派生数据结构
### 数组
```c
int arr[5] = {1,2,3,4,5};     // 一维数组
int matrix[2][3];             // 二维数组
char str[] = "Hello";         // 字符数组
```
### 指针
```c
int x = 10;
int *ptr = &x;       // 指针定义
*ptr = 20;          // 解引用
```
### 结构体
```c
struct Student {
    char name[20];
    int age;
    float score;
};
```
### 联合体
```c
union Data {
    int i;
    float f;
    char str[20];
};
```
## 三、基本运算

### 算术运算
```c
+  // 加法
-  // 减法  
*  // 乘法
/  // 除法
%  // 取模
```
### 关系运算
```c
==  // 等于
!=  // 不等于
<   // 小于
>   // 大于
<=  // 小于等于
>=  // 大于等于
```
### 逻辑运算
```c
&&  // 逻辑与
||  // 逻辑或
!   // 逻辑非
```
### 位运算
```c
&   // 按位与
|   // 按位或
^   // 按位异或
~   // 按位取反
<<  // 左移
>>  // 右移
num | (1 << n)// 设置位
num & ~(1 << n)// 清除位 
num ^ (1 << n)// 翻转位
num & (1 << n)// 检查位
```
### 赋值运算
```c
=   // 赋值
+=  // 加后赋值
-=  // 减后赋值
*=  // 乘后赋值
/=  // 除后赋值
```
### 自增自减
```c
i++  // 后置自增
++i  // 前置自增
i--  // 后置自减
--i  // 前置自减
```
## 四、运算符优先级（从高到低）

1. `()` `[]` `->` `.`
2. `!` `~` `++` `--` `*` `&` `(类型)`
3. `*` `/` `%`
4. `+` `-`
5. `<<` `>>`
6. `<` `<=` `>` `>=`
7. `==` `!=`
8. `&` `^` `|` `&&` `||`
9. `?:`
10. `=` `+=` `-=` 等
## 五、关键要点

- **数据类型大小**：`char(1B)` < `short(2B)` ≤ `int(4B)` ≤ `long(4-8B)`
    
- **指针运算**：指针加减以数据类型大小为步长
    
- **结构体对齐**：成员按最大类型对齐
    
- **联合体特性**：所有成员共享同一内存空间
    
- **位运算应用**：标志位操作、权限控制、加密算法
# 第三章：控制语句
## 选择结构

### **if语句**
```c
if (condition) { ... }
else if (condition) { ... }
else { ... }

```
**注意**：else的最近匹配原则
### **switch语句**
```c
switch (expr) {
    case constant1: ... break;
    case constant2: ... break;
    default: ... break;
}
```
**注意**：`break`防止case穿透
## 循环结构
```c
// for循环：已知循环次数
for (初始化; 循环条件; 增量) { ... }
// while循环：先判断后执行  
while (循环条件) { ... }
// do-while循环：至少执行一次
do { ... } while (循环条件);
```
### **循环控制**
- `break`：跳出整个循环
- `continue`：结束本次循环，进入下一次
# 第四章：数组与结构

## 数组
### **一维数组**
```c
int a[10]; // 元素连续存放
```
数组名在多数情况下表示首元素地址：`a` ≡ `&a[0]`
### **二维数组**
```c
int b[3][4]; // 按行存储
```
### **字符数组与字符串**
```c
char str[] = "Hello"; // 以'\0'结束
```
常用字符串函数：`strlen`, `strcpy`, `strcmp`, `strcat`
## 结构体
```c
struct Student {
    int id;
    char name[20];
    float score;
};
struct Student stu1;
stu1.id = 1001; // 访问成员
```
# 第五章：栈与队列
## 栈（后进先出LIFO）
**基本操作**：`Push`(入栈), `Pop`(出栈), `GetTop`(获取栈顶)
**实现方式**：
- 顺序栈（数组）
    
- 链栈
    
## 队列（先进先出FIFO）
**基本操作**：`EnQueue`(入队), `DeQueue`(出队), `GetHead`(获取队头)
**实现方式**：
- 顺序队列（存在假溢出）
- **循环队列**（解决假溢出）
    - 判空：`front == rear`
    - 判满：`(rear + 1) % MAXSIZE == front`
- 链队列
# 第六章：指针
## 基本概念
```c
int a = 10;
int *p = &a;    // p指向a的地址
*p = 20;        // 等价于 a = 20
```
## 指针运算
- 加减整数（移动指针）
- 关系运算（比较地址高低）
## 指针与数组
```c
int a[10];
a[i] ≡ *(a + i) // 核心关系
```
## 指针与函数
```c
// 传址调用
void swap(int *a, int *b) { ... }
// 函数指针
int (*pf)(int, int) = &max;
```
## 指针与字符串
```c
char *str1 = "Hello";   // 字符串常量，不可修改
char str2[] = "World";  // 字符数组，可以修改
```
## 动态内存分配
```c
int *p = (int*)malloc(10 * sizeof(int));
// 使用p...
free(p); // 必须释放！
```
# 第七章：位运算精要
## 核心位操作模式
```c
// 判断是否为2的幂
(n > 0) && ((n & (n-1)) == 0)
// 获取最低位的1
n & -n
// 清除最低位的1  
n & (n-1)
// 计算1的个数（汉明重量）
int countOnes(unsigned int num) {
    return (num == 0) ? 0 : (num & 1) + countOnes(num >> 1);
}
```
## RGB分量提取
```c
void getRGB(int color, int *red, int *green, int *blue) {
    *red   = (color >> 0)  & 0xFF;  // 0-7位
    *green = (color >> 8)  & 0xFF;  // 8-15位
    *blue  = (color >> 16) & 0xFF;  // 16-23位
}
```
## 异或运算
```c
// 直接使用
a ^ b
// 位运算模拟
(a | b) & ~(a & b)
// 异或性质
a ^ a = 0          // 自反性
a ^ 0 = a          // 与0异或
a ^ b = b ^ a      // 交换律
```
## 备考建议

1. **理解重于记忆**：理解数据在内存中的布局
2. **多敲代码**：亲手实践例子和习题
3. **画图分析**：复杂问题时画内存图和流程图
4. **重点突破**：指针、数组、字符串、链表、动态内存分配
5. **做往年真题**：了解考试题型和侧重点

## 常见易错点

1. 数组越界访问
2. 指针未初始化或野指针
3. 内存泄漏（malloc后未free）
4. 字符串结束符`\0`问题
5. 未定义行为（如多个自增自减在同一表达式）
6. 类型转换导致的精度丢失