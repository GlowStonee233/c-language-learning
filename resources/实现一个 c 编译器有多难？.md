> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.zhihu.com](https://www.zhihu.com/question/63728844/answer/101227544839) 为什么这些基础工具都是国外开发的？

不难，本文这就手把手教你入门。

计算机专业专门有一门课是讲这个的，你完全可以照着从头开始写:

![](https://picx.zhimg.com/v2-48c3970ebb16e5a2471c1f0fb9526ee5_r.jpg?source=2c26e567)![](https://picx.zhimg.com/v2-00b7ea72722edca8e5cada04a0721b6f_r.jpg?source=2c26e567)![](https://picx.zhimg.com/v2-80c813eb2a0f0918a150748301f20373_r.jpg?source=2c26e567)

没错，看完前四页，我们就知道了，写一个编译程序只需要五步，只比把大象放冰箱多两步。这本书也并不厚，一共385页，除去练习，一天只看一页，一年肯定看完了，如果你像大学生一样有时间，也许一周也可以 。

你可能很快就发现这本书好是好，操作起来有点鸡生蛋蛋生鸡的问题: 不能用c语言去写c语言对吧？不能用基于c语言实现编译器的语言(比如golang啥的)写c编译器吧？否则评论区肯定有人会说你这个编译器不纯，这个问题也好解决，你可以学一门更老的语言(比如Basic啥的)来搞，也可以一步到位，直接学汇编(用cpu指令集编程，酷不酷？彻底不彻底？)，现在是x86的天下，就学x86汇编好了:

![](https://pica.zhimg.com/v2-56bb7c4ba2e640da765e82a13bb3c0a7_r.jpg?source=2c26e567)![](https://picx.zhimg.com/v2-6eeb7144c71732e11afba265ba29224a_r.jpg?source=2c26e567)

正如目录中所展示的，用汇编程序写图形游戏都属于教科书水平，你完全不用担心用汇编写不出词法分析器语法分析器这些东西，唯一的问题是这本书比上一本厚，读起来也更晦涩，你可能要花比上本书多一倍的时间读完:

![](https://picx.zhimg.com/v2-95be9430f6b6554bc32363a823176875_r.jpg?source=2c26e567)

你已经完全精通汇编语言了，用它是实现任何具体功能都难不倒你了，只是相当耗时，你看上面，读文件这么一个简单的需求它都得写个好几页才能实现，为了更高效的写代码，一个比较现实的做法是先设计一个简单语言(或者就用c语言规范的c0子集)把常见控制和计算能力封装下，并用汇编实现他的编译器，我们就叫他c0吧，然后再用这个较为高级的c0语言实现更高级的c语言编译器。

假设你成功的实现了c0编译器，先恭喜你终于脱离汇编苦海，进入了高级语言的殿堂，但你会发现你在写代码的过程中经常会遇到一些"脑筋急转弯"问题，比如怎么在一个非常大的表中快速查到某个条目？怎么快速又省空间的对一个大表中的条目排序？程序员们称之为算法问题。

好消息这些事也不难处理，大部分前人都总结过，不需要你现想，你只需要再看一本书:算法导论

![](https://picx.zhimg.com/v2-4064c03de23b7a0bf9d96f4fe06901f1_r.jpg?source=2c26e567)

比如快速查询可以用B树，怎么创建和查询B树人家讲的明明白白:

![](https://picx.zhimg.com/v2-7434c570064e4e97a89939b18482f669_r.jpg?source=2c26e567)

事实上树的概念来自于数学，因此如果你要完全看懂本书，你需要参阅学习高等数学，组合数学，离散数学，概率论与统计，复变函数等很多数学课本中的知识，否则可能看不懂这本书里走马观花介绍的这些背景知识:

![](https://pic1.zhimg.com/v2-40c0222e8f1fe2332e4b577d903a8578_r.jpg?source=2c26e567)

这本书比汇编那本书更厚一些(700+页)，也更考验智商和耐力(事实上我大学四年都没看完)。鉴于你也只是把他当做字典一样的工具书来做思路辅助用，看这么深这么广可能会炸，并且你理解了可能也写不出来，所以可以暂时放弃和c语言不共戴天的原则，屈尊看一本用c语言描述的简化版教科书: 数据结构

![](https://pic1.zhimg.com/v2-2de58e24a46020c63d245a2386c4e2aa_r.jpg?source=2c26e567)![](https://picx.zhimg.com/v2-ced03f7a78416c8eab56940e0cac291a_r.jpg?source=2c26e567)

相较于上本书，这本书可谓小而精，每个问题直插心脏，怎么做连代码都给你写好了，鉴于你是要写c编译器的，所以你当然看得懂里面的C代码

![](https://picx.zhimg.com/v2-d2f3d13c2cb61072516031c78af2bae7_r.jpg?source=2c26e567)

这本书侧重讲对一类具体的问题，如何设计合适的数据结构，结合算法，来巧妙而高效的解决问题。

由于这本书(以及前面的几本书)主要讲的是基本原理和算法，你看到的demo都是用面向过程(或者叫流水账)的思路写出来的，用这种思路写出的代码基本上超过500行就难以维护了，为了实现大型需求，你需要更先进的设计思路，学习下面向对象的程序设计

![](https://pica.zhimg.com/v2-fab214a6136ed7d6f5582312e0fe1c06_r.jpg?source=2c26e567)

这真的不是在危言耸听:

![](https://picx.zhimg.com/v2-23b67719b4da3c58e6be54993bf10967_r.jpg?source=2c26e567)

现在你已经精通编程的基本技巧了，不过现在有个问题是写词法分析器和语法分析器的前提是你得知道C标准中的词法和语法有哪些，这个也好办，SAC就有卖，最新的是2024(也就是C24)，要搞就搞最新的，符合国际标准的，这样出来大家才会趋之若鹜的用，对吧：[https://www.sacinfo.cn/s/std_detailed?sid=IEC-117654](https://www.sacinfo.cn/s/std_detailed?sid=IEC-117654)

![](https://pic1.zhimg.com/v2-809f55c6fb4827b19bacdab729b2b567_r.jpg?source=2c26e567)

干大事不拘小钱，买就是了。

你买回来就知道，这个标准真的很大了，一两个月真的写不完，这时候就得再学一下软件工程，学学怎么拆分功能分别写，然后再怎么测试和集成，这属于工程方法论了，和钱学森大佬的工程控制论一样，是干这一行必备的方法论。

![](https://pic1.zhimg.com/v2-7b344c993d25f74e15b0155ff0763d30_r.jpg?source=2c26e567)

好消息是这本书不厚，比第一本还薄，看起来也不晦涩，你突击看的话，一周肯定富余。

好了，现在你胸有成竹了，标准里提到的能力你一定看完就知道该咋实现了，设计也是一刹那间就出来了，开始写吧，编译优化啥的我们先忽略了，跑起来为王。

已知的一点是，现有的gcc14.2源代码包gzip压缩后都有153MB，考虑到它支持了不止c语言一种的编译，我们算c只占20%吧(实际上不止，大部分语言编译器都是基于c的，不过原谅我没开电脑没法细算，下面的估算都是纯拍脑袋，要是估错了别怪我)，30MB，gzip对文本的压缩率一般在50-80%，我们假设是65%，那么估算下来解压后关于c编译器的源码大概有86MB; 平均来说，一个程序员一天大概可以写200行代码，你加个鸡腿，每天写256行，假设一行平均40个字符，那么一天就是8KB，写完这86MB只需要10971人天。

一年有248个工作日，因此你一个人写的话，大概也只需要44.24年，一点都不难，你现在就开始写，2069年建国120年国庆刚好能赶得上，你不要怀疑自己，事实上gnugcc社区的那么多人，也是写了38+年才写到现在的水平(他们还没实现完C24呢，优势在我 )。

![](https://picx.zhimg.com/v2-b4eea90e03d4f9e1f1ab9d42b3fd75c9_r.jpg?source=2c26e567)

等一下等一下，你都能下载到完整的源代码了，你也懂它的原理，如果有必要，你也可以随意改他，那你从头再写一遍的意义在哪呢？

只是因为这是洋人写的吗，还是担心洋人偷你硬盘？

没苦不用硬吃。