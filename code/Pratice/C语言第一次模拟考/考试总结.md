# $T1:cos(x)的泰勒展开$
- 没有注意到只需要用一个循环，导致运行时间很长。
- 将初始值放在了循环外面，导致计算错误。
## 错误代码
```c
#include<stdio.h>
double mycos(double x,int n);
int main(){
    int n;
    double x;
    scanf("%lf %d",&x,&n);
    printf("%.8lf",mycos(x,n));
    return 0;
}
double mycos(double x,int n){
    double up=1.0;
    double down=1.0;
    double sum=0.0;
    for(int i=0;i<=n;i++){
        for(int j=1;j<=2*i;i++){
            down=down*j;
        }
        for(int j=0;j<n;j++){
            up=-up*x*x;
        }
        sum+=up/down;
    }
    return sum;
}
```
## 简单修改版
```c
#include<stdio.h>
double mycos(double x,int n);
int main(){
    int n;
    double x;
    scanf("%lf %d",&x,&n);
    printf("%.8lf",mycos(x,n));
    return 0;
}
double mycos(double x,int n){
    double sum=0.0;
    for(int i=0;i<=n;i++){
        for(int j=1;j<=2*i;i++){
            double down=1.0;
            down=down*j;
        }
        for(int j=0;j<n;j++){
            double up=1.0;
            up=-up*x*x;
        }
        sum+=up/down;
    }
    return sum;
}
```
## 大幅简化版（只用一个循环）
```c
double mycos(double x, int n) {
    double up = 1.0;      // 分子
    double down = 1.0;    // 分母
    double sum = 1.0;     // 累加和，从第0项开始
    for(int i = 1; i <= n; i++) {
        up = -up * x * x;// 更新分子：x^(2i) = x^(2(i-1)) * x²
        down = down * (2*i-1) * (2*i);// 更新分母：(2i)! = (2(i-1))! * (2i-1) * (2i)
        sum += sign * up / down;// 累加当前项
    }
    return sum;
}
```
## 最简版本
```c
#include<stdio.h>
double mycos(double x, int n);
int main(){
    int n;
    double x;
    scanf("%lf %d",&x,&n);
    printf("%.8lf",mycos(x,n));
    return 0;
}
double mycos(double x, int n) {
    double term = 1.0;  
    double sum = 1.0;  
    for(int i = 1; i <= n; i++) {
        term = term * (-1) * x * x / ((2*i-1) * (2*i));
        sum += term;
    }
    return sum;
}
```
## 利用数组减少计算次数

```c
double mycos(double x, int n) {
    int i=0;
    double sum=0;
    double down[20];    
    long up[20];
    down[0]=1;
    up[0]=1.0;
    for(i=0;i<19;i++){  
        down[i+1]=(i+1)*down[i];
        up[i+1]=-x*x*up[i];
    }
    for(i=0;i<n;i++){
        sum+=up[i]/down[2*i];
    }
    return sum;

}
```
# T2:逆序数
## 错误代码
```c
#include<stdio.h>
int main(){
    int n;
    scanf("%d",&n);
    int arr1[100];
    int arr2[100];
    int j=0;
    int i=0;
    int temp=n;
    int count=0;
    while(temp>0){
        arr1[count]=temp%10;
        temp=temp/10;
        count++;
    }
    for(i=count-1;i>=0;i--){
        arr2[j]=arr1[i];
        j++;
    }
    int result=0;
    for(i=0;i<count;i++){
        result=result+arr2[i];
        result=10*result;
    }
    if(result%n==0){
        printf("%d*%d=",n,result/n);
        for(i=0;i<count;i++){
            printf("%d",arr2[i]);
        }
    }
    else{
        printf("%d ",n);
        for(i=0;i<count;i++){
            printf("%d",arr2[i]);
        }
    }
}
```
错误分析：将提取结果误认为正序排列，导致错误。同时将数列转化为整数时，算法错误导致误差达到十倍
## 正确代码
```c
//计算逆序数
#include<stdio.h>
int main(){
    int n;
    scanf("%d",&n);
    int arr[100];
    int i=0;    
    int count=0;
    int result=0;
    int temp=n;
    while(temp>0){
        arr[count]=temp%10;
        temp=temp/10;
        count++;
    }//获取n的每一位数字（倒序排列）
    for(i=0;i<count;i++){
        result=10*result+arr[i];
    }//获取逆序数
    if(result%n==0){
        printf("%d*%d=",n,result/n);
        for(i=0;i<count;i++){
            printf("%d",arr[i]);
        }
    }
    else{
        printf("%d ",n);
        for(i=0;i<count;i++){
            printf("%d",arr[i]);
        }
    }
}
```